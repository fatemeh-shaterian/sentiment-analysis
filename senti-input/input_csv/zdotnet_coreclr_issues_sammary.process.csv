issueId,issue_number,url,user,like,dislike,laugh,hooray,confused,heart,body
349687554,19428,https://api.github.com/repos/dotnet/coreclr/issues/19428,noahfalk,2,0,0,0,0,0,multicore jit has been able to provide startup wins after it is trained but in many scenarios generating and persisting the training data is problematic we could instead analyze the il of methods as they were being generated to infer the additional methods they are likely to call in the near future as a simple case if we were jitting a method: foo bar baz();} we have a pretty strong expectation that bar and baz will be needed in the near future lets naively assume that each of foo bar and baz take us to compile foo takes us to run once jitted and at the us mark of compiling foo the jit will call back to the runtime alerting it that bar and baz are good speculative compilation candidates in the current runtime foo would complete after us whereas in a perfectly parallelized world with no other overhead it would complete in us in practice the wins would probably be less than what we see from trained multicore jit but wed need further investigation to determine how much less we might still be able to capture a significant fraction the advantage is that it doesnt create any dependencies that the application needs to account for which gives it broader scenario reach
349644129,19416,https://api.github.com/repos/dotnet/coreclr/issues/19416,AaronRobinsonMSFT,1,0,0,1,0,0,the build-test.cmd handles all test asset building native/managed on the windows platform this is not the case for build-test.sh which is used on non-windows platforms.the build-test.sh script does not handle native test asset building instead the build.sh script uses generate all repo projects based on the root cmakelists.txt see clr_cmake_build_tests this is in contrast to windows where native test projects are generated from the tests\cmakelists.txt file.this appears to be for historical reasons but the ramifications are bad the generation of test projects for non-windows has organically become dependent on many settings in the root cmakelists.txt file.cc russkeldorph janvorli bruceforstall
349586900,19412,https://api.github.com/repos/dotnet/coreclr/issues/19412,mikedn,2,0,0,0,0,0,this came up occasionally in discussions but afaik theres no issue associated with it and imo there should be due to the significant negative impact gt_asg nodes have on ryujits ir imo its one of the worst ir features if not plain and simple the worst so far i only encountered pros and no cons its an extra ir node wastes memory and slows down ir traversal it imposes a model where the meaning of some nodes depends on the context a gt_lcl_var on the rhs is a use but on the lhs is a def the jit uses various means to deal with this issue gtf_var_def gtf_ind_asg_lhs gtgetparent etc it complicates ud chain traversal ssa gives you the gt_lcl_var node on the lhs from there you need to use gtgetparent to get the gt_asg node and then get the assignments second operand if youre lucky the lhs follow the assignment otherwise gtgetparent will need to traverse multiple nodes it requires additional work to transform hir into lir the later does not use assignment nodes it doesnt match the il model that uses stores while i dont think that the ir has to strictly follow the il model this one seems like a huge and unnecessary deviation it doesnt follow the assembly model either one could argue that mov eax ebx is assignment but thats only true if eax and ebx happen to be enregistered variables otherwise youd be looking at mov eax ebx which is more similar to a store.anyone knows any advantages?afair phoenix did have assign but its ir was very different looking more like assembly i know next to nothing about llvm but i dont think it has assignment
349564124,19409,https://api.github.com/repos/dotnet/coreclr/issues/19409,kbaladurin,1,0,0,0,0,0,we should clear thumb bit of the address before flushing icache otherwise we may not flush the cache for the first byte of the instruction.this patch should fix unexpected sigills during debugging: program received signal sigill illegal instruction. switching to thread xace lwp xaeaee in gdb bt xaeaee in xbad in update_get_addr from lib/ld-linux.so x in backtrace stopped previous frame identical to this frame corrupt stack?)(gdb x/i pc xaeaee blx r xaeaee nop xaeaee nop xaeaeea add sp xaeaeec ldmia.w sp r r r r r pc
349438568,19407,https://api.github.com/repos/dotnet/coreclr/issues/19407,v0l,2,2,0,0,0,0,tested sample code on net net core behavior is the same for all why is this handled like this clearly the call to printit
349364608,19402,https://api.github.com/repos/dotnet/coreclr/issues/19402,alan1010ten,1,0,0,0,0,0,how to run dotnet core app on x without os
348952175,19373,https://api.github.com/repos/dotnet/coreclr/issues/19373,annaaniol,9,1,0,0,0,0,introducing a dllmap design document
348838543,19362,https://api.github.com/repos/dotnet/coreclr/issues/19362,tannergooding,1,0,0,0,0,0,this resolves
348547174,19345,https://api.github.com/repos/dotnet/coreclr/issues/19345,AndyAyersMS,0,0,0,1,0,0,remove almost all of the code in the jit that tries to maintain local refcounts incrementally also remove lvasortagain and related machinery.explicitly sort locals before post-lower-liveness when optimizing to get thebest set of tracked locals.explicitly recount after post-lower liveness to get accurate counts afterdead stores this can lead to tracked unreferenced arguments tolerate thisduring codegen
347639351,19290,https://api.github.com/repos/dotnet/coreclr/issues/19290,BruceForstall,1,0,0,0,0,0,fixes
347536569,19279,https://api.github.com/repos/dotnet/coreclr/issues/19279,scalablecory,1,0,0,0,0,0,id like the jit to detect when one branch leads to another branch and fold them into a single branch.im sure this optimization has a specific name in compiler theory but i dont know it if youll excuse a dumb example: int initialbranching(string x if x foo return if x bar return if x baz return return string subsequentbranching(string x int y initialbranching(x if y return x if y return x return other;} here a sufficiently advanced compiler should be able to transform this into something like: string folded(string x if x foo goto zero if x bar goto zero if x baz goto one goto other zero return x one return x other return other;} why? obviously the dumb example is not what im actually doing for performance purposes im updating a text parser from depending on char to be encoding-agnostic in some places it needs to allow injecting inlineable sub-parsers that handles encoding-specific things returns length of newline if matched if not matched if more data is needed.int isnewline(readonlyspan
347526227,19278,https://api.github.com/repos/dotnet/coreclr/issues/19278,tannergooding,1,0,0,0,0,0,this updates the templated x hwintrinsic tests to print out the issupported status for each isa in order to help diagnose the state of ci machines in the case of failure
347093498,19251,https://api.github.com/repos/dotnet/coreclr/issues/19251,tannergooding,1,0,0,0,0,0,this marks the hwintrinsic types as readonly this allows the c compiler to assume the type is immutable and it can then perform certain optimizations when used in the context of other readonly types fields etc
345924137,19203,https://api.github.com/repos/dotnet/coreclr/issues/19203,fiigii,2,0,0,0,0,0,during benchmarking aos/soa ray-tracer we found that the vector benchmark raytracer is much slower on windows than linux execution time windows linux baseline raytracer s s packettracer s s performance gains x x according to vtune analysis this gap is caused by the crt math library which raytracer uses math.pow at windows! image linux! image the left side aos means raytracer we can see ucrtbase.dll on windows has much more time consuming and instruction retired than libm-..so on linux.the data is collected on core i vs but core i vs has the same performance gap
345891960,19199,https://api.github.com/repos/dotnet/coreclr/issues/19199,jeroen-mostert,1,0,0,0,0,0,apologies in advance if this question is particularly ignorant or does not belong here i browsed the repo for things tagged question and it didnt seem particularly out of order to raise an issue for clarification.as corprof.idl explains for the functionenter functionleave and functiontailcall callbacks set with icorprofilerinfo*::setenterleavefunctionhooks it is very important to note that these function implementations must be declspec(naked since the ee is not saving any registers before calling any of them you must save all registers you use including fpu registers if the fpu stack is not empty and you intend to use it.alright so why does the ee not save any registers as opposed to following the platform abi rules for volatiles this mostly leads to profilers doing a predictable register saving dance before invoking another function the regular way this is nasty since it requires some platform-specific assembler thats not covered by intrinsics the alternative being il rewriting of any and all methods you want to instrument which has its own issues).whats the design or implementation rationale behind this speed but if every profiler has to save registers anyway practically speaking assuming not too many are written in raw asm where would those savings come in if no hook is set surely the ee could just invoke a stub that literally does nothing as i believe it already does while if a hook is set it can call a stub to save the volatiles before the profiler proper removing this burden from profilers?this requirement gets onerous as youre going cross-platform as illustrates but im just interested in why this is or was deemed necessary/expedient in the first place
345399817,19182,https://api.github.com/repos/dotnet/coreclr/issues/19182,BruceForstall,1,0,0,0,0,0,jited code but not crossgen/ngen code always generates direct calls using a byte movw/movt/blx sequence e.g.: movw r xmovt r xbblx r corinfo_help_assign_ref it should instead generate using the byte bl instruction: bl corinfo_help_assign_ref the limitation is that bl has a relative range of bits or to bytes from the instruction if this range is not sufficient we need a fallback mechanism note that when we are generating code we dont know the address it will be placed at so we dont know what range we actually need.one option is to implement jump stub logic for arm as we have for arm/amd another option is to implement a rejit mechanism where if the relocation for this call fails during recordrelocation then we re-jit the function preventing the jit from using direct bl calls we could either prevent it for just this function or for ever jit-ed function thereafter in the same process.the determination of whether a call is close enough is done in lowerarmarch.cpp lowering::iscalltargetinrange this calls validimmforbl which asks the vm via ceejitinfo::getreloctypehint whether it is ok for arm this function always says no for ngen it says yes but then if we overflow the required relocs by generating a too-large ngen image it restarts the ngen process and disallows direct branches.)it might be worth doing some investigation to see how many of these calls are likely to be possible to be made direct most seem to be to jit helpers so it would require the generated code buffer to be relatively close to coreclr.dll
345359251,19176,https://api.github.com/repos/dotnet/coreclr/issues/19176,ahsonkhan,1,0,0,0,0,0,fixes tornhoof jarlob
345354239,19174,https://api.github.com/repos/dotnet/coreclr/issues/19174,4creators,1,0,0,0,0,0,over last couple of months coreclr tests accumulated increasing number of compiler warnings c il c which create a lot of noise according to my checks there were couple of thousands of them for inner loop tests only.there are increasing number of msbuild warnings as well however they should be fixed after projects are converted to sdk style.one of actions which would prevent accumulation of warnings would be treating them as errors by compilers what would force everyone to handle them explicitly elimination of current warnings may take more than pr and it would be good to avoid them in future.cc bruceforstall jkotas aaronrobinsonmsft jashook tannergooding andyayersms
345324513,19168,https://api.github.com/repos/dotnet/coreclr/issues/19168,chsienki,1,0,0,0,0,0,update the base services test projects to sdk style projects
344999054,19145,https://api.github.com/repos/dotnet/coreclr/issues/19145,CarolEidt,1,0,0,0,0,0,the register allocator uses operisshiftorrotate as the assertion for the method that gets the kills for the class of instructions that use rcx as the shift amount register expand it to include rsh_lo and lsh_hi .fix
344420602,19120,https://api.github.com/repos/dotnet/coreclr/issues/19120,wojtpl2,0,0,0,1,0,0,currently you can create net core application with com object: c guid(ceef-a-d-bb-edcb comvisible(true public interface icomexampleclass icommodelclass examplemethod(string param string param guid(abf--a-a-fdacb classinterface(classinterfacetype.none comvisible(true public class comexampleclass icomexampleclass public icommodelclass examplemethod(string param string param return new commodelclass result param param guid(faeede-ece-d-ba-afabe comvisible(true public interface icommodelclass string result get set guid(ccb-d--a-fffaebec classinterface(classinterfacetype.none comvisible(true public class commodelclass icommodelclass public string result get set but you cant generate tbl file: cmdc:\program files x)\microsoft sdks\windows\v.a\bin\netfx tools\tlbexp.exe comexample.exe out:comexample.tlb you cant register assembly using regasm: cmdc:\windows\microsoft.net\framework\v regasm.exe tlb:comexample.tlb c:\users\wnagorsx\source\repos\consoleapp\consoleapp\bin\x\debug\net..\win-x\comexample.exe how can i register com objects from net core and then use it in cpp existing application?i was trying publish application with self-contained it doesnt work too
344191320,19115,https://api.github.com/repos/dotnet/coreclr/issues/19115,BruceForstall,1,0,0,0,0,0,"remove support for specifying the toolset directory for arm,which was used to point to an internal toolset.building for arm now works just like the other platforms e.g.invoke build arm .the requirements visual studio update or later with arm toolset installed windows sdk or later cmake or later"
343728618,19089,https://api.github.com/repos/dotnet/coreclr/issues/19089,acmyu,1,0,0,0,0,0,right now rrdump is only supported on windows x and x it works on linux but the rrdumptests for that os are disabled because of errors it hasnt been tested on osx or arm
343478159,19078,https://api.github.com/repos/dotnet/coreclr/issues/19078,Zhentar,1,0,0,0,0,0,"csi i sizeof(uint refdestination i; jits down to asmlea eax, rdx*+ mov dword ptr rcx ,eax all well and good but if i cut out the intermediate set.... csrefdestination i sizeof(uint jit gives me asm mov eax,edx shl eax add eax mov dword ptr rcx ,eax its bit unfortunate that lea isnt getting used in the scenario where it could also cut out an additional instruction"
343424249,19077,https://api.github.com/repos/dotnet/coreclr/issues/19077,AndyAyersMS,1,0,0,0,0,0,consolidate various compiler globals used when setting local var refcounts by folding them into the visitor lvamarkrefscurblock lvamarkrefscurstmt lvamarkrefsweightremove the largely vestigial lvprefreg and associated methods to setor modify this field havent verified but this is likely a remmant ofthe legacy backend.in the one remaning use lcl var sorting predicates swap in lvisregarg instead which gets most of the same cases
343377638,19076,https://api.github.com/repos/dotnet/coreclr/issues/19076,Zhentar,1,0,0,0,0,0,"c source in this gist to vtune of my execution time is in my functions prologue this was unexpected because it hadnt been in previous iterations and my function body had unfortunately not improved at all).looking at the the disassembly i see: asmlineenumerator.movenext push rdi push rsi sub rsp,h mov rsi,rcx lea rdi, rsp+h mov ecx xor eax,eax rep stos dword ptr rdi mov rcx,rsi mov rax,fcdedh mov qword ptr rsp+h ,rax the rep stos dword in there seems rather odd at the very least it should be a rep stos qword with half as many iterations although im not sure it would be any faster on my skylake but also i dont think theres any x architecture for which a byte rep stos is faster than a reasonable unrolled version and the unrolled version wouldnt even be particularly large and some of the comments in the jit code seem to suggest that rep stos shouldnt ever be getting emitted"
343292606,19071,https://api.github.com/repos/dotnet/coreclr/issues/19071,Zhentar,2,0,0,0,0,0,bsr bsf are functionally equivalent to lzcnt tzcnt for non-zero values except that instead of needing haswell/piledriver plus the minimum requirement is would be nice for things like span.indexof where its only applied to non-zero values.bswap is an instruction that reverses the order of bytes its supposed to be good for endian-ness conversions but i care because word on the street is that its better than rotates for entropy diffusion in hash functions leading to some of the trendy new fast hash functions such as farmhash and tha using it
343248480,19066,https://api.github.com/repos/dotnet/coreclr/issues/19066,tannergooding,0,0,0,0,0,1,this is a port of which we determined should be in coreclr next to the ilasm package so that it can easily be used/consumed from source-build and related efforts).fyi tmat jaredpar rainersigwald eerhardt weshaggard alexperovich michalstrehovsky all the people who reviewed/commented on the previous pr
342940094,19051,https://api.github.com/repos/dotnet/coreclr/issues/19051,stephentoub,3,0,0,0,0,0,timespan has three standard formats c g and g yesterday i updated its implementation with throughput improvements for c the default based on porting the design from utfformatter this pr does so for g/g.initially i wasnt going to handle g/g as they factor in culture utfformatter doesnt but even with accessing the current culture there are still significant wins to be had i was also going to keep the c and g/g implementations separate to avoid bogging down the default c formatting with additional conditions needed to support g/g but the overhead incurred for that turns out to be minimal enough that its worth keeping one implementation rather than two mostly-similar ones the impact on c is mostly within noise.this pr makes a significant throughput improvement for g/g formatting it also removes several unnecessary allocations such that tryformat with g/g is now allocation-free and tostring just allocates the asked-for string).benchmark: c#using system;using benchmarkdotnet.attributes;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.running; memorydiagnoser inprocess public class benchmark private static void main benchmarkrunner.run
342703557,19023,https://api.github.com/repos/dotnet/coreclr/issues/19023,noahfalk,3,0,0,0,0,0,dotnet/jit-contrib sywhang while investigating im seeing a number of things that look inconsistent and probably need to be fixed or better documented jit folks can you let me know what you think the functionenter methods are a publicly exposed and have a documented abi on linux x we pass functionidorclientid in r msdn documentation doesnt mention a custom calling convention so developers would expect rdi i believe we picked r for good reason so i propose we change msdn to match the runtime sometimes provides the implementation of the profileenter call as an intermediary between the jitted code and other forms of the profiler callback on linux x that gives us non-agreeing definitions of the register preservation requirements the msdn docs claim the caller must preserve all registers the code comments above the runtime profileenternaked implementation suggest a number of registers are not preserved incidentally the comments arent self-consistent either xmm and rdx are both preserved and not preserved the implementation of the jit has different expectations about what would be preserved for example is it really safe to trash the argument registers in the prologue of the caller the implementation of the assembly routine preserves all the integer argument registers dont have a good sense of exactly what the jit expects to be preserved across this call for the code to run correctly but whatever it is id like to bring our own comments implementation and msdn docs into alignment with it i suspect there may be discrepancies for the register preservation requirements on other architectures but im happy to start with linux x.thanks noah
342495774,19001,https://api.github.com/repos/dotnet/coreclr/issues/19001,stephentoub,1,0,0,0,0,0,jit/hardwareintrinsics/x/avx/avx_ro/avx_ro.sh begin execution users/dotnet-bot/j/workspace/dotnet_coreclr/master/x_checked_osx._innerloop_tst_prtest/bin/tests/osx.x.checked/tests/core_root/corerun avx_ro.exe running add.double test running add.single test running addsubtract.double test running addsubtract.single test running and.double test running and.single test running andnot.double test running andnot.single test running blendvariable.double test running blendvariable.single test running ceiling.double test running ceiling.single test running divide.double test running divide.single test running duplicateevenindexed.double test running duplicateevenindexed.single test running duplicateoddindexed.single test running extract.byte test avx_ro.sh line abort trap core dumped debuggerfullpath core_root/corerun exepath clrtestexecutionarguments expected actual
342406741,18990,https://api.github.com/repos/dotnet/coreclr/issues/18990,stephentoub,2,0,0,7,0,0,improves the throughput of the null/c/t/t default format for timespan.tostring/tryformat porting over the approach/specialization from utfformatter.contributes to jkotas danmosemsft ahsonkhan benchmark: c#using system;using benchmarkdotnet.attributes;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.running; memorydiagnoser inprocess public class benchmark private static void main benchmarkrunner.run
342140374,18979,https://api.github.com/repos/dotnet/coreclr/issues/18979,AndyAyersMS,2,0,0,0,0,0,this is a preparatory change for auditing and controlling how localvariable ref counts are observed and manipulated.see for context.no diffs seen locally no tp impact expected.there is a small chance we may see some asserts in broader testingas there were places in original code where local ref counts wereincremented without checking for possible overflows the new apiswill assert for overflow cases
342133475,18977,https://api.github.com/repos/dotnet/coreclr/issues/18977,dotnetjt,1,0,0,0,0,0,hi noahfalk this is to continue the discussion from a closed issue prior.im slowly porting our windows clr profiler to linux everything was going spectacularly well until i tried to use the icorprofilerinfo::getfunctionenterinfo method calling this immediately results in a segmentation fault: hresult hr;cor_prf_frame_info pframeinfo;ulong pcbargumentinfo hr profilerinfo->getfunctionenterinfo(functionid eltinfo pframeinfo pcbargumentinfo null); im smart enough to know the issue is probably a bad pointer for eltinfo which of course is going to be the enter stub code lets pretend for a moment that i dont know or understand assembly or calling conventions enough to and that i only got my windows version working with the help of some really great samples that magically worked heres my setup of the elt hooks: hr profilerinfo->setenterleavefunctionhookswithinfo((functionenterwithinfo*)methodentered functionleavewithinfo*)methodleft functiontailcallwithinfo*)methodleft); these are defined as: extern c void methodentered(functionid function_id_or_client_id cor_prf_elt_info elt_info void methodleft(functionid function_id_or_client_id cor_prf_elt_info elt_info);} and finally the assembly behind all this which is pretty much a straight lift of asmhelpers.s but with method names changed: .intel_syntax noprefix#include unixasmmacrosamd.inc#define real dword#define real qword.equ sizeof_profile_platform_specific_data x x includes fudge to make fp_spill right.equ sizeof_fp_arg_spill x*.equ sizeof_stack_frame sizeof_profile_platform_specific_data sizeof_fp_arg_spill.equ profile_enter x.equ profile_leave x.equ profile_tailcall x note register preservation scheme preserved all non-volatile registers rax rdx xmm xmm not preserved integer argument registers rcx rdx r r floating point argument registers xmm volatile integer registers r r volatile floating point registers xmm upper halves of ymm registers on avx which are volatile extern_c void methodentered(functionidorclientid functionidorclientid size_t profiledrsp note note>nested_entry methodentered text nohandler upon entry r clientinfo r profiledrsp push_nonvol_reg rax lea rax rsp x caller rsp mov r rax x return address push_argument_register rdx alloc_stack sizeof_stack_frame correctness of return value in structure doesnt matter for enter probe setup profileplatformspecificdata structure xor r r nullify r mov rsp x r r is null struct functionid field save_reg_postrsp rbp x struct rbp field mov rsp x rax caller rsp struct probersp field mov rsp x r return address struct ip field mov rsp x r struct profiledrsp field mov rsp x r return value struct rax field mov rsp x r r is null struct hiddenarg field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field mov rsp x rdi struct rdi field mov rsp x rsi struct rsi field mov rsp x rdx struct rdx field mov rsp x rcx struct rcx field mov rsp x r struct r field mov rsp xa r struct r field mov r x profile_enter mov rsp xa rd struct flags field get aligned stack ptr rsp frame_size lea rax rsp xb and rax we need to be able to restore the fp return register save fp return registers movdqa rax x xmm movdqa rax x xmm end_prologue rdi already contains the clientinfo mov rdi r lea rsi rsp x call c_pltfunc(entermethodstub restore fp return registers lea rax rsp xb and rax movdqa xmm rax x movdqa xmm rax x restore arg registers mov rdi rsp x mov rsi rsp x mov rdx rsp x mov rcx rsp x mov r rsp x mov r rsp xa begin epilogue free_stack sizeof_stack_frame pop_argument_register rdx pop_nonvol_reg rax retnested_end methodentered text extern_c void methodleft(functionidorclientid functionidorclientid size_t profiledrsp note note>nested_entry methodleft text nohandler upon entry rdi clientinfo rsi profiledrsp push_nonvol_reg rbx lea rbx rsp x caller rsp mov r rbx x return address rdx should be saved here because it can be used for returning struct values push_argument_register rdx alloc_stack sizeof_stack_frame correctness of argument registers in structure doesnt matter for leave probe setup profileplatformspecificdata structure xor r r nullify r mov rsp x r r is null struct functionid field save_reg_postrsp rbp x struct rbp field mov rsp x rbx caller rsp struct probersp field mov rsp x r return address struct ip field mov rsp x rsi struct profiledrsp field mov rsp x rax return value struct rax field mov rsp x r r is null struct hiddenarg field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field movsd real ptr rsp x xmm struct flt field mov rsp x r struct rdi field mov rsp x r struct rsi field mov rsp x r struct rdx field mov rsp x r struct rcx field mov rsp x r struct r field mov rsp xa r struct r field mov r x profile_leave mov rsp xa rd flags struct flags field get aligned stack ptr rsp frame_size lea rax rsp xb and rax we need to be able to restore the fp return register save fp return registers movdqa rax x xmm movdqa rax x xmm end_prologue rdi already contains the clientinfo lea rsi rsp x call c_pltfunc(leavemethodstub restore fp return registers lea rax rsp xb and rax movdqa xmm rax x movdqa xmm rax x restore int return register mov rax rsp x begin epilogue free_stack sizeof_stack_frame pop_argument_register rdx pop_nonvol_reg rbx retnested_end methodleft text it seems to me like the frame isnt being set up right but i just have no idea where to begin help thanks in advance for any insight
342123502,18973,https://api.github.com/repos/dotnet/coreclr/issues/18973,richlander,12,0,0,0,0,2,enable tiered compilation by defaulttiered compilation was added as an optional feature in net core it has been demonstrated that the feature has a lot of value we have done additional test runs that show similar gains.there have been some reports of degradation due to tiered compilation we believe that these cases are in the narrow minority.we would like to do the following enable tiered compilation by default in the first net core preview enable an opt-out of the feature it is opt-in right now collect user feedback on the feature to make a decision if the feature works well enough to ship in enabled.we would make the same changes in master aka net core at the same time.if that doesnt work out we could keep the feature as opt-in and enable it in some set of templates this option isnt a proposal and would be dissapointingrelevant links
342107821,18971,https://api.github.com/repos/dotnet/coreclr/issues/18971,richlander,2,0,0,0,0,0,docker enables you to limit a containers resources this control is great for high-density hosting and other low-resource scenarios developers have the expectation that the application platform respects these limits and does its best to work within them.i wrote a crude test framework to determine how net core behaves when various resource limits are set you can see the test results results i saw made some sense workstation performed better than server gc in this environment however some other characteristics were surprising it could be that my tests were flawed.our first goal is to provide developers with guidance for example if there a minimum memory limit that is required to run an app in production is server gc currently safe to run with docker limits?our next goal is to update the product as appropriate to ensure that it works well with docker limits and then to update guidance appropriately.once we are done id like to re-run this test suite following the guidance i/we should be able to pick a lower bound number this app is very simple and expect it to run w/o memory exhaustion. my app is very simple there will be apps run in containers that require running on multiple cores and take advantage of server gc is that appropriate for docker limits or is there a minimum memory level of mb for example for that scenario we should probably find a different test app that better exhibits the behavior of this type of app
342091649,18969,https://api.github.com/repos/dotnet/coreclr/issues/18969,AndyAyersMS,4,0,0,0,0,0,this issue proposes a series of changes to reduce the overhead and increase the fidelity of local variable reference counts in the jit the main idea is to get rid of the current costly and buggy incremental count maintenance in favor of batch updates that are done just before accurate ref counts are needed.see discussion in for background.expected impact is improvement in tier minopts debug throughput minimal impact to optimized jit throughput smaller frame sizes in some cases where reference counts are currently inflated removal of workarounds to artificially inflate reference counts to avoid assertsthe more accurate reference counts and weighted counts are likely to cause widespread codegen diffs hopefully these will mostly be improvements but some regressions are certainly possible.proposed steps are x encapsulate accesses to lvrefcnt and lvrefcntwtd in an api make backing fields private x characterize when ref count access and update is invalid and update api to flag invalid access x classify invalid accesses and figure out strategies for removing them x once all invalid accesses are removed add appropriate asserts to catch invalid accesses x figure out what actions under lvamarkrefs are required for all compilations vs only needed when optimizing x figure out minopts debug codegen approach x ensure we have an algorithm that can properly recompute counts from scratch x recompute counts after lower change from incremental updates to batched updates decide how often counts need to be made current or track if theyve possibly gone stale sort through codegen diffs resulting from more accurate ref counts and fix what can be fixed try and clean up the logic in lvamarkrefs to split out ref counting from other activitiescc dotnet/jit-contrib
341720613,18952,https://api.github.com/repos/dotnet/coreclr/issues/18952,stephentoub,3,0,0,0,0,0,copies/modifies the recently added tryparse/integerstyle routines for hex in order to provide more optimized parsing since allowhexspecifier cant be used with any other styles other than allowing leading/trailing whitespace deletes existing code paths for parsing hex as i was copying code around i kept getting bitten by different names used for the same thing so i also standardized some parameter names in various helper functions.benchmark: c#using system;using system.globalization;using benchmarkdotnet.attributes;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.running; memorydiagnoser inprocess public class benchmark private static void main benchmarkrunner.run
341693580,18948,https://api.github.com/repos/dotnet/coreclr/issues/18948,pentp,3,0,0,5,0,0,this is the minimum set of changes required to move decimal to a fully managed implementation shared with corert fixes managed decimal performance work over the last year has made it at least as fast as the native implementation often much faster
341691064,18947,https://api.github.com/repos/dotnet/coreclr/issues/18947,jkotas,1,0,0,0,0,0,fixes build breaks with latest visual studio preview.fixes
341582148,18934,https://api.github.com/repos/dotnet/coreclr/issues/18934,Zhentar,0,0,1,0,0,0,from the jit mostly does an impressively good job of optimizing this code: cs public class spantest private struct data public int a b c d private static data data default public void incrementa incrementwrapper(memorymarshal.createspan(ref data.a methodimpl(methodimploptions.aggressiveinlining public static void incrementwrapper(span
341418092,18930,https://api.github.com/repos/dotnet/coreclr/issues/18930,stephentoub,1,0,0,3,0,0,as was recently done for int/int in tjis ports the utfparser approach to parsing to uint/uin.{try}parse specifically for numberstyles.integer the default).also fixes an issue discovered in the previous int/int changes where if the input both has an overflow and has a formatting error e.g int.parse(blah we would end up throwing whichever error was hit first which is a change from net core and netfx the formatexception needs to be preferred over the overflowexception which just means we cant bail early when overflow is detected im putting up another corefx tests pr with more tests that cover this.(i tried to stay fairly true to the utfparser code since time and effort was spent tuning those however this has yielded a fair amount of duplication now with code repeated four times for each of int uint int and uint after all of the perf improvements are in we should look to see whether we can retain almost all of the gains while reducing some of that duplication.)contributes to jkotas ahsonkhan danmosemsft benchmark: c#using system;using benchmarkdotnet.attributes;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.running; memorydiagnoser inprocess public class benchmark private static void main benchmarkrunner.run
341335772,18924,https://api.github.com/repos/dotnet/coreclr/issues/18924,jkotas,0,0,0,2,0,0,fixes
340883541,18897,https://api.github.com/repos/dotnet/coreclr/issues/18897,stephentoub,15,0,0,5,0,0,special-case the default numberstyles.integer format to improve the throughput of int/int.{try}parse ports the implementation from utfparser modifying it to accomodate the additional cases needed for numberstyles.integer e.g culture impact on positive and negative signs trailing nulls leading and trailing whitespace prohibiting additional characters at the end etc.benchmarks: c#using system;using benchmarkdotnet.attributes;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.running; memorydiagnoser inprocess public class benchmark private static void main benchmarkrunner.run
340749995,18889,https://api.github.com/repos/dotnet/coreclr/issues/18889,wfurt,2,0,0,0,0,0,i tested this in my rp as well as ubuntu on qemu im not even able to get list of commands pi@raspberrypi:~/aa lldb dotnet-../dotnet bin/debug/netcoreapp./aa.dll(lldb target create dotnet-../dotnetcurrent executable set to dotnet-../dotnet arm).(lldb settings set target.run-args bin/debug/netcoreapp./aa.dll(lldb rprocess launched dotnet-../dotnet arm)hello world!going to sleep!process stopped thread name dotnet stop reason signal sigstop frame xfce xfce svc x xfcec cmn r xfcf mov r r xfcf ldrls r sp (lldb plugin load dotnet-../shared/microsoft.netcore.app/../libsosplugin.so(lldb sos(lldb sos helpstack dump handlecommand(command sos help)segmentation fault i did same steps on x and lldb-.(lldb sos-------------------------------------------------------------------------------sos is a debugger extension dll designed to aid in the debugging of managedprograms functions are listed by category then roughly in order of......(lldb sos helpsos command help not found home/furt/dotnet-./shared/microsoft.netcore.app/../libsos.so undefined symbol help
340347935,18869,https://api.github.com/repos/dotnet/coreclr/issues/18869,mikedn,1,0,0,0,0,0,follow-up from discussion there are a few inefficiencies around lclvar sorting lvasortbyrefcount that may worth addressing lvasortbyrefcount is called times during compilation of a method and every time it allocates memory for the lvarefsorted array the array could be cached and reused provided that potential increases of the lclvar count are considered unlike lvasortbyrefcount lvatrackedtovarnum is allocated only once but its size is hardcoded to lclmax_tracked and thats extremely large for many methods the number of tracked variables is available before allocating so a more reasonably size can be used again accounting for the fact that the number of lclvars may increase lvatrackedtovarnum is actually redundant lvasortbyrefcount contains the same information lvatrackedtovarnum does have an advantage on bit hosts in that its half the size of lvasortbyrefcount its not clear whats the best solution lvasortbyrefcount does have the advantage that it contains direct pointers to lclvars so it should be faster actual sorting is done using the standard c library qsort this implies an indirect call to the comparer function that blocks inlining and also pays the cost of guard:cf and the comparer code required by qsort is slightly more costly than the c style less predicate a std::sort -like experimental implementation that avoids the indirect calls shows an improvement of in instructions retired all lclvars are sorted but only first lclmax_tracked lclvars need be a partial sort algorithm could be beneficial in those cases where the jit internally generates large number of lclvars i think there was an issue with like lclvars but such cases seem to be rare in corelib there are only a couple of methods with lclvars and the rest are below do we actually need to sort the lclvars or is it enough to just take the top lclvars in no particular order its obvious that as far as liveness is concerned the order of the tracked variables is irrelevant so far i only found a case cse heuristic that appears to depend on the order
339622919,18839,https://api.github.com/repos/dotnet/coreclr/issues/18839,fiigii,3,0,0,0,0,0,this pr ports the current simd benchmark raytracer using vector to a soa algorithm using avx/avx intrinsics the new benchmark keeps the same shading approach of the original raytracer as much as possible so they can generate the same images and be compared directly performance data rendering a k image execution time windows linux baseline raytracer s s packettracer s s performance gains x x the data collected on intel core i x skylake-x ghz ht on turbo on gb ddr mhz windows and ubuntu vtune characterization module level windows! image linux! image to the execution time and the module-level vtune data we can see that the baseline has worse performance on windows due to the crt math library which ucrtbase.dll takes execution time the linux crt math library libm-..so has more reasonable performance the baseline uses math.pow at which calls into crt via p/invoke currently the soa ray-tracer packettracer does not need pinvoke into crt as we implemented a brief simd vectormath.pow in managed code.the most obvious module-level difference between the baseline and soa is that the soa ray-tracer has higher gc overhead shown as coreclr.dll / libcoreclr.so / libc-..so this issue is logged at for further discussion vtune characterization managed code windows! image linux! image codegen issues of ryujit have been logged at vtune characterization coreclr runtime windows! image linux! image
339581770,18837,https://api.github.com/repos/dotnet/coreclr/issues/18837,jakobbotsch,1,0,0,0,0,0,"when the jit was morphing trees like expr it would turn themultiplication into a neg node with the same type as its right operand.this is a problem when the right operand was a small type like typ_ubytebecause the neg node always produces a widened result this could causeproblems when the negation was fed into something that depended on thetype such as a cast to typ_ubyte here the jit would conclude that thecast could be dropped and end up producing a widened result.the solution is to give the tree the same type as the result of theoriginal multiplication.also add a test for this case and for a similar case of expr,which already had a fix.fix no pmi diffs in frameworks or tests except the new test-case for pmi and no crossgen diffs"
339580245,18836,https://api.github.com/repos/dotnet/coreclr/issues/18836,tannergooding,1,0,0,0,0,0,on various architecturesthere exist registers that require different encoding characteristics for example on x there are additional registers available r-r and xmm-xmm which require the use of the rex prefix or a vex-encoded instruction).given that these change how the instruction is encoded it would be beneficial if there was a stress-mode that would prefer these registers in order to help validate that the emitter has them properly handled
339157756,18819,https://api.github.com/repos/dotnet/coreclr/issues/18819,AndyAyersMS,1,0,0,0,0,0,in some cases csc will use ldobj pop to null check a pointer tostruct this change avoids copying the struct value for such constructs.codegen may still redundantly null check if there are multiple such checksin a method.fixes
338763411,18800,https://api.github.com/repos/dotnet/coreclr/issues/18800,stephentoub,0,0,0,1,0,0,ports the code used by utfparser modified to support things utfparser doesnt but datetime{offset{.parseexact do such as single-digit offset hours.local times w/o timezone improve by x.times with timezones improve by x.all cases reduce allocations from bytes across objects down to benchmark: c#using system;using benchmarkdotnet.attributes;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.running; memorydiagnoser inprocess public class benchmark private static void main benchmarkrunner.run
338741754,18795,https://api.github.com/repos/dotnet/coreclr/issues/18795,BruceForstall,0,0,0,1,0,0,now that we have ubuntu arm hardware in the lab these are unnecessary.the jobs have also been failing for months
338447972,18785,https://api.github.com/repos/dotnet/coreclr/issues/18785,tannergooding,0,0,0,1,0,0,this is apis for
338037947,18771,https://api.github.com/repos/dotnet/coreclr/issues/18771,stephentoub,0,0,0,2,0,0,significantly improves the performance of datetime.parseexact r by porting and adapting the utfparser code from corefx for a x throughput increase and also saving three string allocations totaling bytes which more generally we should subsequently look at getting rid of for other formats this optimizes for the default case of a datetimestyles.none specifying any other style falls back to the normal parsing support as that requires handling things such as arbitrary whitespace anywhere in the string.benchmark: c#using system;using benchmarkdotnet.attributes;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.running; memorydiagnoser inprocess public class benchmark private static void main benchmarkrunner.run
337977777,18768,https://api.github.com/repos/dotnet/coreclr/issues/18768,CarolEidt,2,0,0,0,0,0,this is no longer used after
337681891,18759,https://api.github.com/repos/dotnet/coreclr/issues/18759,brianrob,1,0,0,0,0,0,historically these could always be fetched when the event was dispatched because eventsource does direct dispatch in real-time however now that eventpipe can dispatch to eventlisteners the thread id and timestamp arent known for these events and needs to be plumbed through
337636430,18748,https://api.github.com/repos/dotnet/coreclr/issues/18748,mikedn,1,0,0,0,0,0,morph issue: c#static volatile int x; methodimpl(methodimploptions.noinlining) static int test(int a x generates asmg_m_ig:g_m_ig c xor eax eaxg_m_ig c ret similar issue but involving vn/assertion propagation: c#static int test(int a int k a return x k;} generates the same code as above.in this case vn assigned x k the vn of constant and then assertion propagation drops the x load because it only considers persistent side effects.found while working on initially i thought that we can simple make assertion propagation use gtf_all_effect only to discover that it doesnt work because gtnodehassideeffects doesnt pay attention to side effects other than gtf_side_effect so whos paying attention to gtf_order_sideeff and gtf_glob_ref
337593763,18744,https://api.github.com/repos/dotnet/coreclr/issues/18744,tannergooding,2,0,0,0,0,0,there are several hwintrinsics exposed that are only emittable in bit mode and throw a pnse exception if invoked in bit mode regardless of the fact that the general isa.issupported check returns true).we should have a deeper discussion on how to properly expose this data to the consumer of these apis
337045177,18712,https://api.github.com/repos/dotnet/coreclr/issues/18712,tannergooding,1,0,0,0,0,0,pending bmi x andnot bitfieldextract x extractlowestsetbit x getmaskuptolowestsetbit x resetlowestsetbit x trailingzerocountpending bmi multiplynoflags x parallelbitdeposit x parallelbitextract zerohighbits
337036470,18711,https://api.github.com/repos/dotnet/coreclr/issues/18711,stephentoub,1,0,2,0,0,0,improves throughput by by avoiding asspan().copyto and just writing out the characters one-by-one i experimented with playing the same tricks as utfformatter around storing the data in a ulong and blitting it out to the destination span of chars reinterpreted but it didnt make a measurable improvement and increased the code complexity.i also tried porting the tryparse changes from utfparser but depending on the input to a benchmark the new version(s wasnt necessarily faster for example it helped a bit when the input was all caps but it actually hurt when the input was all lowercase the code was also significantly more complex especially once endianness was factored in in the end i decided to leave it as is.contributes to jkotas ahsonkhan
336812118,18695,https://api.github.com/repos/dotnet/coreclr/issues/18695,sbomer,1,0,0,1,0,0,this change removes the old net generated xunit wrapper projects and replaces them with sdk projects targeting netcoreapp built using the sdk instead of buildtools the new wrappers are built the same way during the windows and unix test builds some details building the wrappers binplaces a helper dll into the same output directory for each wrapper i had to fix how we pass arguments in build-test.sh so that i could disable binclash logging by passing a parameter with a space in it for the wrapper build like we do on windows i put some common properties for sdk-style test projects into a common props file and factored some of the existing props to avoid duplication the net core version of xunit doesnt support the msbuild runner so im using the official xunit console runner this and its dependencies get copied over to core_root i removed uses of an older custom xunit package xunit.console.netcore i saw that tried to do this too and ran into issues with helix so i tried to fix helixprep.proj to use the new runner suggests that tests.targets from buildtools might need to be fixed as well but i didnt see any uses of it that would cause problems i might have missed something in which case that will need to be updated in buildtools does anyone know how i can test the helix stuff on this pr the benchmark and performance projects were updated to use the new runner as well but i didnt know how to validate the change andyayersms do you know how i can run these this includes runtest.py a script jashook wrote to unify how we run tests between platforms runtest.py will build runtest.proj which calls the xunit console runner like we do on windows runtest.sh has been kept unchanged for now and will still scan the directory for sh files to run./cc russkeldorph
336781727,18692,https://api.github.com/repos/dotnet/coreclr/issues/18692,mjsabby,1,3,0,0,0,0,is there a technical reason or downside to having multi-module assemblies in coreclr removed the code associated with feature_multimodule_assemblies since it was never defined.if there isnt id like to propose we bring this feature back
336409775,18678,https://api.github.com/repos/dotnet/coreclr/issues/18678,AndyAyersMS,1,0,0,0,0,0,"some data on how often we drop assertions from investigations into via pmi over fx):table size num methods avg assertion count methods with dropped assertions overall this doesnt seem too bad only about of methods lost assertions from table size limits i unfortunately didnt track how many of the size cases were ones where we deliberately limited the size for throughput reasons.table size is determined by looking at compilcodesize which will not take additions from inlining into account among other things so it seems like we perhaps could find a better size predictor.or perhaps just allow the table to grow heres a breakdown of how many methods would fit into our existing size bins:assertion count methods more than max number of assertions seen was in a method that used a size table in microsoft.codeanalysis.visualbasic.visualbasiccommandlineparser:parse(ref,ref,ref,ref):ref:this so of these were dropped.there is obviously some consideration of the overall cost of the subsequent dataflow analysis too which is roughly proportional to max assertion size number of blocks so if we allow max assertion size to scale up with blocks we potentially see some quadratic behavior but this seems perhaps solvable too we generate all or more assertions initially and then only limit the ones we use if we see bad scaling.this might let us also try and prioritize which assertions should survive though i dont have any particular idea yet how to formulate that something like the value number equivalent of weighted ref count usage note today we actually generate all assertions assertion gen doesnt early out once the table is full though perhaps it should it just stops recording assertions once the table fills up so we are already paying the cost of finding all these assertions and the table size itself is not a burdenso a rough proposal would be to find and record all assertions allowing the table to grow larger with perhaps some size limit and have a budget based on blocks assertions and if over budget start trimming assertions somehow to get under budget"
336390569,18675,https://api.github.com/repos/dotnet/coreclr/issues/18675,AaronRobinsonMSFT,1,0,0,0,0,0,the pinvoke scenario surface area is large and the coreclr repo doesnt have coverage that would be considered adequate missing areas not exhaustive arrays safehandles criticalhandles dllimport searching with unicode characters
336010497,18658,https://api.github.com/repos/dotnet/coreclr/issues/18658,brianrob,1,0,0,0,0,0,right now eventpipe is only controllable via environment variables and private reflection we should add an out-of-process control mechanism to significantly improve usability
336007737,18654,https://api.github.com/repos/dotnet/coreclr/issues/18654,brianrob,2,0,0,0,0,0,the following platforms currently dont get pgo optimized windows arm windows arm linux arm linux arm osx x
335920080,18649,https://api.github.com/repos/dotnet/coreclr/issues/18649,brianrob,1,0,0,0,0,0,first functional implementation of event dispatch from eventpipe to managed eventlistener enabling native runtime events to be dispatched to eventlistener.this implementation has the following limitations to be improved in future prs cannot be run at the same time as trace file collection using eventpipe each event dispatch requires a pinvoke to get the next event from eventpipe some required event metadata isnt currently exposed thread id timestamp activity id)im in the process of offline validating corefx etw/eventsource tests are unaffected
335572264,18642,https://api.github.com/repos/dotnet/coreclr/issues/18642,BruceForstall,1,0,0,0,0,0,currently reg_opt_rsvd is defined as r this is a preserved register which means if we need to reserve it we also need to save/restore it in the prolog/epilog.can we change this to scratch register lr instead to avoid this?(we cant obviously use the other scratch register r because it is used in some special cases such as vsd dispatch
335545893,18640,https://api.github.com/repos/dotnet/coreclr/issues/18640,hypersw,8,0,0,0,0,1,goal enable interop with native libraries with com abi and a reasonable subset of com features on all supported platforms. *related issue with generic discussion issue is to list specific work areas required to achieve the functionality rcw runtime callable wrappers managed proxy for a native vtable addref on native iunknown until managed proxy is finalized or marshal release/finalrelease turn managed casts into qi calls to native iunknown turn reflection/dynamic into idispatch(ex calls to native object ccw com callable wrappers generate vtable expose native pointer to it keep gc root until final release from native side turn idispatch calls into reflection/dynamic calls on the managed object marshalling mostly the same as in pinvoke non-preserve-sig handling hresult into exception for rcw exception into hresult for ccw out parameter vs return value transform pointer<->rcw and object<->ccw transform supposedly most of the implementation should already be available from the net framework code winapi implementations should be substituted with crude fallbacks for trivial cases no activation scenarios no cross-apartment call marshalling no proxy/stubs activation manual from a dll file or possibly side-by-side scenarios at first activation is out of scope suppose we create the first com object with external means e.g pinvoke getobjectforiunknown).here are example scenarios for possible application of this functionality clr debugger interfaces icordebug et al we have a success story of running the cross-platform implementation of debugger with native com interop from c with mono on linux and mac mono has huge problems with correctness of the implementation yet if youre using only core features and trivial marshalling its working enough to have a functioning debugger the problems do not look fundamental just of the quality sort obviously we would now like to run the same code on coreclr visual studio com interfaces have proven a working example of a large-scale native-managed interop with native and managed parts mixed together with no clear separation thats not exactly about porting but thats a good example of a multi-technology app with native/managed interop api a few of our own helper libraries on windows are exposing com interfaces for object-oriented interaction with the app this experience is nice to have on any platform
335502529,18637,https://api.github.com/repos/dotnet/coreclr/issues/18637,natethegreat44,5,0,0,0,0,0,"hi,we have an asp.net core app that recently started receiving unexplainable outofmemoryexceptions after deployment on thursday june the exceptions are not usually fatal but once they start they grow worse until eventually the dotnet process crashes things are usually good for about hours after launch and it doesnt seem to matter much whether things are under load or not were using blue/green deployments and our inactive cluster experiences crashes about as much as the active cluster.this app serves as an integration layer for other restful http services and as such makes extensive use of the httpclient i.e were not explicitly using any new http apis from core were using the standard alpine docker images running on linux in aws prior to june we were on aka since june and for quite a while before that without any outofmemoryexceptions apparently our build on thursday was upgraded to via the sdk-alpine and runtime-alpine docker base images.using tools like ps htop it does not appear that memory is actually the cause here usage typically sits at about gb out of gb available.as such it really looks like something in is conflicting with our code an example stack trace is below.we did manage to capture a few core dumps that were trying to dig into in the mean time if there are a are any other details that might be helpful please let us know.thank you,nate --t::.z level=error category=whibbidy.common.web.httphelper id=system message=error when making web request to get url doretry=false type=system.net.http.httprequestexception exception=system.net.http.httprequestexception the ssl connection could not be established see inner exception system.outofmemoryexception exception of type system.outofmemoryexception was thrown at system.runtime.interopservices.marshal.getfunctionpointerfordelegateinternal(delegate d at interop.crypto.xstorectxsetverifycallback(safexstorectxhandle ctx xstoreverifycallback callback at internal.cryptography.pal.opensslxchainprocessor.buildchain(xcertificate leaf hashset candidates hashset systemtrusted oidcollection applicationpolicy oidcollection certificatepolicy xrevocationmode revocationmode xrevocationflag revocationflag datetime verificationtime timespan remainingdownloadtime at internal.cryptography.pal.chainpal.buildchain(boolean usemachinecontext icertificatepal cert xcertificatecollection extrastore oidcollection applicationpolicy oidcollection certificatepolicy xrevocationmode revocationmode xrevocationflag revocationflag datetime verificationtime timespan timeout at system.security.cryptography.xcertificates.xchain.build(xcertificate certificate boolean throwonexception at system.security.cryptography.xcertificates.xchain.build(xcertificate certificate at system.net.security.certificatevalidation.buildchainandverifyproperties(xchain chain xcertificate remotecertificate boolean checkcertname string hostname at system.net.security.securechannel.verifyremotecertificate(remotecertvalidationcallback remotecertvalidationcallback protocoltoken alerttoken at system.net.security.sslstate.completehandshake(protocoltoken alerttoken at system.net.security.sslstate.checkcompletionbeforenextreceive(protocoltoken message asyncprotocolrequest asyncrequest at system.net.security.sslstate.startsendblob(byte incoming int count asyncprotocolrequest asyncrequest at system.net.security.sslstate.processreceivedblob(byte buffer int count asyncprotocolrequest asyncrequest at system.net.security.sslstate.startreadframe(byte buffer int readbytes asyncprotocolrequest asyncrequest at system.net.security.sslstate.startreceiveblob(byte buffer asyncprotocolrequest asyncrequest at system.net.security.sslstate.checkcompletionbeforenextreceive(protocoltoken message asyncprotocolrequest asyncrequest at system.net.security.sslstate.startsendblob(byte incoming int count asyncprotocolrequest asyncrequest at system.net.security.sslstate.processreceivedblob(byte buffer int count asyncprotocolrequest asyncrequest at system.net.security.sslstate.startreadframe(byte buffer int readbytes asyncprotocolrequest asyncrequest at system.net.security.sslstate.startreceiveblob(byte buffer asyncprotocolrequest asyncrequest at system.net.security.sslstate.checkcompletionbeforenextreceive(protocoltoken message asyncprotocolrequest asyncrequest at system.net.security.sslstate.startsendblob(byte incoming int count asyncprotocolrequest asyncrequest at system.net.security.sslstate.processreceivedblob(byte buffer int count asyncprotocolrequest asyncrequest at system.net.security.sslstate.startreadframe(byte buffer int readbytes asyncprotocolrequest asyncrequest at system.net.security.sslstate.partialframecallback(asyncprotocolrequest asyncrequest end of stack trace from previous location where exception was thrown at system.net.security.sslstate.throwifexceptional at system.net.security.sslstate.internalendprocessauthentication(lazyasyncresult lazyresult at system.net.security.sslstate.endprocessauthentication(iasyncresult result at system.net.security.sslstream.endauthenticateasclient(iasyncresult asyncresult at system.net.security.sslstream.<>c.b___(iasyncresult iar at system.threading.tasks.taskfactory .fromasynccorelogic(iasyncresult iar func endfunction action endaction task promise boolean requiressynchronization end of stack trace from previous location where exception was thrown at system.net.http.connecthelper.establishsslconnectionasynccore(stream stream sslclientauthenticationoptions ssloptions cancellationtoken cancellationtoken end of inner exception stack trace at system.net.http.connecthelper.establishsslconnectionasynccore(stream stream sslclientauthenticationoptions ssloptions cancellationtoken cancellationtoken at system.threading.tasks.valuetask .get_result at system.net.http.httpconnectionpool.createconnectionasync(httprequestmessage request cancellationtoken cancellationtoken at system.threading.tasks.valuetask .get_result at system.net.http.httpconnectionpool.waitforcreatedconnectionasync(valuetask creationtask at system.threading.tasks.valuetask .get_result at system.net.http.httpconnectionpool.sendwithretryasync(httprequestmessage request boolean dorequestauth cancellationtoken cancellationtoken at system.net.http.redirecthandler.sendasync(httprequestmessage request cancellationtoken cancellationtoken at system.net.http.httpclient.finishsendasyncbuffered(task sendtask httprequestmessage request cancellationtokensource cts boolean disposects at whibbidy.common.web.httphelper.processrequest(string uri httpmethod method httpheaders headers int timeout string body string redact boolean doretry in whibbidy/src/whibbidy.common/web/httphelper.cs:line at system.net.http.connecthelper.establishsslconnectionasynccore(stream stream sslclientauthenticationoptions ssloptions cancellationtoken cancellationtoken at system.threading.tasks.valuetask .get_result at system.net.http.httpconnectionpool.createconnectionasync(httprequestmessage request cancellationtoken cancellationtoken at system.threading.tasks.valuetask .get_result at system.net.http.httpconnectionpool.waitforcreatedconnectionasync(valuetask creationtask at system.threading.tasks.valuetask .get_result at system.net.http.httpconnectionpool.sendwithretryasync(httprequestmessage request boolean dorequestauth cancellationtoken cancellationtoken at system.net.http.redirecthandler.sendasync(httprequestmessage request cancellationtoken cancellationtoken at system.net.http.httpclient.finishsendasyncbuffered(task sendtask httprequestmessage request cancellationtokensource cts boolean disposects at whibbidy.common.web.httphelper.processrequest(string uri httpmethod method httpheaders headers int timeout string body string redact boolean doretry in whibbidy/src/whibbidy.common/web/httphelper.cs:line"
335142352,18623,https://api.github.com/repos/dotnet/coreclr/issues/18623,stephentoub,0,0,0,1,0,0,i dont know if we want to do this now or wait for more unification with corert but it didnt take very long with vs auto-fix support so i figured id submit it now and we can decide to take it or punt until later its just been bothering me when making code changes in corelib in particular that the same file class and maybe even method contains both styles cc jkotas danmosemsft
334221240,18578,https://api.github.com/repos/dotnet/coreclr/issues/18578,stephentoub,1,0,0,0,0,0,two issues addressed the other overloads support inputs string char etc being null and just treat that the same as an empty string we should do the same for stringbuilder rather than throwing cancellationtoken was being ignored the overloads should check whether cancellation was requested this applies to the existing write{line}async overloads that were added in cc vancem jeremykuhne pjanotti
334216332,18577,https://api.github.com/repos/dotnet/coreclr/issues/18577,ydekova,4,0,0,0,0,0,we have a net core web api running on aws ubuntu vm.the api is using ef to query a relatively small db and makes a lot of external requests due to integrations with other systems after we upgraded to we started to have serious oom problems on production during the upgrade we havent changed much in our execution logic aside from the changes needed to support the changes in the apis i made sure we are reusing httpclients and that the dbcontext objects are scoped honestly i dont think it is a memory leak from changes in our code moreover the app was running on the same environment with the same user load for roughly a year without problems we make deployments regularly but lets say it could be running continuously for two weeks.after the upgrade it consumes gb of ram for several hours and then crashes with oom actually the whole server crashes the strange thing is that the memory used by the app goes up and barely goes down even in idle times its like barely anything gets released.looking at memory snapshots i can see a lot of memory cache collections growing big many of them used by entity framework and the json.net lib.im sure that all that memory caching improves performance but my assumption is that the app should trade off performance for memory use based on the params of the system also it seems like the gc doesnt release memory but im not very familiar with how its implemented i wonder why it used to work fine with we are using supervisor to start and motor the service not sure if it matters but this is also not new.is there some important configuration i could be missing to tell the system how much in-memory caching it could do?checked a few issues which might be related but none seemed to offer a solution so far and i was not sure which is the most related so i created this one possibly related similar to what danports describes here and we are also considering downgrading after days of struggle i noticed that most people reporting the problem are reporting it with web api projects we have another dot net mvc app running on that machine which doesnt seem to have the problem but it has a significantly lower load the api is just faster to exhaust the memory
333782530,18549,https://api.github.com/repos/dotnet/coreclr/issues/18549,fiigii,2,0,0,0,0,0,currently each aes intrinsic has byte and sbyte overloads but the unsigned byte is probably sufficient for data encryption/decryption operations. csharp public static class aes public static bool issupported get issupported public static vector
333659522,18542,https://api.github.com/repos/dotnet/coreclr/issues/18542,benaadams,3,0,0,0,0,0,this is problematic for example when adding formatting and/or buffering capabilities over span as seen in add support for bufferwriter
332992209,18504,https://api.github.com/repos/dotnet/coreclr/issues/18504,mikedn,7,0,0,1,0,0,this brings down the size of compiler from around kbytes to around kbytes some data members have moved to codegen but then the silatesttrackedscopes change also brings down the size of codegen from around kbytes to around kbyte.this decreases the jit memory usage by with minopts for crossgen corelib.mem stats diff also results in decrease in instructions retired most of this comes from silatesttrackedscopes we no longer zero out a element array though its seems a bit too good to be true maybe pin gets confused by the memset call or something
332950521,18502,https://api.github.com/repos/dotnet/coreclr/issues/18502,noahfalk,1,0,0,0,0,0,for compat with profilers that used our apis in unexpected ways we can allowthe ilcodeversion to fallback to the default il code when no il was explicitlygiven.this is the port for
332949861,18501,https://api.github.com/repos/dotnet/coreclr/issues/18501,bartonjs,3,0,0,0,0,0,there are workstreams which have higher than average requirements about being defensive against in-memory sniffing and heapdumps for those customers the clear-on-use behavior of the garbage collector may be a reason that they cannot use net or may cause them a lot of regulatory/compliance paperwork to use net.while the primary responsibility of clearing sensitive data would fall on the application theres a fair amount of platform code which makes temporaries and leaves them to the gc additionally immutable types such as string have no good mechanism for clearing their data.rather than making the majority of applications have a performance penalty of a lot of small memory clears this behavior would be behind an opt-in.when in the aggressively clearing mode the gc would clear the memory assigned to an object when that object has been declared to be garbage and calling applications would be able to get a moderate cleanup of potentially sensitive data by manually invoking gc.collect
332883565,18487,https://api.github.com/repos/dotnet/coreclr/issues/18487,stephentoub,1,0,0,0,0,0,seal some internal overrides in the more common encodings add overrides of getbytes/getbytecount/getchars/getcharcount to avoid another layer of virtuals from the base class they can call to an internal non-virtual).related to jkotas roji tarekgh krwq
332869756,18486,https://api.github.com/repos/dotnet/coreclr/issues/18486,anmenaga,1,0,0,0,0,0,after the move from netcore to this started happening very frequently.powershell running on raspberry pi model b raspbian gnu/linux stretch))crashes with error in pwsh double free or corruption fasttop xefe stack from gdb: thread pwsh received signal sigabrt aborted. switching to thread x lwp gi_raise sig=sig@entry at sysdeps/unix/sysv/linux/raise.c sysdeps/unix/sysv/linux/raise.c no such file or directory.(gdb bt gi_raise sig=sig@entry at sysdeps/unix/sysv/linux/raise.c xbc in gi_abort at abort.c xbfbf in libc_message do_abort=do_abort@entry fmt=
332840677,18484,https://api.github.com/repos/dotnet/coreclr/issues/18484,AtsushiKan,1,0,0,0,0,0,add the following code snippet to runtimemethodinfo.cs private static void foo(typedreference retval typedreference arg typedreference arg typedreference arg throw null private static invokedelegate pfoo foo private delegate void invokedelegate(typedreference retval typedreference arg typedreference arg typedreference arg); then build the repo the crossgen step fails with this output: build c:\dd\coreclr\bin\product\windows_nt.x.debug\crossgen.exe platform_assemblies_paths c:\dd\coreclr\bin\product\windows_nt.x.debug\il out c:\dd\coreclr\bin\product\windows_nt.x.debug\system.private.corelib.dll c:\dd\coreclr\bin\product\windows_nt.x.debug\il\system.private.corelib.dll assert failure(pid xdf thread xd pparentclass->ischeckappdomainagile()crossgen eeclass::setappdomainagileattribute xa xff fea)crossgen methodtablebuilder::buildmethodtablethrowing xe xff c)crossgen classloader::createtypehandlefortypedefthrowing xef xff ddf)crossgen classloader::createtypehandlefortypekey xc xff b)crossgen classloader::doincrementalload x xff )crossgen classloader::loadtypehandlefortypekey_body xd xff ed)crossgen classloader::loadtypehandlefortypekey xb xff f)crossgen classloader::loadtypedefthrowing xcf xff f)crossgen classloader::loadtypedeforrefthrowing xf xff bf)crossgen loadtypedeforrefhelper x xff ab file c:\dd\coreclr\src\vm\class.cpp line image c:\dd\coreclr\bin\product\windows_nt.x.debug\crossgen.exemicrosoft r coreclr native image generator version copyright c microsoft corporation all rights reserved. this is blocking development of a non-boxing invoke implementation based on typedreferences
332672674,18481,https://api.github.com/repos/dotnet/coreclr/issues/18481,wfurt,1,0,0,0,0,0,forced usage of flock based implementation of named mutexes on freebsd according to the detection phtread should work but following test was failing threading/namedmutex/test/paltest_namedmutex_test test child process paltest_namedmutex_test failed at line expression childrunningevent.release this should be further investigated and understood note that there is libthr and libpthread on freebsd.related to
332595797,18476,https://api.github.com/repos/dotnet/coreclr/issues/18476,janvorli,22,0,0,35,0,24,this change is basically the work of xoofx done some time ago rebasedto the current master and with added fixes my contributions to it were extensive testing running all coreclr pri tests loaded intoassemblyloadcontext including their dependencies and ensuring that they work except the ones that use features not yet supported for unloading like thread local members com interop).that uncovered issues listed below fix few memory leaks enable unloading of assemblies with pinvokes fix virtual stub manager initialization fix issue with unwind info regions reporting for stub linker fix misplaced assert related to statics in collectible assemblies fix issue with sos domain enumeration fixed tests that were allocating but not freeing gchandle thatwas preventing the tests from unloading.i recommend viewing the commits separately.there is still a lot of work to do to enable e.g unloading of assemblieswith classes having thread local members and other stuff but it seemsworth merging these changes in
332380470,18465,https://api.github.com/repos/dotnet/coreclr/issues/18465,Extred,4,0,0,0,0,0,hello.ive spotted a performance drop on linux s-srv amd smp debian debu x gnu/linux compared to windows/macos.flame graphs:! image perfview view: deb.perfview.xml.zip looks like locale/encoding problem but changing system locale settings as suggested in helps not.tried on net core runtimes and
332056879,18457,https://api.github.com/repos/dotnet/coreclr/issues/18457,janvorli,1,0,0,0,0,0,in the utf.cpp and process.cpp pal was incorectly using theglobal new operator this results in calling this operatorsdefinition in coreclr runtime which is wrong in the caseof the utf stuff a customer has reported a crash happeningdue to that when the path from which the pal was initializedcontained chinese characters.the fix is to use internalnew internaldelete functions instead.i have also found that we were missing deletions of the decoderfallbackbufferand encoderfallbackbuffer so i have added them
331827240,18448,https://api.github.com/repos/dotnet/coreclr/issues/18448,Petermarcu,1,0,0,0,0,0,"atpyk commented on wed may upgraded dotnetcore to and upgraded all packages too.when i startup my web application the exception prompts.stacktrace at microsoft.aspnetcore.hosting.webhostbuilder.buildcommonservices(aggregateexception hostingstartuperrors at microsoft.aspnetcore.hosting.webhostbuilder.build at grapeleaf.adminservice.program.buildwebhost(string args in e:\workspace\dotnet\xxx\xxx.adminservice\xxx.adminservice\program.cs:line at grapeleaf.adminservice.program.main(string args in e:\workspace\dotnet\xxx\xxx.adminservice\xxx.adminservice\program.cs:line atpyk commented on thu may uninstall original net core sdk and runtime and reinstall vs and sdk i create a new webapi application by scaffold it doesnt work.---@vladislavantonyuk commented on thu may commented on thu may sad it doesnt work too.---@vladislavantonyuk commented on thu may sure you have installed the latest vs and try to reinstall net core.roolback your changes to net core and follow the instruction i have sent you---@atpyk commented on thu may debug into microsoft.aspnetcore.hosting and find out the error line var hostingservices buildcommonservices(out var hostingstartuperrors);it will throw the exception bad il format.but if i rename this method to buildcommonservices or other it works.so weird~it seems like the namespace microsoft.aspnetcore.hosting conflicts with others the net runtime involves dlls of different version at same time.---@vladislavantonyuk commented on fri jun sure you have installed version and try to uninstall all previous versions also doublecheck you have finished all steps in the instruction ive sent you atpyk commented on fri jun have reinstall my os it works.thanks.---@mangod commented on sat jun you have newrelic monitoring your net app by any chance when you ran into the issue?---@merurino commented on sun jun i was about to comment here my issue seemed to be newrelic was returning the il issue i was building it and running it on docker.---@mangod commented on sun jun thanks for responding after debugging the issue it looks like the changes related to code versioning are causing issues with profiling apis noahfalk who should we follow up with to get this investigated looks like the ilheader is not getting initialized correctly after updating a method il using setilfunctionbody---@noahfalk commented on mon jun sorry you are running into trouble feel free to start with me as the investigator and i can pull in others as needed to help get us started could you post steps i can follow to try reproducing the problem can you let me know what you observed while debugging that lead you to your conclusions?---@mangod commented on mon jun for your response noahfalk will package up a repro and send over email joseclament commented on wed jun have a web job built on netcoreapp console application targeting the win-x and getting the unhandled exception system.badimageformatexception could not load file or assembly exception i havent had any issue with locally deployed using the visual studio directly to the app service any thoughts?---@noahfalk commented on wed jun are you aware of any net profiler or monitoring agent being used in your deployment environment if not we should probably a open a new issue because there would be a decent chance that the root cause for you will be unrelated to the root cause here.---@joseclament commented on thu jun i am using appinsight to push the logs other than no profiling or tooling.let me know if i need to open a new issue.---@nil commented on thu jun i am seeing a similar issue using the appdynamics net core profiler agent on a netcoreapp application and net core sdk when the application starts the following exception is thrown: system.badimageformatexception hresult=xb message=bad il format source=system.private.corelib stacktrace at system.appdomainmanager..ctor at system.reflection.assembly.getentryassembly at microsoft.aspnetcore.hosting.webhostbuilder.buildcommonservices(aggregateexception hostingstartuperrors at microsoft.aspnetcore.hosting.webhostbuilder.build at myapp.web.startup.main(string args joseclament commented on thu jun and nil i got the bottom of the problem it took couple of days to get the bottom of the issue and made me bit nut i was able to dig and find this link core should be built on x version even if the deploying server(azure is based on bit architecture because the bit net core processes using the net core runtime as opposed to the net framework runtime are not yet supported on azure but is planned to be coming in the future you can verify this by go to the kudu and type dotnet info you can see something like this below:.net core sdk reflecting any global.json version commit fbebruntime environment os name windows os version os platform windows rid win-x base path d:\program files x)\dotnet\sdk you can see only the x version here host useful for support version commit caabeba.net core sdks installed d:\program files x)\dotnet\sdk d:\program files x)\dotnet\sdk d:\program files x)\dotnet\sdk you may be able to debug this locally any cpu option as you might have x and x based libraries installed on your machine i could not find any documentation on msdn about this i was assumed it would have been automatically support x version also make sure that the application setting is enabled for the bit.---@nil commented on thu jun am not using azure the error occurs on my local pc when launching the application with iis express under the vs debugger regardless of whether iis express bit or bit is selected.the application starts up correctly if i remove the appdynamics.agent.windows nuget package or set coreclr_enable_profiling environment variable to in my web.config disabling the profiler).---@mangod commented on thu jun it possible for you to capture a full native stack of the exception that might help with identifying if you are hitting the same issue or something different nil commented on thu jun here are the steps to reproduce the issue i see in a command prompt run: cmdmkdir repro pushd reprodotnet new webdotnet add package appdynamics.agent.windows version open the project in visual studio and build it once a number of files brought by the appdynamics package show up under the project including repro.appdynamicsconfig.json edit this file and replace its content with: json controller host localhost port account customer password cbe-dd-fe-bb-bceb ssl true enable_tls true application name irrelevant tier irrelevant node irrelevant these values are not important they just need to be different than the default placeholders for the profiler to activate.add a web.config file to the project with the following content: xml per the appdynamics docs the two coreclr_profiler_path variables must be full paths adjust as required .start debugging f with iis express and note badimageformatexception is thrown at system.appdomainmanager..ctor when the application starts.find the newest log file under programdata%\appdynamics\dotnetagent\logs\profiler which should be similar to info>:use coreclr profiler info>:should instrument standalone profiler process config found at d:\repro\bin\debug\netcoreapp.\repro.appdynamicsconfig.json dotnet as app repro.dll info>:agent configuration controller:{account:customer,enabletls:true,ssl:true,host:localhost,password: *,port:},application:{tier:irrelevant,node:irrelevant,name:irrelevant info>:enabled rejit normally disabled all ngen images error>:injectmee failed info>:transforming clrhost:system.void system.appdomainmanager..ctor with noahfalk commented on thu jun glad you were able to get the bottom of it and very appreciated that you came back to post your findings in case others hit the same issue in the future indeed it looks like your issue had a similar symptom but different root cause than the other ones here i created to track any further work there.@nil thanks for the repro let me try repro your issue so we can figure out if this is the same root cause or something else noahfalk commented on thu jun thanks i was able to reproduce the problem easily using your excellent instructions although the appdynamics issue is slighly different than the newrelic one appdynamics does not call icorprofilerinfo::setilfunctionbody or icorprofilerfunctioncontrol::setilfunctionbody the fix i submitted earlier today does solve both issues at the same time.i wasnt sure if you were an employee with appdynamics or a customer of appdynamics for potential short term resolutions to the issue you could either continue to use net core or use a daily build of net core that has this fix as soon as the installers are ready for download ill write back again when they are a little further in the future im attempting to get this fix into the official servicing releases for i can also try to reach out to appdynamics to see if there are any additional solutions available for the issue.let me know if youve got any other questions or concerns?---@nil commented on fri jun glad i could help and thank you for the update much appreciated i am a customer and have opened an appdynamics support ticket about this will update it shortly with a link to this issue"
331499519,18429,https://api.github.com/repos/dotnet/coreclr/issues/18429,noahfalk,0,0,0,3,0,0,changes the default state of the tiered compilation feature check to be on by default removed comments about the source about this being a work in progress although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features assume it works unless noted otherwise adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off stop accepting the deprecated env var complus_experimental_tieredcompilation im not aware it has any remaining usage but if so were going to find out.@kouvel adiaaida adamsitnik jorive this isnt going to work just yet if nothing else i think a bunch of jit tests will be improperly disabled but i hope its in the ballpark.ive marked this no_merge to ensure nobody submits it prematurely but i do plan to remove the marking and merge once the pr is green ive given broader heads up to the team that this change is incoming and everyone is ready for it
331428150,18427,https://api.github.com/repos/dotnet/coreclr/issues/18427,maryamariyan,0,0,0,3,0,0,fixes
331285751,18413,https://api.github.com/repos/dotnet/coreclr/issues/18413,hvanbakel,1,0,0,0,0,0,so weve been running into an issue where the runtime seems to be assigning the wrong value to a parameter leading to an accessviolationexception being thrown.the issue occurs in a docker container based on microsoft/dotnet:.-runtime running on linux and doesnt occur on windows the code in the callstack in the image was compiled in release configuration it seems to have assigned the formatter func
330980551,18406,https://api.github.com/repos/dotnet/coreclr/issues/18406,AndyAyersMS,4,0,0,0,0,0,we should re-examine the logic the jit uses for inlining in the presence of explicit tail calls calls with a tail prefix currently the jit wont inline any method that is explicitly tail called any method that makes an explicit tail call of these should be allowed provided with reasonable checks former callee frame is not overly huge latter call site is in tail position
330909704,18401,https://api.github.com/repos/dotnet/coreclr/issues/18401,stakx,1,0,0,0,0,0,while working on moq ive run into something strange it appears that the runtime does not match signatures properly when creating delegates through e.g methodinfo.createdelegate it appears that custom modifiers arent taken into account at all: csharpusing system;public delegate void within(in attributetargets arg c compiler emits a required custom modifier among other things see il below)public interface iwithoutin void invoke(ref attributetargets arg no custom modifier here}public class withoutin iwithoutin public void invoke(ref attributetargets arg console.writeline($called with arg class program static void main var interfacemethod typeof(iwithoutin).getmethod(invoke var interfacemethodviadelegate within)interfacemethod.createdelegate(typeof(within new withoutin interfacemethodviadelegate.invoke(attributetargets.all i can create a delegate with signature void(in attributetargets for a method with signature void(ref attributetargets this doesnt seem right since the signatures differ by a required custom modifier from ecma section delegates the invoke method shall be virtual and have the same signature return type parameter types calling convention and modifiers as the target method when actually called the arguments passed shall match the types specified in this signature emphasis added by me)is this imprecise signature matching for delegates intentional or a bug?(expand to see the il for within and iwithoutin ) .class public auto ansi sealed within extends system.runtime system.multicastdelegate ctor omitted method public hidebysig newslot virtual instance void invoke in valuetype system.runtime system.attributetargets modreq( system.runtime.interopservices system.runtime.interopservices.inattribute arg runtime managed param custom instance void system.runtime system.runtime.compilerservices.isreadonlyattribute::.ctor begininvoke and endinvoke omitted)}.class interface public abstract auto ansi iwithoutin method public hidebysig newslot abstract virtual instance void invoke valuetype system.runtime system.attributetargets arg cil managed details>/cc zvirja
330808387,18383,https://api.github.com/repos/dotnet/coreclr/issues/18383,stephentoub,2,0,0,3,0,0,when doing tostring on single-digit integers just return a cached string this helps avoid string allocation/formatting costs for this very common case while only costing one comparison for other cases.microbenchmark: c#using system;using system.diagnostics;using system.runtime.compilerservices;using benchmarkdotnet.attributes;using benchmarkdotnet.running;using benchmarkdotnet.attributes.jobs; memorydiagnoser inprocess public class benchmarks private static void main benchmarkrunner.run
330752208,18375,https://api.github.com/repos/dotnet/coreclr/issues/18375,jkotas,3,0,0,0,0,0,the concept of versioning bubbles is described in current implementation is hardcoded to each assembly being its own versioning bubble this issue is about adding an option for larger versioning bubbles add command line option to crossgen to allow specifying versioning bubbles update isinsameversionbubble to respect this record mvids of assemblies participating in the version bubble in rr image add enforcement to assembly loader to detect version bubble mismatches using mvids stored in the rr images this is important for a good diagnostic of mistakes when the assembly within version bubble is accidentally replaced by a different one use def tokens and module references within the version bubble look for zapimporttable::tryencodemodule this is required to allow cross-module inlining of non-leaf methods within the version bubble
330750432,18373,https://api.github.com/repos/dotnet/coreclr/issues/18373,jashook,1,0,0,0,0,0,this will allow coreclr run programs which have native varargs.it also re-enables the argiterator type for managed to managed nativevararg calls which will allow the use of the arglist keyword.this change also deletes a test which expects an invalid program exceptionfor native varargs usage. limitations: nyi statements have been added for all unix targets.with this change arglist native varargs will be supported but notyet tested on: amd windowsx windowsarm windowsarm windows this change does not address re-enablabling native vararg tests this will be donein a seperate change.see for on initial thoughts on varargs bringup on unix platforms
330472819,18365,https://api.github.com/repos/dotnet/coreclr/issues/18365,A-And,2,0,0,0,0,0,this is connected to the following commit builds a test host and uses as helper projectt to download and run corefx binaries.there are no windows-specifics to the implementation other than the batch scripts the test lists are included as an example ive added a command-line parameter to specify a test list according to scenario the test urls currently point to corerts ci again just to be able to test binary download.cc russkeldorph bruceforstall jkotas sergiy-k
330462584,18361,https://api.github.com/repos/dotnet/coreclr/issues/18361,mrange,1,0,0,0,0,0,"i am very excited about tiered compilation in dotnet core so i decided to take it for a spin unfortunately in my case i found a performance degradation from ms to ms my dotnet version dotnet version my use-casei am tinkering with a push stream in f push streams are faster than pull streams like linq one area where net jit loses against jvm jit is that net jit is less keen on inlining with tiered compilation i was hoping to see improved inlining improving performance.essentially the degradation seems to boil down to that there is an extra jmp in the call chain as far as i understood this is due to the new jitter introducing an level stub to track stats i was expected this jmp being eliminated after warmup phase as the stub dont do any stats tracking it seems to be the final optimized stub to me finally time for some assembly code top level loop this identical regardless of complus_tieredcompilationffc ddece bdf cmp ebx,ediffc dded f jg ffc ddeeffc dded bce mov rcx,rsiffc dded bd mov edx,ebxffc dded b mov rax,qword ptr rsi ffc ddeda b mov rax,qword ptr rax+h virtual call to next step in the push streamffc ddede ff call qword ptr rax+h ffc ddee ffc inc ebxffc ddee ebe jmp ffc ddece the virtual call ends up here which seems left overs from the stats tracking stub this is not present when complus_tieredcompilation=ffc dd ebb jmp ffc ddac the next step in the push streamffc ddac b mov rcx,qword ptr rcx ds:a c=aaffc ddac d movsxd rdx,edxffc ddac b mov rax,qword ptr rcx ffc ddaca b mov rax,qword ptr rax+h ffc ddace b mov rax,qword ptr rax+h ffc ddad ffe jmp rax so with tiered compilation i was hoping for the virtual call to be eliminated as is the case in jvm jit instead i got a performance degradation from ms to ms.perhaps i should wait for some more detailed posts on tiered compilation as promised here i am quite excited about tiered compilation so i wanted to get an early start hopefully you tell me i made a mistake my f code: module trivialstream the trivial stream is a very simplistic push stream that doesnt support early exits useful for first the trivial stream is useful as basic stream to measure performance against type receiver<t t unit type stream<t receiver<t unit module details module loop this way to iterate seems to be faster in f than a while loop let rec range s e r i if i e then r i range s e r i s open details sources let inline range b s e stream let main argv printfn attach debugger and hit a key system.console.readkey ignore performancetests.test perf.tsv"
330452564,18358,https://api.github.com/repos/dotnet/coreclr/issues/18358,CarolEidt,3,0,0,2,0,0,eliminate unnecessary struct copies especially on linux and reduce code duplication.across all targets use gt_field_list to pass promoted structs on stack and avoidrequiring a copy and/or marking lvdonotenregister for those cases.unify the specification of multi-reg args numregs now indicates the actual number of reg args not the size in pointer-size units regnums contains all the arg register numbers
330375908,18349,https://api.github.com/repos/dotnet/coreclr/issues/18349,tannergooding,3,0,0,0,0,0,fyi caroleidt fiigii creators this should resolve remaining work is to add additional handling for special commutative intrinsics such as compare*orderedscalar update the memoryload/memorystore intrinsics to be gt_indir where possible allow some helper intrinsics to be containable themselves such as staticcast when it is a non rmw source operand
330024475,18332,https://api.github.com/repos/dotnet/coreclr/issues/18332,danmosemsft,1,0,0,0,0,0,leecow commented on wed jun commented on wed jun discovered a bug that causes a function to return null even if every possible return value is non-null the issue does not happen if the project is compiled in debug mode please see the code attached that reproduces this issue. csharpusing system;using system.collections.generic;namespace dotnetbug internal class foo idisposable public void dispose class program public static string aargh using var foo new foo foreach var i in new list
330007746,18330,https://api.github.com/repos/dotnet/coreclr/issues/18330,mikedn,1,0,0,0,0,0,while hacking the jit quite often i end up with a simple question how many time does x happen how many jcc instructions are generated how many side effects trees are extracted how many range checks are encountered/removed?so i end up adding variables printf s and what not and its always a quick improvisation done to be used once and then thrown away.i think it would be useful to have some basic metrics framework in the jit that would let people to simply add a line like: c++metrics.increment(extractedsideeffect); pretty much anywhere in the jit code and have such counters dumped to the console like mem stats are or included in disassembly comments so that they show up in diffs and maybe be used by jit-analyze.counters should be collected per method and if possible per phase as well and of course some basic aggregations should be included as well.the api should be as easy to use as possible the above example shows the use of a string as a counter identifier so i guess the implementation would be using these strings as a hashtable key this would avoid the need to add a new enum member such an enum typically resides in a header that when changed triggers the compilation of all jit files of course an enum based overload could also provided that would be useful for counters that are useful long term.@dotnet/jit-contrib thoughts
329866951,18323,https://api.github.com/repos/dotnet/coreclr/issues/18323,chrarnoldus,4,0,0,0,0,0,our net core web apps running on azure app service occasionally start throwing invalidprogramexceptions at seemly random places in code for example see the following stack traces:on net core see inner exception net core so the issue doesnt seem toe be fixed see inner exception)due to the unpredictable nature of these exceptions i suspect the problem is in the runtime and not in the asp.net core libraries used in all of the cases the exception continued to be thrown every time the affected code was executed the problem disappears after restarting the process so i dont have steps to reproduce it i do have memory dumps that were captured by the application insights snapshot collector if a microsoft employee is interested in analysing those in the understanding that they probably contain sensitive data please contact me using the email in my profile
329691298,18322,https://api.github.com/repos/dotnet/coreclr/issues/18322,noahfalk,0,0,0,1,0,0,for compat with profilers that used our apis in unexpected ways we can allowthe ilcodeversion to fallback to the default il code when no il was explicitlygiven.issue kouvel
329608221,18308,https://api.github.com/repos/dotnet/coreclr/issues/18308,stephentoub,0,0,0,0,0,1,brianrob is currently working on a change thatll remove the concurrentdictionary usage from tracing on linux which interestingly doesnt actually currently add to the dictionary so its not providing anything useful at the moment anyway once thats removed nothing else in corelib is using concurrentdictionary and we can remove it this pr is thus dependent on brians change
329575356,18305,https://api.github.com/repos/dotnet/coreclr/issues/18305,krwq,0,0,0,1,0,0,fixes locally with original repro.some old time zones i.e asia/manilla see comment in the code for more examples had adjustment higher than our max expected value h because of compatibility with sql server concerns we cannot change the max value i.e windows does not have that data at all last known adjustment with offset larger than h is in year
329261281,18294,https://api.github.com/repos/dotnet/coreclr/issues/18294,luqunl,0,0,0,1,0,0,use wchar to avoid truncate ptarget is wchar*.fix
329195786,18288,https://api.github.com/repos/dotnet/coreclr/issues/18288,pentp,1,0,0,0,0,0,this fixes tests are in and the same change for corert is in benchmarks also there
328938911,18274,https://api.github.com/repos/dotnet/coreclr/issues/18274,AndyAyersMS,2,0,0,0,0,0,have the jit tolerate byref/nint return type mismatches for inlinessame way that it tolerates them for ret instructions.fixes
328899891,18272,https://api.github.com/repos/dotnet/coreclr/issues/18272,kant2002,1,0,0,0,0,0,closes
328802138,18264,https://api.github.com/repos/dotnet/coreclr/issues/18264,luqunl,1,0,0,0,0,0,add/set gtf_relop_qmark in gtnewqmarknodefix
328801868,18263,https://api.github.com/repos/dotnet/coreclr/issues/18263,jkotas,1,0,0,0,0,0,unicodeencoding was taking fast path only when both source and destination were byte aligned it was not the case for unicode.getstring.the fix is to just check the source alignment as fast path precondition and use unaligned write for destination.also removed alternative fast path that is not needed anymore tweaked local variable assignments for better register allocation and fixed performance issue introduced by recent big endian portability fix.fixes
328786562,18260,https://api.github.com/repos/dotnet/coreclr/issues/18260,Suchiman,2,0,0,0,0,0,reenables all warnings that do not trigger fixes two of the easier warnings and reenables them too.contributes to
328772868,18258,https://api.github.com/repos/dotnet/coreclr/issues/18258,Suchiman,1,0,0,0,0,0,fixes
328765940,18255,https://api.github.com/repos/dotnet/coreclr/issues/18255,tannergooding,1,0,0,0,0,0,this does a few things moves the hwintrinsicinfo struct into a header file moves many of the hwintrinsicinfo lookup functions to be static members on the struct moves the hwintrinsicinfo flags to be queried via explicit methods
328725348,18251,https://api.github.com/repos/dotnet/coreclr/issues/18251,slavanap,1,0,0,0,0,0,simplify varrfromdec in decimal.gethashcode in order to reduce rounding error caused by division big double by big power of for decimal with big scale.fix issue unfortunately i had to add varhashfromdec to oleauto.h header file because i need constants decmax and dsto for hash computation i know thats not a good way to do it thus im open to suggestions how to reorganize these code changes if they are necessary
328490868,18234,https://api.github.com/repos/dotnet/coreclr/issues/18234,janvorli,2,0,0,0,0,0,this change enables cross build and rootfs creation foralpine linux arm arm targets.besides that ive cleaned up the toolchain.cmake and got ridof the explicit specification of gcc version specific includeand lib folders for all targets except of tizen clang is ableto figure that out on its own the same way as it does when doingregular non-cross builds but it needed one more option for that.ive also fixed a bug in the add_compile_param macro that causedignoring of parameters in cases where another parameter that wasa substring of the one being added was already present so for exampleif an option l${cmake_sysroot}/usr/lib/gcc was already added attempt to add option l${cmake_sysroot}/usr/lib would do nothing
328376607,18230,https://api.github.com/repos/dotnet/coreclr/issues/18230,cshung,1,0,0,0,0,0,caroleidt
328238964,18221,https://api.github.com/repos/dotnet/coreclr/issues/18221,stephentoub,1,0,0,0,0,0,contributes to an empty numbergroupsizes array is used as part of fixed formatting which is used by f n c and p specifiers we end up trying to access element of the array triggering an indexoutofrangeexception the fix is simply to move the check down until after weve checked that the array isnt empty.cc jkotas egorbo
327967377,18213,https://api.github.com/repos/dotnet/coreclr/issues/18213,stephentoub,1,0,0,0,0,0,"added a dumpasync command to sos this adds a few additional features to it computing gc roots is a relatively slow operation and doing it for every state machine object found in a large heap can be time consuming making it opt-in with roots command-line flag added waiting command-line flag dumpasync will now retrieve the state field from the statemachine and if waiting is specified itll filter down to state machines that have a state value meaning the state machines are waiting at an await point for example given this program: c#using system.threading.tasks;class program static async task main await methoda await methoda(int.maxvalue static async task methoda(int delay await methodb(delay static async task methodb(int delay await task.yield await task.delay(delay using dumpasync outputs address mt size name ffeae system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdf taskmethodbuilder instance t__builderffebcbc a system.int instance delayffebeed b able+yieldawaiter instance u__ffebcead c vices.taskawaiter instance a u__continuation b system.object)#e ffeacc system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdf taskmethodbuilder instance ec t__builderffebcbc system.int instance delayffebcead vices.taskawaiter instance ec u__continuation b system.object)#ed ffea system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdf taskmethodbuilder instance f t__builderffebcead vices.taskawaiter instance f u__continuation f system.threading.tasks.task+setoninvokemres)#d ffeae system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdf taskmethodbuilder instance d t__builderffebcbc a system.int instance delayffebeed b able+yieldawaiter instance d u__ffebcead c vices.taskawaiter instance d u__continuation dd system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test )#dd ffeacc system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdf taskmethodbuilder instance e t__builderffebcbc system.int instance delayffebcead vices.taskawaiter instance e u__continuation ed system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test )found state machines. while using dumpasync waiting outputs only address mt size name#ed ffea system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdf taskmethodbuilder instance f t__builderffebcead vices.taskawaiter instance f u__continuation f system.threading.tasks.task+setoninvokemres)#d ffeae system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdf taskmethodbuilder instance d t__builderffebcbc a system.int instance delayffebeed b able+yieldawaiter instance d u__ffebcead c vices.taskawaiter instance d u__continuation dd system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test )#dd ffeacc system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdf taskmethodbuilder instance e t__builderffebcbc system.int instance delayffebcead vices.taskawaiter instance e u__continuation ed system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test )found state machines. skipping the two state machines that have a state field value of meaning its completed note that this change has the somewhat unfortunate impact of taking a dependency on whats effectively an implementation detail of roslyn but the value the filtering provides is deemed to be worth it this design is unlikely to change in the future and as with other diagnostic/debugging features that rely on such details it can be updated if roslyn ever changes its scheme in the meantime the code will output a warning message if it cant find the state field if a state machine is found to have roots but also to have a state value that suggests it was dropped without having been completed which is likely a sign of an application bug the command now prints out an information message to highlight that state for example this program: c#using system;using system.threading.tasks;class program static void main task.run(async await new taskcompletionsource().task console.readline when processed with dumpasync roots results in address mt size name#fbb ffeaafe system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.boolean system.private.corelib , program+<>c+<b___>d test statemachine program+<>c+<b___>d struct mt field offset type vt attr value nameffebcbc system.int instance stateffebdb private.corelib instance fbb t__builderffebffd private.corelib instance fbb u__continuation fbfc system.threading.tasks.unwrappromise system.boolean system.private.corelib )gc roots:incomplete state machine state with roots.found state machines. cc jkotas danmosemsft noahfalk jaredpar mikem"
327924679,18208,https://api.github.com/repos/dotnet/coreclr/issues/18208,GrabYourPitchforks,1,0,0,0,0,0,encoding.ascii has room for optimization such as vectorizing the getbytes getchars methods simplifying if checks and so on.(this is a nice-to-have this isnt blocking anything as i know
327537206,18193,https://api.github.com/repos/dotnet/coreclr/issues/18193,vancem,2,0,0,0,0,1,there was already some support for labeling threads using the window setthreaddescription api however it was missing some important cases like labeling the threadpool and gc server and background threads fix this also make the naming consistant they all start with net).these names show up in perfview traces and can be used by debuggers or other profilers as well.@maoni brianrob
327418391,18162,https://api.github.com/repos/dotnet/coreclr/issues/18162,danmosemsft,2,0,0,0,0,0,there is heavy use of unsafe code in number.parsing.cs and calling code eg at this could be rewritten with readonlyspan
327384309,18160,https://api.github.com/repos/dotnet/coreclr/issues/18160,stephentoub,0,0,0,1,0,4,"debugging async methods with sos can be time consuming and relies on knowing how to use dumpheap dumpvc gcroot and other commands to get the desired information while often digging through a myriad of objects on the heap to find the desired info.this commit adds a new dumpasync command which finds the async state machine objects on the gc heap and outputs relevant information about each including the fields of its state machine any registered continuation and gc roots for the state machine object as they often serve as a valid substitute for call stacks).example program used as a test: c#using system.threading.tasks;class program static async task main await methoda static async task methoda await methodb static async task methodb await methodc static async task methodc await methodd static async task methodd await task.delay(int.maxvalue);} and example command output dumpasync type methodd address mt size name#fde ffcba system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test statemachine program+d struct mt field offset type vt attr value nameffddfb d system.int instance stateffdec e taskmethodbuilder instance fe t__builderffddfea f vices.taskawaiter instance fe u__continuation fe system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test )gc roots thread c ae ffdac system.threading.tasks.task.spinthenblockingwait(int system.threading.cancellationtoken d:\repos\coreclr\src\system.private.corelib\src\system\threading\tasks\task.cs rbp aec ffa system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test ff system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test fec system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test fe system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test fde system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test handletable df pinned handle afe system.object f system.threading.timerqueue f system.threading.timerqueue f system.threading.timerqueuetimer fe system.threading.tasks.task+delaypromise fde system.runtime.compilerservices.asynctaskmethodbuilder +asyncstatemachinebox system.threading.tasks.voidtaskresult system.private.corelib , program+d test found state machines. cc jkotas janvorli mikem noahfalk danmosemsft"
327116162,18156,https://api.github.com/repos/dotnet/coreclr/issues/18156,A-And,1,0,0,0,0,0,corefx ci testing scenario for coreclr current state of corefx testing in coreclrcurrently the coreclr repos runs corefx tests by checking out the corefx repository at a specified commit or head by default building the repo on top of the runtime to test building all tests and subsequently running them these jobs run post-check-in in multiple different stress configurations.while this approach is flexible a few details make it less suited to be used in ci firstly breaking changes can creep in due to corefx version mismatches secondly this process is time-consuming and storage-heavy which is not ideal for quick pr runs thirdly in the current state the way to skip running tests is by annotating the test code itself with xunit annotations requiring changes to be made in both repos and slowing down development current state of corefx testing in corert proof of concept)when helix runs corefx tests the produced project and test binaries are saved and kept for a limited time a test list is produced on every build with the urls of the binaries these built test assemblies can be reused for ci jobs allowing a quicker and less resource-intensive way to test changes made to the runtime.in corert a small subset of framework tests run for every pr these tests are not built locally but instead an already built set of tests is saved in blob storage and downloaded on request each test project includes a xunit test runner eliminating the need to build it independently.a minimal test harness in the form of a dummy csproj file is used to allow nuget package dependencies to be resolved for the project our xunit console wrapper produced and published from the build tools repo allows unstable and failing tests to be disabled via command line switches and/or rsp files test runs are defined via json files in the repository which define both which tests to run e.g system.collections.tests.dll as well as which tests should be excluded defined either by fully-qualified name their class or namespace with a required reason for exclusion validated on every test run the feature will allow ci checks to pass even if a breaking change is propagating the failing test(s can be added to the exclusion list with a link to the associated issue or other reason for skipping during test runs avoiding the need to make any modifications to corefx-side test code this gives a large degree of flexibility in defining test runs each definition can be created as an easily extensible json file utilizing the enforced json schema additional tooling can be built around the framework for example validity of exclusions can be tracked by an associated link to a github issue the validity of issues can be checked on each test run using a library/tool similar to octokit.net proposalthe approach taken in corert will be extended to cover coreclr the coreclr components to be tested will be laid out such that they can be run with the dotnet cli mirroring the binplacing approach in the corefx repo the established infrastructure pattern will be modified for better integration with the existing codebase the test harness defining dependencies will be removed and instead the repos xunit version will be reused the core_root folder built for current testing scenarios contains most components necessary to run tests and will therefore be reused a test list will sit in the root of the blob storage instance with url values of each test for supported configurations e.g windows_nt x once tests are run with a specified configuration the test list will be read and the test suites at the relevant urls downloaded.each test flights included test assemblies and method/class/namespace exclusions will be defined via a json file the test assemblies can be automatically updated and replaced in blob storage by running a full corefx build for each respective configuration for the current work built corefx test assemblies will be copied into separate blob storage to be used by the ci setup outside of the scope of this proposal binary management can be automated by adding features to dotnet-maestro-bot updating the test assemblies on every update to the current corefx version
326703941,18137,https://api.github.com/repos/dotnet/coreclr/issues/18137,noahfalk,0,0,0,0,0,1,this is a more distilled design proposal that solves issues raised in the idea is to add a new profiler api such as icorprofilerinfo::addassemblypath(appdomainid appdomainid const wchar passemblypath)which will add a path to list of assemblies that the runtime probes to resolve assembly references this allows profilers to instrument managed code and include assembly references to a new assembly that was deployed by the profiler rather than being deployed as part of the application. background info to assist implementors probably the hardest part of the problem is creating a testable repro scenario assuming you dont already have your own il instrumenting profiler handy there is an example instrumenting profiler here that has most of what is necessary however this example instruments using a calli instruction reproduce the problem here the profiler instead needs to include with the profiler a new managed assembly that has the implementation of some simple callback within it lets call this managedinstrumentation.dll public static class managedcallbackfunctions public static void onmethodenter(int functionid console.writeline(function functionid was called use imetadataassemblyemit::defineassemblyref to create an assemblyref token that refers to the managedinstrumentation.dll assembly use imetadataemit::definetyperefbyname and definememberref create a memberref token that refers to managedcallbackfunctions.onmethodenter change the instrumentation to use an il call opcode with the managedcallbackfunctions.onmethodenter tokenrunning an application with this profiler should fail because managedinstrumentation.dll cant be located to test the new api you will need to handle the appdomaincreationfinished callback in the handler qi for icorprofilerinfo and then invoke addtrustedassemblypath(domainid path_to_managedinstrumentation.dll initially the qi will fail but once the feature is implemented this call should succeed at modifying the assembly list later the compilation of instrumented methods should also succeed because the runtime will find managedinstrumentation.dll and load it.to implement the feature add the new api to add an implementation to implementation of the method needs to change the tpa list which is stored here to that datastructure should be something like basedomain pdomain basedomain appdomainid pdomain->gettpabindercontext()->getappcontext()->gettpalist();more background docs about clr and profiling the tpa list normally gets set from without using a profiler the pprofilernames/values there is a property named trusted_platform_assemblies with a list of assembly paths the runtime host constructs this list however they want dotnet.exe assembles it from some json configuration files like app.deps.json and then the runtime stores it
326616827,18128,https://api.github.com/repos/dotnet/coreclr/issues/18128,sandreenko,1,0,0,0,0,0,src\inc\warningcontrol.h has list of disabled warning for all coreclr projects many of them came from the desktop and do not fire on coreclr like etc some of them need small fixed so the task is to delete all warnings that do not fire delete warning that needs simple small fixes and fix them
326327349,18121,https://api.github.com/repos/dotnet/coreclr/issues/18121,sandreenko,1,0,0,0,0,0,delete unused variables after the legacy_backend death
325994693,18111,https://api.github.com/repos/dotnet/coreclr/issues/18111,jkotas,1,0,0,0,0,0,corert corelib does this already related can be used for performance optimizations like
325815324,18101,https://api.github.com/repos/dotnet/coreclr/issues/18101,jkotas,4,0,0,0,0,0,reimplement most of array.clear in managed code using span clear helpers.fixes dotnet/corefx
324906625,18067,https://api.github.com/repos/dotnet/coreclr/issues/18067,mateusrodrigues,14,0,0,0,0,0,"hello,im working on a project with google summer of code and freebsd to port the net core runtime and sdk as well as powershell over to the freebsd platform right now im gathering information on how to build and put together the tooling and runtime since the components are pretty scattered around in different repositories.ive started with coreclr and corefx to build a working runtime which im basing on the rc release commit hash ac for coreclr and fb for corefx what i did was building them on ubuntu linux which is an officially supported platform to understand what the build results are and how to put them together and then execute the same steps on freebsd to try to get the same result during this process of building on linux ive come upon a couple questions which id like to discuss ive built the corefx managed components on windows targeting linux with build-managed.cmd os=linux skiptests which resulted in a bunch of dlls exptected and a couple linux executables and so files not expected these executables and so files also appear when building coreclr native on linux which is expected why did they appear on the windows build and which ones should i use the ones that appear on the windows corefx managed build or the ones that appear on the coreclr native build they have the same filenames but different sizes the ones on the coreclr native build are about x larger after getting the runtime working on linux by creating the folder structure with the dotnet executable on top the libhostfxr.so file inside the host/fxr/..-rc folder and the dlls along with createdump and the native components of corefx inside the shared/microsoft.netcore.app/..-rc folder i tried executing a little helloworld.dll program i created and built elsewhere on my own built-from-source runtime and it complained about a missing microsoft.netcore.app.deps.json file in what step should it get built and how do i build it?cc petermarcu jkotas i should mention this project is being mentored by dragonsa freebsd and davidchisnall microsoft research and freebsd"
324647696,18064,https://api.github.com/repos/dotnet/coreclr/issues/18064,BruceForstall,17,0,0,45,0,1,all code related to the legacy_backend jit is removed this includes all code related to x floating-point code generation almost lines of code have been removed
324610238,18061,https://api.github.com/repos/dotnet/coreclr/issues/18061,mikedn,2,0,0,0,0,0,the jit knows not to inline throw helper methods manually blocking inlining prevents the jit from detecting that these methods do not return and that may negatively impact the quality of the caller method code
324513411,18048,https://api.github.com/repos/dotnet/coreclr/issues/18048,BruceForstall,1,0,0,0,0,0,arm/windows is currently built in the ci and locally using a private microsoft sdk with windows sdk shipped with vs i believe all required arm files are public also visual studio has since public arm windows compilers and recent cmake versions supposedly support these new tools.thus we should change the build infrastructure including ci and official builds to build arm/windows with all public tools and stop using the private toolset
324364462,18044,https://api.github.com/repos/dotnet/coreclr/issues/18044,devKlausS,1,0,0,0,0,0,we are running net core applications inside docker containers on a kubernetes cluster docker containers get oomkilled because gc is not executed.to test this we created a test program which allocates arrays in a loop these arrays should get deleted by the gc the program is executed in a docker container with mb memory limit kubernetes is not involved in the tests.when running the test with swap enabled everything works as expected and the gc gets triggered when the total memory reaches mb the test never gets killed.when running the test with swap disabled the test gets oomkilled when the total memory reaches mb we have tested this behaviour with servergc=true|false and with net core and enabling swap is not an option cause its neither recommended nor supported by kubernetes codeyou can find out test program here var rand new random list
324123582,18033,https://api.github.com/repos/dotnet/coreclr/issues/18033,AndyAyersMS,1,0,0,0,0,0,when the jit is optimizing type equality and inequality tests it may run into the following case object.gettype typeof(x) this can usually be optimized into a comparison of the objects method table pointer versus a known method table address but historically that has not always been a valid optimization so the jit calls caninlinetypecheckwithobjectvtable to identify the cases where the optimization is valid jans comments in it seems in coreclr this optimization is likely always valid and the check is no longer needed
323724039,18022,https://api.github.com/repos/dotnet/coreclr/issues/18022,GrabYourPitchforks,1,0,0,0,0,0,"i have the following two repro methods along with their x codegen using the latest ryujit. cs methodimpl(methodimploptions.noinlining) public static bool methodfoo(byte x return byte)x asmconsoleapp!consoleapp.program.methodfoo(byte):ffe cb f cmp cl,hffe cb fc setb alffe cb fbc movzx eax,alffe cb c ret cs methodimpl(methodimploptions.noinlining) public static bool methodbar(byte x return sbyte)x asmconsoleapp!consoleapp.program.methodbar(byte):ffe cb fbc movzx eax,clffe cb fbec movsx rax,alffe cb fc cmp eax,ffffffchffe cba fcc setl alffe cbd fbc movzx eax,alffe cb c ret the foo method checks to see if the high bit is clear and the bar method checks to see if the byte has input pattern xxxxxx these are both common operations when performing utf text processing in the examples above the bar method has suboptimal codegen i would instead expect the codegen to be the following. asmcmp cl,chsetl almovzx eax,alret"
323671313,18019,https://api.github.com/repos/dotnet/coreclr/issues/18019,Korporal,2,0,0,0,0,0,given that the lock keyword simply wraps a critical section and critical sections are confined to a single process it strikes me as possible in principle for the clr to be able to perform a kind of deadlock detection.it could do this when any thread attempts to acquire a lock by examining if the calling thread currently owns any other locks and then for each of those examine if any of these are being waited for by any other thread.it could then abort the attempted lockwith some specific deadlockexception or something.because critical sections are process wide it does beg the question in my mind about if it is possible for two appdomains in the same process to ever share a lock i suspect this isnt ordinarily something one would design though.the proof of concept could just be a small api that wraps the monitor class and maintains the data structures necessary to track lock ownership by threads the api would manage a static tree/list that is itself thread safe that records which threads currently hold which locks given the potential performance impact this could be something that is enabled/disabled at runtime at the appdomain level.the algorithm is then to deny a request from thread x to acquire a lock if doing so would lead to a hang because some other thread is trying to acquire a lock already held by thread x the key observation here being that any thread that has locks held and is waiting for some other lock by definition cannot release the locks it already holds.the exception that would be thrown could contain metadata describing why a deadlock was detected which is far better than seeing an appdomain simply freeze.the ultimate benefit is not that deadlocks would be eliminated but that they could be detected at the instant they arise and used during testing or when attempting to reproduce a deadlock that has been reported in an app or class library.thoughts
323427453,18013,https://api.github.com/repos/dotnet/coreclr/issues/18013,morganbr,18,0,1,0,0,2,this issue will track progress toward supporting loading and running mixed-mode assemblies on coreclr the main goal is to provide support for wpf and other existing c++/cli code on net core some of the work will be dependent on updates to the msvc compiler.steps include x documenting how mixed-mode assemblies work in general proposing a net core design loading mixed-mode assemblies into running managed code starting the runtime from native code in mixed-mode assembliesthis is related to but cross-platform support is outside of the scope of this issue as its a compiler feature not a runtime feature
323321491,18005,https://api.github.com/repos/dotnet/coreclr/issues/18005,benaadams,1,0,0,0,0,0,"its mostly a wrapper on buffermemmove with some checks failed unprofitable inline readonlyspan :copyto(struct):this ! image occurrence in system.private.corelib.dasm asm assembly listing for method readonlyspan :copyto(struct):this lcl frame size g_m_ig push rdi push rsi push rbx sub rsp mov qword ptr rsp+h rdxg_m_ig mov eax dword ptr rcx mov rd eax mov r qword ptr rdx mov r qword ptr r cmp rd dword ptr r ja short g_m_ig mov rsi bword ptr r mov rcx bword ptr rcx mov rdi rcx movsxd rbx eax mov rcx qword ptr r test rcx rcx jne short g_m_ig mov rcx rdx lea rdx reloc call corinfo_help_runtimehandle_class mov rcx raxg_m_ig mov rdx rsi mov r rdi mov r rbx call buffer:memmove(byref,byref,long nop g_m_ig add rsp pop rbx pop rsi pop rdi ret g_m_ig call throwhelper:throwargumentexception_destinationtooshort int total bytes of code prolog size for method readonlyspan :copyto(struct):this second occurrence in system.private.corelib.dasm asm assembly listing for method readonlyspan :copyto(struct):this lcl frame size g_m_ig sub rsp nop g_m_ig mov rd dword ptr rcx mov eax rd cmp eax dword ptr rdx ja short g_m_ig mov rdx bword ptr rdx mov rax rdx mov rdx bword ptr rcx movsxd r rd mov rcx rax shl r call buffer:memmove(struct,struct,long nop g_m_ig add rsp ret g_m_ig call throwhelper:throwargumentexception_destinationtooshort int total bytes of code prolog size for method readonlyspan :copyto(struct):this"
322433441,17970,https://api.github.com/repos/dotnet/coreclr/issues/17970,briansull,1,0,0,0,0,0,"with this change we can use a prefix and wildcard matchthis allows us to match classes and methods that start with a prefix.example my*:method would match a method named method inside any class that starts with my get or simply get both will match any method that starts with get_this allows us to match some managed c methods that we could not otherwise match:by using complus_jitdump=std._find_if*we can match this managed c method module>:std._find_if(long,struct,struct,struct"
322063093,17952,https://api.github.com/repos/dotnet/coreclr/issues/17952,JustArchi,1,0,0,0,0,0,steps to reproduce dotnet publish c release r win-x o out any app manually rename out directory to out or any other with a semicolon run yourapp.exe result: failed to initialize coreclr hresult x thank you in advance. narzdzia wiersza polecenia programu net product information version commit sha hash edbadfruntime environment os name windows os version os platform windows rid win-x base path c:\program files\dotnet\sdk\..\microsoft net core shared framework host version build ddbbcebffefebabe
321986063,17949,https://api.github.com/repos/dotnet/coreclr/issues/17949,AndyAyersMS,2,0,0,0,0,0,in many cases the use of a variable has a single reaching definition we should consider tracking this information in the importer and using it to drive early optimizations.the idea for now is to look at only the simplest cases ones where a variable has a single definition and all uses are clearly dominated by the definition arguments that are not exposed or redefined a subset of the temps introduced by the jit like the newobj temps for ref types a single definition where all uses can be shown to be dominated by the definition non-zero init locals that are not exposed or redefined zero init locals with one in-method definition where the zero init does not reach any usesbecause these track at most one definition per variable and for locals one dataflow bit per local per block the representation shouldnt be super costly.there are already some precursors of this in the importer code tracking of ref types tracking the this init state we can consider tracking the full definition expression or just some properties of that definition for instance in some prototypes for i added non-null tracking for newobj temps for ref types but likely the full expression would be cheap enough to track.the tracking mechanism needs to be robust in the presence of reimportation and should have some kind of post-importer sanity check.it would also be good if this information remained viable through the early phases of the jit for instance it could be used and maintained during inlining
321981459,17948,https://api.github.com/repos/dotnet/coreclr/issues/17948,mikedn,1,0,0,0,0,0,"contributes to looks like containment might have been lost in though it cause a significant diff so its not clear how this slipped in xtotal bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes system.linq.expressions.dasm of base microsoft.diagnostics.tracing.traceevent.dasm of base system.private.corelib.dasm of base commandline.dasm of base system.linq.dasm of base total files with size differences improved regressed unchanged.top method improvements by size bytes system.linq.expressions.dasm funccallinstruction :run(ref):int:this methods system.linq.expressions.dasm actioncallinstruction :run(ref):int:this methods system.linq.expressions.dasm funccallinstruction :run(ref):int:this methods system.private.corelib.dasm arraysorthelper :pickpivotandpartition(ref,int,int,ref):int methods system.private.corelib.dasm arraysorthelper :downheap(ref,int,int,int,ref methods total methods with size differences improved regressed unchanged xtotal bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes system.linq.expressions.dasm of base microsoft.diagnostics.tracing.traceevent.dasm of base system.private.corelib.dasm of base system.linq.dasm of base commandline.dasm of base total files with size differences improved regressed unchanged.top method regessions by size bytes system.private.corelib.dasm module:findtypes(ref,ref):ref:this system.private.corelib.dasm type:findinterfaces(ref,ref):ref:thistop method improvements by size bytes system.linq.expressions.dasm funccallinstruction :run(ref):int:this methods system.linq.expressions.dasm actioncallinstruction :run(ref):int:this methods system.linq.expressions.dasm funccallinstruction :run(ref):int:this methods system.private.corelib.dasm arraysorthelper :downheap(ref,int,int,int,ref methods system.private.corelib.dasm arraysorthelper :pickpivotandpartition(ref,int,int,ref):int methods total methods with size differences improved regressed unchanged"
321751172,17936,https://api.github.com/repos/dotnet/coreclr/issues/17936,janvorli,1,0,0,0,0,0,for some reason the alpine docker container running on a selinux host mapsheap as rwx when we allocate alternate stack from the heap we alsochange the protection of the first page to prot_none so that it canserve as a guard page to catch stack overflow and when we free thealternate stack we restore the protection back to prot_read prot_write the restoration fails in alpine docker container running ona selinux host with eprot failure and the selinux log reports that anattempt to change heap to executable was made so it looks like thekernel has added the perm_exec to the permissions we have passed to themprotect call there is a code in the mprotect implementation that cando that although i dont fully understand the exact conditions under which ithappens yet this is driven by the vm_mayexec flag in the internal vma blockstructure to fix that ive modified the alternate stack allocation to use mmap munmap instead of c heap allocation.close
321742829,17935,https://api.github.com/repos/dotnet/coreclr/issues/17935,AndyAyersMS,4,0,0,0,0,0,when a caller argument is an exact type and feeds a virtual or interface call in the callee we might want to inline more aggressively.a toy example of this can be found in this benchmarkdotnet sample here run if inlined would allow the interface calls to devirtualize. run is currently pretty far from being a viable inline candidate: inline candidate callsite is boring multiplier increased to calleenativesizeestimate=callsitenativesizeestimate=benefit multiplier=.threshold=native estimate for function size exceeds threshold for inlining multiplier inline expansion aborted inline not profitableinliner during fginline result failed this call site reason unprofitable inline forjit_interfacemethod:run():double:this calling jit_interfacemethod:run(ref):double:this caller knows that the argument to run is exact: lvaupdateclass updating class for v ffcd foo to be exact stmt void il xc i-c-g call double jit_interfacemethod.run this in rcx lcl_var ref v this arg lcl_var ref v loc likely we would not give a x boost to inlining benefit based on one argument reaching one call site but if we also realized the call site was in a loop perhaps the net effect would be enough to justify an inline.currently we dont know when observing arg uses whether that use is in a loop or not but if we were to associate uses with callee il offsets we could circle back after finding all the branch targets and develop a crude estimator for loop depth then sum up the weighted observations.it would also be nice to tabulate a few more opportunities of this kind the basic observational part change is simple enough to prototype that perhaps just building it is one way to make forward progress
321617147,17932,https://api.github.com/repos/dotnet/coreclr/issues/17932,Petermarcu,0,0,0,1,0,0,"mike-eee commented on wed may net core team and community,i have a very interesting performance issue for you here i have produced some code that demonstrates a regressing difference in performance when switching from the net core x runtime to rc on my windows server machine that i am using as a hyper-v server please note that i am also using visual studio in producing my output here.to start this issue has context that is most recently rooted in a benchmark.net issue that you can view here i have created a series of five benchmarks using the exact same underlying test code each have a slight modification that produce different results in when run on my windows server host machine note the host machine and not a vm instance you can see an overview of this information here took the code that is in the rd example and by simply rebuilding it and running it in the runtime it produced slower results i have created this branch here for your convenience.(please do note that the results of each scenario are found in the readme.md of their respective branches.)additionally with a small change i was once again able to produce the faster result times as seen in but within the runtime i have published this branch here this is consistent with the bizarre behavior referenced in the five earlier examples but seen here in a different form or configuration for lack of a better term in i feel its worthy to note that i believe that this is a gremlin of a problem that i have been chasing in net core tooling since i have encountered the most weird of circumstances around this behavior while trying to benchmark code using benchmark.net you can see previous iterations of my previous more complicated attempts at wrestling this beast here for your reference that i have been able to show a regressing discrepancy in performance between and rc with a simple recompile i believe this could be due to a tooling/sdk problem that has been around for some time now fortunately i have been able to capture it using a very simple project this time and am more than happy to share it now in hopes to finally tracking down this very weird issue finally i will provide an overview of my windows server specifications here. summary operating system windows server standard bit cpu intel core i k ghz c ivy bridge-e nm technology ram gb ddr mhz motherboard asustek computer inc rampage iv extreme lga c graphics vw x@hz ghl x@hz vw x@hz vw x@hz mb nvidia geforce gtx gigabyte c storage gb samsung ssd pro series ssd c gb microsoft storage space device ssd c gb microsoft storage space device ssd c gb synology iscsi storage scsi disk device iscsi optical drives no optical disk drives detected audio high definition audio deviceoperating system windows server standard bit computer type virtual installation date pmcpu intel core i k cores threads name intel core i k code name ivy bridge-e package socket lga technology nm specification intel core i-k cpu ghz family extended family model e extended model e stepping revision s/s instructions mmx sse sse sse ssse sse sse intel nx aes avx virtualization not supported hyperthreading supported enabled fan speed rpm rated bus speed mhz stock core speed mhz stock bus speed mhz average temperature c caches l data cache size x kbytes l instructions cache size x kbytes l unified cache size x kbytes l unified cache size kbytes cores core core speed mhz multiplier x bus speed mhz rated bus speed mhz temperature c threads apic id core core speed mhz multiplier x bus speed mhz rated bus speed mhz temperature c threads apic id core core speed mhz multiplier x bus speed mhz rated bus speed mhz temperature c threads apic id core core speed mhz multiplier x bus speed mhz rated bus speed mhz temperature c threads apic id ram memory slots total memory slots used memory slots free memory slots memory type ddr size mbytes dram frequency mhz cas latency cl clocks ras to cas delay trcd clocks ras precharge trp clocks cycle time tras clocks command rate cr t physical memory memory usage total physical gb available physical gb total virtual gb available virtual gb spd number of spd modules slot type ddr size mbytes manufacturer kingston max bandwidth pc mhz part number khxcd/gx week/year spd ext xmp timing table jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v xmp frequency mhz cas latency ras to cas ras precharge tras voltage v slot type ddr size mbytes manufacturer kingston max bandwidth pc mhz part number khxcd/gx week/year spd ext xmp timing table jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v xmp frequency mhz cas latency ras to cas ras precharge tras voltage v slot type ddr size mbytes manufacturer kingston max bandwidth pc mhz part number khxcd/gx week/year spd ext xmp timing table jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v xmp frequency mhz cas latency ras to cas ras precharge tras voltage v slot type ddr size mbytes manufacturer kingston max bandwidth pc mhz part number khxcd/gx week/year spd ext xmp timing table jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v xmp frequency mhz cas latency ras to cas ras precharge tras voltage v slot type ddr size mbytes manufacturer kingston max bandwidth pc mhz part number khxcd/gx week/year spd ext xmp timing table jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v xmp frequency mhz cas latency ras to cas ras precharge tras voltage v slot type ddr size mbytes manufacturer kingston max bandwidth pc mhz part number khxcd/gx week/year spd ext xmp timing table jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v jedec frequency mhz cas latency ras to cas ras precharge tras trc voltage v xmp frequency mhz cas latency ras to cas ras precharge tras voltage v please let me know if you require any further information around this issue or my environment and i will be happy to get it for you.thank you for any assistance you can provide towards solving this issue"
321399848,17928,https://api.github.com/repos/dotnet/coreclr/issues/17928,stephentoub,2,0,0,0,0,0,when marshaling back results for a stringbuilder argument in a p/invoke for utf its allocating a new char pinning it and then handing that off to stringbuilder.replacebufferinternal which itself then allocates a new char and all of that happens even if the stringbuilders char is already big enough to handle the results which is commonly the case due to the stringbuilder having been sized appropriately from the get-go for both unicode and ansi its similarly allocating a new char invariably even if the existing buffer is already sufficient.this commit cleans that up.while ideally we wouldnt use stringbuilders at all in coreclr/corefx for marshaling we still do in some places e.g dns.gethostname while we should separately fix that to avoid using a stringbuilder at all its useful to demonstrate the impact of the change here: c# benchmark public static string gethostname dns.gethostname(); on my machine results in method gen allocated before kb after b cc jkotas jeremykuhne vancem
321277028,17919,https://api.github.com/repos/dotnet/coreclr/issues/17919,AndyAyersMS,2,0,0,0,0,0,improve value number support for various subtracts and unsigned compares.for instance for non-float values x x
321216699,17916,https://api.github.com/repos/dotnet/coreclr/issues/17916,stephentoub,2,0,0,0,0,0,i went through all substring calls in coreclr and replaced the ones that were straightforward.cc jkotas tarekgh danmosemsft
320869282,17908,https://api.github.com/repos/dotnet/coreclr/issues/17908,stephentoub,1,0,0,0,0,0,the only place it was used was in concurrentexclusiveschedulerpair and there threadlocal
320659018,17905,https://api.github.com/repos/dotnet/coreclr/issues/17905,danmosemsft,2,0,0,0,0,0,see this will reduce confusion as the work continues to unify more and more code in the two corelibs it makes sense for the directory name to reflect this also it reflects the rename we did from mscorlib for maryamariyan youll just need to do this and find everything that breaks not just in the repo eg the mirror
320468585,17891,https://api.github.com/repos/dotnet/coreclr/issues/17891,GrabYourPitchforks,1,0,0,0,0,1,"this takes advantage of roslyns new ref reassignment feature to speed up the inner loop in array.reverse testing shows that for large arrays the reversal time is cut by approx from the baseline.old loop codegen: asmff fcc cc movsxd r,eaxff fcf bc mov rd,dword ptr rcx+r* ff fc ed lea r, rcx+r* ff fc cd movsxd r,edxff fca bc mov rd,dword ptr rcx+r* ff fce mov dword ptr r ,rdff fc c mov dword ptr rcx+r* ,rdff fc ffc inc eaxff fc ffca dec edxff fc bc cmp eax,edxff fcb cdf jl ff fcc) new loop codegen: asmff e b mov edx,dword ptr rcx ff e b mov rd,dword ptr rax ff e mov dword ptr rcx ,rdff ea mov dword ptr rax ,edxff ec c add rcx,ff f cfc add rax,fffffffffffffffchff f bc cmp rcx,raxff f e jb ff e) the codegen samples above are for reversing an int i saw similar performance gains for other types referential types like object dont get as large a benefit due to the card table checks but there is still some speedup.i also took the opportunity to collapse the precondition checks using the recommended patterns for index count parameters"
320052970,17876,https://api.github.com/repos/dotnet/coreclr/issues/17876,jkotas,17,0,0,0,0,0,basesize for system.string was not set correctly it caused unnecessary extra bytes to be allocated at the end of strings that had length on bit platforms.this change makes affected strings proportionally cheaper for example new string(a in a long-running loop is faster
319210126,17850,https://api.github.com/repos/dotnet/coreclr/issues/17850,JoeStead,5,0,0,0,0,0,we have a coredump from our application that was built using the net core sdk a standalone app the application was running on centos to perform some analysis on the dump ive exported the file onto an ubuntu vm with lldb installed and the same net core sdk version that was used to build the application.im launching lldb like this: lldb usr/bin/dotnet core mydumpfilehere the dump is loaded and im able to use the standard lldb commands so far so good now i want to load the sos plugin which i do by running: plugin load usr/share/dotnet/shared/microsoft.netcore.app/../libsosplugin.so now if i type help i see the commands from the plugin finally i setclrpath to setclrpath usr/share/dotnet/shared/microsoft.netcore.app and to my knowledge i should be good to go now as soon as i use any sos command i get the following message: failed to load data access dll xcan not load or initialize libmscordaccore.so the target runtime may not be initialized. i thought that perhaps the sdk versions werent quite matching up so i built the coreclr repo and used the plugin from there instead still with no luck finally i thought i might be able to use the plugin thats actually shipped with our self contained app again that does not work the only thing i can think of is i need to analyse this on a centos machine but my limited understanding is that shouldnt matter
318611362,17826,https://api.github.com/repos/dotnet/coreclr/issues/17826,kbaladurin,2,0,0,0,0,0,apply and for linux/x
318500623,17818,https://api.github.com/repos/dotnet/coreclr/issues/17818,fiigii,7,0,0,0,0,0,refine the api design of intel hardware intrinsic related issues/prs implement remaining avx intrinsic rely on related issues/prs implement remaining sse intrinsic rely on related issues/prs enable containment analysis on more hardware intrinsic forms e.g imm arg arg etc implement fma intrinsic rely on fma intrinsic codegen is different from other isas whose instruction selection depends on the operators position e.g in registers or memory implement other isa classes bmi bmi aes and pclmulqdq fully support all the intel hardware intrinsic of existing apis create non-trivial benchmarks for intel hardware intrinsic related issues/prs improve the cq of intel hardware intrinsic base-on key scenarios partially rely on especially when intrinsics are used in combination or with things like vectors and identify areas that need work related issues/prs investigate the jit throughput impact from hardware intrinsic recognition rely on related discussion identify candidates that can be optimized using hw intrinsics and implement them using intrinsics corefx mscorlib hpc ml etc related issues/prs more...category:cqtheme:intrinsicsskill-level:intermediatecost:extra-large
318456132,17816,https://api.github.com/repos/dotnet/coreclr/issues/17816,sergey-kanaev,3,0,0,0,0,0,i have a third-party net standard class library built with msbuild via visualstudio the library has the satellitecontractversion attribute the corresponding satellite assembly with localization resources has an assembly version that differs from the main librarys assembly version.the main assembly is loaded successfully by the net framework and net core framework but the satellite assembly is loaded only if an application that uses the library is built with net framework the issue occurs in net core because the resourcemanager.getsatellitecontractversion method always returns the null value so the resourcemanager in net core ignores the version of the satellite assembly which is specified in the satellitecontractversion attribute of the main assembly instead the resourcemanager tries to load the satellite assembly with the version specified in the assemblyversion attribute of the main assembly.for example the following attributes are applied to the assembly assembly assemblyversion assembly satellitecontractversion(...) after building using msbuild the following assemblies are created a main assembly a.dll with version a satellite assembly a.resources.dll with version net core framework loads assembly a.dll with version and tries to load the a.resource.dll assembly with version net framework loads assembly a.dll with version and tries to load the a.resouces.dll assembly with version the issue leads to different behavior if the existing libraries with the satellitecontractversionattribute are built by msbuild in net framework applications and net core applications
318275101,17807,https://api.github.com/repos/dotnet/coreclr/issues/17807,noahfalk,2,0,0,0,0,0,previously this feature could only be enabled via complus_tieredcompilation variable now it can also be enabled from configproperties in the runtimeconfig.json
318229399,17802,https://api.github.com/repos/dotnet/coreclr/issues/17802,AndyAyersMS,1,0,0,0,0,0,the jit has been using ir pattern matching to find the information needed foroptimizing delegate construction this missed one case causing the code touse a very slow construction path.change introduced a token cache to convey this information to theoptimization for corert and some rr cases with this change the jit nownow relies on the token cache for all the other cases too.this initial commit preserves the pattern match code and verifies that whenit fires it reaches the same conclusion as the token cache does.this cross-validation revealed one case where the token information was lessspecific than the pattern match so we now also update the method handle inthe token from the call info.a subsequent commit will remove the pattern matching when we are confident thenew token cache logic handles all the cases correctly.closes
317842605,17788,https://api.github.com/repos/dotnet/coreclr/issues/17788,BruceForstall,1,0,0,0,0,0,"for the arm case of a special return buffer argument always x),we dont need the code to check for it because a few lines above allnon-standard args cause us to continue and skip the code.also remove a duplicative ifdef"
317809910,17785,https://api.github.com/repos/dotnet/coreclr/issues/17785,sdmaclea,1,0,0,0,0,0,ports to linux@creators andyayersms weshaggard bruceforstall russkeldorph jkotasi can confirm this allows tests to be built on my ubuntu skylake desktop as it hung before this is infinite improvement it took minutes to build the priority linux arm checked managed tests
317404197,17759,https://api.github.com/repos/dotnet/coreclr/issues/17759,sandreenko,1,0,0,0,0,0,the pr adds tests that are failing in our internal test system with arm altjit.failures are: codegencommon_cpp______assertion_failed__nyi__initialize_floating_point_register_to_zeroliveness_cpp______assertion_failed____we_should_never_encounter_a_reference_to_a_lclvar_that_has_a_zero_refcnt__lsraarm_cpp______assertion_failed____shouldn_t_see_an_integer_typed_gt_mod_node_in_arm
317218110,17750,https://api.github.com/repos/dotnet/coreclr/issues/17750,EgorBo,2,0,0,0,0,0,as far as i understand the following code var v new vector var v v f; converts f to a vector(.f f f and divide v by this vector see using intristics so it sounds like it should perform with the same speed as: var v new vector var v v new vector(.f f f); but the results are time slower than the division by a vector.it feels like new vector(float has wrong intristics and slower than new vector(float float float) does it use mm_set_ps to populate a vector from a scalar?i see all operations are inlined so i cant blame them.---! image
316859890,17733,https://api.github.com/repos/dotnet/coreclr/issues/17733,mikedn,2,0,0,0,0,0,currently gt_jcc/setcc nodes use relops as condition codes and this prevents the use of flag specific conditions e.g s ns p np and floating point conditions additionally the code used by gt_jtrue and relop codegen is rather convoluted and not very easy to reuse for gt_jcc/setcc codegen.this changes gt_jcc/setccs condition to gencondition a class that can encode all necessary conditions signed/unsigned integral conditions ordered/unordered floating point conditions and flag specific conditions mapping between gencondition codes and emitter jump kinds is done via arch specific tables instead of genjumpkindforoper and genjumpkindsfortree .gt_jtrue codegen has been updated to also use gencondition so that genjumpkindforoper and genjumpkindsfortree can be removed.contributes to
316310305,17697,https://api.github.com/repos/dotnet/coreclr/issues/17697,mikedn,1,0,0,0,0,0,failure to initialize these members can lead to bad code generation as described in
316087152,17691,https://api.github.com/repos/dotnet/coreclr/issues/17691,fiigii,0,1,0,0,0,0,fix ptal
316063952,17684,https://api.github.com/repos/dotnet/coreclr/issues/17684,BruceForstall,2,0,0,0,0,0,for non-windows builds we generally build with clang though for arm we build with clang and at least in the ci arm builds with clang should these all be updated to something consistent and newer e.g clang what is the process for making this decision and making it happen?@russkeldorph janvorli jkotas
315967798,17674,https://api.github.com/repos/dotnet/coreclr/issues/17674,CarolEidt,1,0,0,0,0,0,currently linearscan::resolveconflictingdefanduse may change the register assignment on the def or use of a tree temp sdsu when there is a conflict this may increase the likelihood that at least one of the references will get a desired register but it can cause problems when a necessary fixed register is not actually assigned this is because although there is a reftypefixedref associated with it that will only discourage other interval s from taking that register and will not actually cause it to be spilled if it is occupied a solution see and is to also mark the register as killed but that is overly conservative since if it is allocated to an interval that remains live e.g a lclvar it will be unnecessarily killed category:correctnesstheme:register-allocatorskill-level:expertcost:small
314599489,17581,https://api.github.com/repos/dotnet/coreclr/issues/17581,benaadams,2,0,0,0,0,0,x speed upfor useasync true pre image stephentoub jkotas is this a valid change
314303846,17563,https://api.github.com/repos/dotnet/coreclr/issues/17563,sdmaclea,1,0,0,0,0,0,while analyzing for it became apparent that the use of volatile in workstealingqueue was negatively impacting performancefor example localpop makes two volatile reads in its early out case only one is required makes seven volatile reads in its fast path only three are required localpush has similar issues. cansteal is making two volatile reads packing head/tail in one int could allow this to be a single volatile read this would also allow trysteal to be lockless
313938508,17536,https://api.github.com/repos/dotnet/coreclr/issues/17536,sdmaclea,1,0,0,0,0,0,fixes buggy jit_memset implementationuse heavily optimized platform implementationfollows linux amd arm precedent@janvorli ptal@dotnet/arm-contrib fyifixes which were actually due to bugs in jit_memset in rare corner casesi would like this for
313568741,17524,https://api.github.com/repos/dotnet/coreclr/issues/17524,BruceForstall,2,0,0,0,0,0,"byref pointers need to point within their host object thusthe alternate name interior pointers if the jit creates andreports a pointer as a byref but it points outside the hostobject and a gc occurs that moves the host object the byrefpointer will not be updated if a subsequent calculation putsthe byref back into the host object it will actually be pointingto garbage since the host object has moved.this occurred on arm with array index calculations in particularbecause arm doesnt have a single-instruction base scale*index offsetaddressing mode thus we were generating for the jaggedarr_cs_dotest case processjaggeddarray function r array object r computed index offset we mark r as a byref.add r r r r is the offset of the object we care about then we load the array element in this case the loaded element is a gcref so r becomes a gcref.ldr r r- we get this math because the user code uses a i which isessentially a i for element size this is optimizedto a i in the above code r is i in this case,after the first instruction r can point beyond the array.if a gc happens r isnt updated and the second instruction loads garbage.there are two fixes change array morphing in fgmorpharrayindex to rearrange the array indexir node creation to only create a byref pointer that is precise and no intermediatebyref pointers that dont represent the actual array element address beingcomputed change fgmoveopsleft to prevent the left-weighted reassociation optimization byref ref int int int byref byref ref int int thisoptimization creates incorrect byrefs that dont necessarily point withinthe host object.these fixes are all-platform.fixes there are many many diffs they perhaps surprisingly overwhelmingly positive.for amd superpmi the diffs are a size win for functions thisappears to be due to less code cloning and sometimes better optimization.for arm ngen-based desktop asm diffs it is a improvement across allframework assemblies a lot of the diffs seem to be because we cse the entirearray address offset expression not just the index expression"
313411408,17516,https://api.github.com/repos/dotnet/coreclr/issues/17516,ianhays,1,0,0,0,0,0,cc weshaggard janvorli
313285546,17512,https://api.github.com/repos/dotnet/coreclr/issues/17512,benaadams,2,0,0,0,0,0,"total bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes system.private.corelib.dasm of base total files with size differences improved regressed unchanged.top method improvements by size bytes system.private.corelib.dasm winmarshal:getexceptionforwinerror(int,ref):ref system.private.corelib.dasm timezoneinfo:getlocalizednamesbyregistrykey(ref,byref,byref,byref system.private.corelib.dasm string:concat(ref,ref,ref,ref):ref system.private.corelib.dasm path:combineinternal(ref,ref,ref,ref):ref system.private.corelib.dasm string:concat(ref,ref):ref methods system.private.corelib.dasm string:concat(ref,ref,ref):ref methods system.private.corelib.dasm path:combineinternal(ref,ref,ref):ref system.private.corelib.dasm calendardata:.ctor(ref,ushort,bool):this system.private.corelib.dasm environment:setenvironmentvariablecore(ref,ref system.private.corelib.dasm string:makeseparatorlist(ref,byref,byref):this system.private.corelib.dasm pathinternal:normalizedirectoryseparators(ref):ref system.private.corelib.dasm path:combineinternal(ref,ref):ref system.private.corelib.dasm pathinternal:equalstartingcharactercount(ref,ref,bool):int system.private.corelib.dasm calendardata:initializeeranames(ref,ushort):this system.private.corelib.dasm calendardata:initializeabbreviatederanames(ref,ushort):this system.private.corelib.dasm contracthelper:getdisplaymessage(int,ref,ref):ref system.private.corelib.dasm corelib:fixupcorelibname(ref):ref system.private.corelib.dasm string:concat(ref):ref methods system.private.corelib.dasm culturedata:get_sengdisplayname():ref:this system.private.corelib.dasm culturedata:get_snativedisplayname():ref:this system.private.corelib.dasm appcontextdefaultvalues:tryparseframeworkname(ref,byref,byref,byref):bool system.private.corelib.dasm environment:validatevariableandvalue(ref,byref system.private.corelib.dasm argumentexception:get_message():ref:this system.private.corelib.dasm contract:assertmustuserewriter(int,ref system.private.corelib.dasm contract:reportfailure(int,ref,ref,ref system.private.corelib.dasm eventpipeproviderconfiguration:.ctor(ref,long,int):this system.private.corelib.dasm eventpipeconfiguration:.ctor(ref,int):this system.private.corelib.dasm path:getrelativepath(ref,ref,int):ref system.private.corelib.dasm pathinternal:endswithperiodorspace(ref):bool system.private.corelib.dasm cultureinfo:get_parent():ref:this system.private.corelib.dasm culturedata:getculturedata(int,bool):ref system.private.corelib.dasm culturedata:get_timeseparator():ref:this system.private.corelib.dasm culturedata:getnfivalues(ref):this system.private.corelib.dasm numberformatinfo:.ctor(ref):this system.private.corelib.dasm systemtypemarshaler:converttomanaged(long,byref system.private.corelib.dasm stringbuilder:insert(int,ref,int):ref:this system.private.corelib.dasm assemblyloadcontext:validateassemblynamewithsimplename(ref,ref):ref:this system.private.corelib.dasm externalexception:tostring():ref:this system.private.corelib.dasm contracthelper:triggerfailure(int,ref,ref,ref,ref system.private.corelib.dasm typeforwardedfromattribute:.ctor(ref):this system.private.corelib.dasm resourcemanager:getstringfrompri(ref,ref,ref):ref:this system.private.corelib.dasm string:isnullorempty(ref):bool system.private.corelib.dasm environment:setenvironmentvariablecore(ref,ref,int system.private.corelib.dasm timezoneinfo:trygetlocalizednamebymuinativeresource(ref):ref system.private.corelib.dasm culturedata:getculturedataforregion(ref,bool):ref system.private.corelib.dasm culturedata:getculturedata(ref,bool):ref system.private.corelib.dasm culturedata:get_slocalizeddisplayname():ref:this system.private.corelib.dasm culturedata:get_isinvariantculture():bool:this system.private.corelib.dasm assembly:loadfromresolvehandler(ref,ref):ref system.private.corelib.dasm windowsruntimemetadata:ondesignernamespaceresolveevent(ref,ref):ref total methods with size differences improved regressed unchanged. from static bool startswithbracket(string hosttext if hosttext null u uint)hosttext.length return false var firstchar hosttext if firstchar return true return false desktop clr v clr.dll on amd.program.startswithbracket(system.string l test rcx rcx l jz lc l mov eax rcx+x l test eax eax la jnz lf lc xor eax eax le ret lf cmp word rcx+xc xb l jnz lc l mov eax x lb ret lc xor eax eax le ret vs public static bool startswithbracket(string hosttext if hosttext null hosttext.length return false var firstchar hosttext if firstchar return true return false desktop clr v clr.dll on amd.program.startswithbracket(system.string l sub rsp x l test rcx rcx l jz l l mov edx rcx+x lc test edx edx le jnz l l xor eax eax l add rsp x l ret l cmp edx x la jbe l lc cmp word rcx+xc xb l jnz ld l mov eax x l add rsp x lc ret ld xor eax eax lf add rsp x l ret l call xffaffc l int"
313045162,17498,https://api.github.com/repos/dotnet/coreclr/issues/17498,benaadams,0,0,0,0,0,1,contributes to ahsonkhan davidfowl grabyourpitchforks krzysztofcwalina
312742084,17490,https://api.github.com/repos/dotnet/coreclr/issues/17490,BruceForstall,5,0,0,16,0,0,remove the obsolete jit legacy_backend code.this was only ever supported for x and arm the x legacy_backend path has not been built for tested for several months for arm legacy_backend is currently still built and can be tested but ryujit/arm the non- legacy_backend code has been the default for many months.also delete the legacy backend support in netci.groovy in the desktop build and other places.this will drastically simplify the jit source code and will complete our multi-year transition to the ryujit architecture
312725903,17488,https://api.github.com/repos/dotnet/coreclr/issues/17488,noahfalk,8,0,0,0,0,0,this issue tracks raffaelers request from this is the culmination of all our symbol publishing work tracked here x produce and upload symbols for windows x produce and upload symbols for macos x produce and upload symbols for linux however if there is anything additional that needs to be done to achieve source stepping it should also be added as a dependency before this issue is closed
312722429,17486,https://api.github.com/repos/dotnet/coreclr/issues/17486,noahfalk,1,0,0,0,0,0,tracking a request originally made here on the os debugger and runtime a developer needs different versions of the sos binaries sos libsos libsosplugin we are working to make it easier to acquire these binaries and filed this work item to track the work i imagine a few things may need to happen sub-divide this issue if needed but retain this one to track overall status produce any binary variations that are currently non-existent figure out the most convenient mechanism for distributing the binaries likely in the sdk provide documentation
312604116,17481,https://api.github.com/repos/dotnet/coreclr/issues/17481,CarolEidt,2,0,0,0,0,0,currently the register allocator will blindly save restore a large vector thats live in a ymm register across a call the upper half of the callee-save registers are not saved across a call for feature_partial_simd_callee_save it will then save restore again across the next call even if the register hasnt been modified.also the determination of live largevectors is made prior to the finalizing of last-use information so its using the usually correct but imperfect relative to references to the same lclvar within a statement last-use information.this determination of whether to fully or partially spill such registers should be made during allocation and the register allocator should track when then upper half needs to be restored.category:cqtheme:register-allocatorskill-level:expertcost:medium
312391613,17477,https://api.github.com/repos/dotnet/coreclr/issues/17477,kouvel,0,0,0,0,0,1,the trigger was taking into account all non-tier jit invocations to delay call counting even for those methods that are not eligible for tiering in the allready benchmark some dynamic methods were being jitted frequently enough to not allow tier call counting to begin fixed to count only eligible methods jitted at tier such that methods not eligible for tiering dont interfere with the tiering heuristics
312238578,17469,https://api.github.com/repos/dotnet/coreclr/issues/17469,ltrzesniewski,1,0,0,0,0,0,ecma specifies the no opcode prefix as the following iii this prefix indicates that the subsequent instruction need not perform the specified fault checkwhen it is executed the byte that follows the instruction code indicates which checks canoptionally be skipped.in short it allows for automatic type checks range checks or null checks to be skipped which would be useful for optimizing hot code paths.the current implementation throws invalidprogramexception whenever it encounters this prefix this opcode is simply marked as unused right now a simple method which reproduces the problem: .method private hidebysig static int noprefix cil managed maxstack il ldc.i il newarr mscorlib system.int il ldc.i il no this is rangecheck nullcheck il_a ldelem.i il_b ret} category:correctnesstheme:msilskill-level:intermediatecost:medium
311838552,17451,https://api.github.com/repos/dotnet/coreclr/issues/17451,ahsonkhan,1,0,0,0,0,0,i tried to limit the changes mainly to files shared between coreclr/corefx relevant to system.memory.each set of changes is a separate commit.the idexx errors were fixed by vs so all instances of the errors within the solution got fixed.related pr on the corefx side dotnet/corefxlab-contrib stephentoub jkotas this should get mirrored cc anipik safern
311671697,17434,https://api.github.com/repos/dotnet/coreclr/issues/17434,Petermarcu,0,0,0,0,1,0,okarlsson commented on thu apr guys!im running a net core application in a docker container that runs in a ec instance on aws.i have a function for resizing profile images before they get uploaded and im using a third party library called imagesharp for this the library uses arraypools when handling the images and my memory usage shoots up to about gb after handling a image.but after the request has completed the memory usage never goes back but is allocated to these memory pools image i only have gb memory in my ec instance the entire instance crashes if i try to for example deploy a new version of my app when there is only mb memory available.is there any way to free up the memory allocated to the arraypools after i have finished a request so my containers dont run out of memory
311464888,17432,https://api.github.com/repos/dotnet/coreclr/issues/17432,stephentoub,0,0,0,0,0,1,the first commit just moves the count{hex}digits methods from into a partial formattinghelpers.countdigits.cs file in the shared partition once those changes replicate to corefx ill dedup the code there.the second commit then uses count{hex}digits in the tostring and tryformat methods of int uint long and ulong in particular for the default d format and some g configurations as well as the x format currently we create a temporary buffer on the stack format into it and then copy from that stack buffer into either the target span for tryformat or into a new string for tostring following the approach and sharing the same code from utfformatter where it first counts the number of digits in the output in order to determine an exact length this commit changes the implementation to skip the temporary buffer and just format directly into the destination span or string.contributes to jkotas ahsonkhan danmosemsft system.runtime.performance.tests.dll before after diff system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tostring(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_int.tryformat(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tostring(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x system.tests.perf_uint.tryformat(value x
311421078,17427,https://api.github.com/repos/dotnet/coreclr/issues/17427,CarolEidt,1,0,0,0,0,0,the test templates currently produce misleading output when a test fails the validateresult method sets the succeeded field to false when it encounters an error and all subsequent calls to validateresult will report failure validateresult should use a local success flag to check the results and then check that before reporting failure and setting the succeeded field to false .i encountered this when tracking down with the simpleternoptest template but i believe it applies to the others as well.category:testingtheme:intrinsicsskill-level:beginnercost:small
311108995,17405,https://api.github.com/repos/dotnet/coreclr/issues/17405,benaadams,1,0,0,0,0,0,contributes to to adds itemref to list as per jkotas
311031753,17399,https://api.github.com/repos/dotnet/coreclr/issues/17399,stephentoub,2,0,0,0,0,0,if the output matches the input string we can just use the input string as the result.this eliminates the allocation in common cases it has a measurable positive impact on windows for the cases i tried where no conversion is needed while also removing the allocation and for cases where conversion is needed it appears to result in no measurable degradation of throughput as those cases are already significantly more expensive.cc tarekgh krwq danmosemsft geoffkizer ahsonkhan
310807582,17393,https://api.github.com/repos/dotnet/coreclr/issues/17393,shakeri,1,0,0,0,0,0,when i change date and time on ubuntu server with this command: sudo date set apr and run this code: console.writeline(datetime.now); here are its output while the current server time is my app.csproj file
310161563,17350,https://api.github.com/repos/dotnet/coreclr/issues/17350,adiaaida,2,0,0,0,0,0,this change adds an additional scenario benchmark the wordvecbenchmark the harness pulls down wordvec.net from eabdullin applies apatch of changes that we made to work with netcoreapp harness theword training and search and then runs the benchmark it also updatesthe timeout for running benchmarks since the training scenario on am file takes about minutes locally
309908760,17326,https://api.github.com/repos/dotnet/coreclr/issues/17326,Maoni0,1,0,0,0,0,0,this is to be used by bcl for deciding when to trim memory usage in poolingcode
309897770,17325,https://api.github.com/repos/dotnet/coreclr/issues/17325,Maoni0,1,0,0,0,0,0,sometimes it may be desirable to not have gc to clear memory when it hands an object out this issue is to track providing such an option to users the gc part is tracked via
309896872,17324,https://api.github.com/repos/dotnet/coreclr/issues/17324,Maoni0,5,0,0,0,0,0,sometimes it may be desirable to not have gc to clear memory when it hands an object out i am using this issue to track providing such an option for large objects in gc which is pretty simple if gcheap::alloc is called with this intention indicated in the flag gc will not clear the memory theres also a part in the higher level component that will need to expose such a flag and pass it down to the alloc helper which will be tracked in a separate issue
309502045,17298,https://api.github.com/repos/dotnet/coreclr/issues/17298,RussKeldorph,0,0,0,1,0,0,fixes
309222716,17286,https://api.github.com/repos/dotnet/coreclr/issues/17286,fiigii,1,0,0,0,0,0,fix the failure in jkotas caroleidt tannergooding
309133296,17273,https://api.github.com/repos/dotnet/coreclr/issues/17273,benaadams,1,0,0,0,0,0,it potentially could since it resolves to calls on object .however more pressing is regression in dictionary for object types andyayersms danmosemsft ianhayscategory:cqtheme:devirtualizationskill-level:intermediatecost:medium
309115277,17268,https://api.github.com/repos/dotnet/coreclr/issues/17268,weshaggard,1,0,0,0,0,0,port and to release branch to fix source-build.fyi dseefeld dagood cc russkeldorph jashook
309021886,17251,https://api.github.com/repos/dotnet/coreclr/issues/17251,stephentoub,1,0,0,0,0,0,my previous changes to add span support to streamwriter regressed performance for small inputs this was primarily due to refactoring out a bunch of duplicated code into a shared span-based helper.this change keeps the helper but uses aggressiveinlining to avoid the extra function call essentially restoring the previous every method has its own copy approach but without the c code duplication i also cleaned up the checkasynctaskinprogress helper to make it streamlined and inlineable test before after improvement system.io.tests.perf_streamwriter.writechararray(writelength system.io.tests.perf_streamwriter.writechararray(writelength system.io.tests.perf_streamwriter.writepartialchararray(writelength system.io.tests.perf_streamwriter.writepartialchararray(writelength system.io.tests.perf_streamwriter.writestring(writelength system.io.tests.perf_streamwriter.writestring(writelength fixes danmosemsft jkotas
308780705,17240,https://api.github.com/repos/dotnet/coreclr/issues/17240,BruceForstall,1,0,1,1,0,0,these are failing almost every job with qeumu unsupportedsyscall issue
308641409,17225,https://api.github.com/repos/dotnet/coreclr/issues/17225,tannergooding,2,0,0,0,0,0,for the case where the setvector helper functions are called with all constant arguments we should support emitting a constant which can be loaded from memory rather than emitting a chain of shuffle or insert calls.category:cqtheme:vector-codegenskill-level:intermediatecost:medium
308558215,17221,https://api.github.com/repos/dotnet/coreclr/issues/17221,janvorli,1,0,0,0,0,0,i have removed libunwind dependency in a recent commit butit turns out that the build was using incorrect includepaths and it was still depending on the libunwind installationfor the libunwind.h header.this change fixes it
308328331,17208,https://api.github.com/repos/dotnet/coreclr/issues/17208,benaadams,0,0,0,1,0,0,resolves jkotas stephentoub jeremykuhne danmosemsft
308232689,17185,https://api.github.com/repos/dotnet/coreclr/issues/17185,jkotas,0,0,0,2,0,0,remove internalsvisibleto for mscorlib and make sure that corefx still builds with it.delete global constants that were left-overs from net framework build system
308180477,17161,https://api.github.com/repos/dotnet/coreclr/issues/17161,4creators,7,0,0,3,0,5,fixes and is a part of the build time improvement for priority tests hours minutes seconds on original time and now takes what means that build and test is faster .test build time improved from to what is faster
308135502,17155,https://api.github.com/repos/dotnet/coreclr/issues/17155,fiigii,1,0,0,0,0,0,according to the discussion remove avx.zeroupper/zeroall apis from mscorlib due to their non-deterministic semantics.also remove avx.zeroextendtovector from avx.platformnotsupported.cs that was an oversight from previous prs.@caroleidt tannergooding eerhardt
308113200,17153,https://api.github.com/repos/dotnet/coreclr/issues/17153,mikem8361,2,0,0,0,0,0,yes interop debugging is net core has the restriction that you cannot hit breakpoints in native code before the net runtime starts.@mikem is there an issue that tracks removing that restriction?fixing this would require a major architectural change to how interop debugging works so i dont think it will be resolved any time soon i would probably recomend switching back and forth between your c project and your net core project depending on which type of code you want to debug this is what i do all the time while debugging the net core debugger which has lots of both c and c code).see
307679657,17125,https://api.github.com/repos/dotnet/coreclr/issues/17125,jzielnik,1,0,0,0,0,0,"hello,ive been working on a project that could load other projects using microsoft.build.evaluation.project however ive encountered an issue project class has icollection allevaluateditems properity but for net core and net standard projects this collection does not have references which can be found under dependencies/sdk ive managed to find that after building such project in obj there is project.assets.json file which contains all paths to those sdks libraries however there are sometimes multiple versionsof those libs i have data about loaded project targetframework property but sometimes its not one-to-one match of library path and targeted framework.is there some nice and easy way to find out which one of those is loaded by clr as it must know which one to chose based or project properties perhaps some kind of library or algorithm or does it need to be checked manually for each lib?thanks and regards,jakub"
307457473,17110,https://api.github.com/repos/dotnet/coreclr/issues/17110,AndyAyersMS,1,0,0,0,0,0,instead of movsd which is for gprs fixes one of the stress failuresseen in
307317090,17094,https://api.github.com/repos/dotnet/coreclr/issues/17094,janvorli,2,0,0,0,1,0,this change removes dependency on the libunwind for all unixes except osx by including its sources in coreclr pal in osx the libunwind is part of the os and also has support for compact unwind info that is osx specific so we keep using that one.the sources were taken from already have the license for it described in are two commits one is just a pure copy of the original sources with addedchanges in gitignore that contained entries that were filtering out some files in the libunwind i.h pattern and x folders the second commit enables building libunwind for all the architectures we support.i have tested the build for x on ubuntu alpine and freebsd ive also testedbuild for arm arm and x on ubuntu using cross build.ive found a bug in the x code of the libunwind but ill leave the fix for later and create an issue for it while the fix looks trivial it still needs to be tested
307296322,17092,https://api.github.com/repos/dotnet/coreclr/issues/17092,stephentoub,6,0,0,4,0,0,two main changes rewrote the formatting to use span directly rather than going through stringbuilder only to then discover that we already had almost exactly the same implementation in utfformatter as that one had some extra optimizations around jit behaviors i ported that over instead but i also took advantage of a few things that can be done only in corelib avoided threadstatic lookups unless necessary. before method mean error stddev tostringo ms ms ms tostringr ms ms ms tryformato ms ms ms tryformatr ms ms ms after method mean error stddev tostringo us us us tostringr us us us tryformato us us us tryformatr us us us test: c#using system;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.attributes;using benchmarkdotnet.running; inprocess public class program public static void main benchmarkrunner.run
307024756,17073,https://api.github.com/repos/dotnet/coreclr/issues/17073,mikedn,3,0,0,0,0,0,hw intrinsics that produce a bool value need special handling when the value they produce is used by a conditional branch as is now the intrinsic node produces the value in a register and then an additional test is required to check for false/true and branch.for example c#return sse.compareequalorderedscalar(x y generates asm cefc vcomisd xmm xmm fbc setpo dl fc sete al c and al dl fbd movzx rdx al d test edx edx jne short g_m_ig b mov eax g_m_ig c retg_m_ig b mov eax g_m_ig c ret but it should generate something like asmg_m_ig ceec vcomisd xmm xmm a jpe short g_m_ig je short g_m_igg_m_ig b mov eax g_m_ig c retg_m_ig b mov eax g_m_ig c ret as far as i can tell this affects pretty much all hw intrinsics that return bool except issupported of course.category:cqtheme:intrinsicsskill-level:expertcost:medium
306691859,17055,https://api.github.com/repos/dotnet/coreclr/issues/17055,sandreenko,1,0,0,0,0,0,for methods that use longvarsets bitsetshortlongrep have more than lclvars codegen allocates a lot of memory for these sets in compupdatetreelife function it creates new sets for each instruction and wastes these temp variables.so this change keeps all these temp sets in its own class and allows to reduce memory consumption for big methods.mem stats for windows_nt.x.release\jit\jit\opt\cse\hugeexpr\hugeexpr.exe: before:all allocations:for methods count avg per method alloc size avg per method max alloc allocatememory avg per method nraused avg per method)allocd bytes by kind kind size pct astnode lsra_interval lsra_refposition bitset after:all allocations:for methods count avg per method alloc size avg per method max alloc allocatememory avg per method nraused avg per method)allocd bytes by kind kind size pct astnode lsra_interval lsra_refposition bitset so we save mb in release x.the percent is bigger with jitstress and this change allows us to generate ni for hugeexpr on x for arm with jitstress that i needed to repro before it was out of memory).diffs for system.private.corelib are small because it doesnt have methods with many locals: before:bitset after:bitset i will add spmi results later.part the second part once the second part is merged i will rebase this pr to remove the first commits from this pr.note in an ideal world we would not call liveness from codegen and save both memory and time instead we should save all necessary gc info in lsra but because codegen creates new trees and moves old instructions we have to compute liveness twice
306334675,17029,https://api.github.com/repos/dotnet/coreclr/issues/17029,jkotas,0,0,0,2,0,0,this makes string.gethashcode a bit faster for small strings because of some of the fcall overhead goes away e.g hello world!.gethashcode is about faster on windows x the performance for larger strings is same
306186550,17018,https://api.github.com/repos/dotnet/coreclr/issues/17018,BruceForstall,1,0,0,0,0,0,a pool of about arm tegra k machines running ubuntu is attached to our jenkins ci available for running tests this change enables a large portion of the normal set of dotnet/coreclr tests including jit stress tests to run on these machines.in addition a considerable amount of netci.groovy refactoring was done
306175250,17015,https://api.github.com/repos/dotnet/coreclr/issues/17015,Petermarcu,2,0,0,0,0,0,strich commented on thu feb issue titlerecently ive been looking into building a small application to solve a problem and i immediately reached for net core i needed to be able to run the app on win linux and mac generala wrote a small application with a few dependencies primarily the ef.core.sqlite package as i needed to read some information from a local sqlite file nothing beyond that i used the internally available http client to do some http post/get stuff.unfortunately i hadnt done my research as i noticed that by default net core console apps build to an executable dll not quite what i had in mind from a developer ux perspective is this really correct surely the common usecase for console apps would still be an executable that a user would still want to treat as an exe and not as something run from a console with dotnet myapp.dll .anywho i soon realised i can use dotnet publish to compile an executable and furthermore do so as a standalone by copying the required dlls into the same directory so it can run without any net installation on the machine however i was fairly surprised that there were a total of or so separate dll files for my purposes im not sure i could distribute my application like this my users would bulk as having to integrate such a large sum of files for my purposes i really need a single executable file from a user ux perspective the file itself can be quite large the dlls above weighed in at mb which is pretty damn large for such a small app but again not necessarily a pain for me.i suppose my key point here is is there a concerted effort to be able to use net core to create standalone single file or at least file applications?---@petermarcu commented on thu feb few comments/questions are you willing to install the runtime as a pre-requisite or do you want to ship the runtime with the application there is a feature that is being designed to enable apps that depend on a runtime still having an exe this world would allow your app to be much smaller but would require that net core runtime that you depend on be installed on the target machine we have a preview of a linker that will shake out code that is not used and usually makes the app smaller but doesnt change the number of dlls check out the next step after the linker will be something that is being called bundling which is exactly what you talked about the ability to have a single executable artifact there isnt a clear timeline/roadmap on that one but i know there are people looking into it you mentioned users not wanting to integrate such large numbers of files is the option of putting up a zip file that you just tell people to extract an option if all the files were in a sub folder and when they opened your app it was just an exe maybe also a config and then a sub folder with dependencies would that help?---@strich commented on thu feb this particular instance the application is a sort of middleware that would be part of a larger application by the end user a developer they may or may not be using net at all so it is pretty important that i dont force them to have to add entire framework installers to deploy alongside it just to support this middleware.the linker looks promising and was something i had stumbled upon previously but i suppose what im really looking for is the bundling feature without it i dont think this middleware app will survive without a lot of heat from the user.i daresay my application as middleware is not one of the most common usecases but i do think it is important that bundling is made available soon as the ability to quickly write and deploy a single file solution is powerful.---@petermarcu commented on thu feb that this would be a useful feature sbomer jeffschwmsft as fyi i think this may be tracked elsewhere but ill leave this issue open for now unless there is a better one to point to
306126676,17008,https://api.github.com/repos/dotnet/coreclr/issues/17008,sdmaclea,1,0,0,0,0,0,jit/directed/rvainit/oddsize/oddsize.sh corerun oddsize.exeassert failure(pid xa thread xa assertion failed obj->gtintcon.gticonval in test:main():int il size file src/jit/compiler.hpp line first failure observed on dbeadflast observed pass on eef
306121752,17006,https://api.github.com/repos/dotnet/coreclr/issues/17006,AndyAyersMS,1,0,0,1,0,0,improve the jits ability to optimize a box-interface call sequenceto handle cases where the unboxed entry point requires a method tableargument.added two test cases one from the inspiring issue and another wherethe jit is then able to inline the method.closes
306021778,16994,https://api.github.com/repos/dotnet/coreclr/issues/16994,jkotas,8,0,0,0,0,0,spanhelpers.sequenceequal is our optimized workhorse for comparing blocks of memory use it for string equality instead of ad-hoc optimized loops. hello world!.equals(hello world is faster on x with this change and it only gets better from there
305997761,16991,https://api.github.com/repos/dotnet/coreclr/issues/16991,benaadams,1,0,0,0,0,0,for dictionary resolves vancem jkotas danmosemsft stephentoub
305857039,16986,https://api.github.com/repos/dotnet/coreclr/issues/16986,nietras,1,0,0,0,0,0,wip work in progress see code review not specific to coreclr should be done in the corefx pr.@ahsonkhan here span.sort in coreclr this builds but i have not yet had time to test this in corefx yet
305787062,16982,https://api.github.com/repos/dotnet/coreclr/issues/16982,stephentoub,1,0,0,0,0,0,helped to avoid allocations when invoking methods on structs cast to interfaces but it appears it didnt completely address it.this code advantage of this feature and with a repro like: c#using system;using system.threading;using system.threading.tasks;class program static async task main for int i i i await new valuetask(task.delay().continuewith default(int))).configureawait(false it successfully avoids the allocation but change the int s in the above to string s and it starts allocating boxes for the interface: c#using system;using system.threading;using system.threading.tasks;class program static async task main for int i i i await new valuetask(task.delay().continuewith default(string))).configureawait(false andyayersms could you take a look?we either need to fix this for if you can that would be excellent or in i need to change the async method builder code to work a different way as we cant have this allocation happening per await
305403849,16953,https://api.github.com/repos/dotnet/coreclr/issues/16953,echesakovMSFT,0,0,0,1,0,0,this pr adds compiling and publishing of x_arm/crossgen so called cross-crossgen to linux/arm official buildmerge only after dotnet/dotnet-buildtools-prereqs-docker is resolved and official build images are updated
304944579,16920,https://api.github.com/repos/dotnet/coreclr/issues/16920,adiaaida,2,0,0,0,0,0,when we try to run tests\runtests.cmd generatelayoutonly after building with the skiptests option the script fails with the following error: c:\coreclr\tests\publishdependency.targets error lock file c:\coreclr\tests\src\common\test_runtime\obj\project.assets.json couldnt be found run a nuget package restore to generate this file c:\coreclr\tests\runtest.proj this scenario should be supported
304080890,16881,https://api.github.com/repos/dotnet/coreclr/issues/16881,AndreyAkinshin,3,0,0,0,0,0,currently performance-guidelines.md contains only windows-specific information running the coreclr performance tests on windows the first step to running the performance tests locally is to do a release build of coreclr and all of the performance tests you can do this with the command build.cmd x release this will of course build the x runtime and you should use x if you want to test x after building the runtime you will need to generate a core root that contains all of the binaries we just built along with the required dependencies this can be done with the command tests\runtest.cmd release x generatelayoutonly with the same caveat that x should be used if that is the platform that you are testing now we need to actually run the performance tests you can do that with the following command that should be run from the root of your repo tests\scripts\run-xunit-perf.cmd arch x configuration release testbinloc bin\tests\windows_nt.x.release\jit\performance\codequality this will run all of the tests in the jit codequality directory as the script will walk all sub-directories and look for tests to run if you want to just run a single test pass the path of the single test that you want to run navigate to the sandbox directory in the root of your repo inside that directory you will find a bunch of files that follow the name perf-*.md these will contain the results formatted as markdown files for each test that was run.---unfortunately its hard to apply this instruction for linux and macos runtest.sh and run-xunit-perf.py have another sets of arguments for example there is no the generatelayoutonly option in runtest.sh also it makes sense to say that python is required as a part of the setup there are a lot of python scripts in tests/scripts
304030760,16877,https://api.github.com/repos/dotnet/coreclr/issues/16877,CarolEidt,1,0,0,0,0,0,we dont bother with the parts of lsra that deal with lclvars if we have no tracked lclvars however we need to check that after liveness has run post-lowering otherwise we miss any lclvars created by optimizations or during lowering.fix
304027942,16875,https://api.github.com/repos/dotnet/coreclr/issues/16875,sywhang,0,0,0,3,0,0,address issue and tested on windows windows server attached is a screenshot of an example crash log in event viewer:
304007322,16873,https://api.github.com/repos/dotnet/coreclr/issues/16873,AndyAyersMS,3,0,0,0,0,0,current code alignment strategy seems a bit random best i can tell it is on x we generally byte align jitted code but we byte align small methods when prejitting we byte align ibc hot methods and otherwise byte align on x we always byte align when jitting and byte align when prejittinghavent looked at arm arm.over-aligning leads to wasted code space under-aligning leads to possible perf issues either poor per or just randomly variable perf as in generally speaking wed prefer frequently-called methods to be maximally aligned and rarely called methods be minimally aligned from a jit standpoint it seems like minopts/debug/tier code should always have minimum alignment tier code should have maximum alignment and the alignment of regularly optimized code is open for discussion.also note method entry alignment constrains loop top alignment category:cqtheme:basic-cqskill-level:expertcost:large
303863107,16854,https://api.github.com/repos/dotnet/coreclr/issues/16854,4creators,3,0,0,0,0,0,hw intrinsics project is approaching a point where it will be possible to write real life code using available isas this should allow to validate intrinsics implementation using complex functionality like cryptographic media and scientific algorithms/applications implementation.possible candidates include sha keccak algorithm jpeg jpeg algorithms fft some regex algorithms and many others.this issue could be used for discussion on performance tests and their implementation.@caroleidt fiigii mikedn sdmaclea tannergooding andyayersms category:testingtheme:intrinsicsskill-level:intermediatecost:medium
303631896,16843,https://api.github.com/repos/dotnet/coreclr/issues/16843,AndyAyersMS,1,0,0,0,0,0,in an example like c#using system;using system.runtime.compilerservices;class x methodimpl(methodimploptions.noinlining static int n public static int main int n n int p new int n q new int n s new int n for int i i n i p i i q i i s i i return p q s inspired by code in fannkuch there should only be one range check for p the remainder are all unnecessary.the jit should realize after the first newarray n is known to be non-negative all the for loop accesses are within the array bounds so loop cloning is pointless since p q and s all have the same length the check for p covers the other two checks.the current jit doesnt handle this very well. asm lcl frame size g_m_ig push rdi push rsi push rbx ec sub rsp g_m_ig eecfbffff call x:n():int bf mov esi eax bd mov edx esi badbafef mov rcx xffebada ecef call corinfo_help_newarr__vc bf mov rdi rax bd mov edx esi badbafef mov rcx xffebada edcef call corinfo_help_newarr__vc bd mov rbx rax bd mov edx esi badbafef mov rcx xffebada ecef call corinfo_help_newarr__vc d xor edx edx f test esi esi ef jle short g_m_ig cmp dword ptr rdi esi fdc setge cl fbc movzx rcx cl f test esi esi fdc setge rb fbc movzx r rb c and ecx rd cmp dword ptr rbx esi fdc setge rb fbc movzx r rb c and ecx rd cmp dword ptr rax esi fdc setge rb fbc movzx r rb c test ecx rd je short g_m_igg_m_ig ca movsxd rcx edx f mov dword ptr rdi+*rcx edx b mov dword ptr rbx+*rcx edx mov dword ptr rax+*rcx edx ffc inc edx bd cmp edx esi ceb jl short g_m_ig eb jmp short g_m_igg_m_ig b cmp edx dword ptr rdi jae short g_m_ig ca movsxd rcx edx f mov dword ptr rdi+*rcx edx b cmp edx dword ptr rbx b jae short g_m_ig b mov dword ptr rbx+*rcx edx b cmp edx dword ptr rax jae short g_m_ig mov dword ptr rax+*rcx edx ffc inc edx bd cmp edx esi cdc jl short g_m_igg_m_ig f cmp dword ptr rdi jbe short g_m_ig b mov edx dword ptr rdi c add edx b cmp dword ptr rbx jbe short g_m_ig b sub edx dword ptr rbx cmp dword ptr rax d jbe short g_m_ig add edx dword ptr rax bc mov eax edxg_m_ig c add rsp b pop rbx e pop rsi f pop rdi c retg_m_ig eff call corinfo_help_rngchkfail cc int total bytes of code prolog size for method x:main():int category:cqtheme:range-checkskill-level:expertcost:medium
303308984,16822,https://api.github.com/repos/dotnet/coreclr/issues/16822,sdmaclea,1,0,0,0,0,0,dotnet/arm-contrib caroleidt russkeldorph eerhardt tannergooding ptal
303299682,16819,https://api.github.com/repos/dotnet/coreclr/issues/16819,tannergooding,1,0,0,0,0,0,for nodes with rmw semantics we are currently setting op as delayfree in a number of scenarios can cause poor codegen in certain scenarios such as when op and op are the same value i.e the same local and where op is the final use for that value.one example of this is: c#public static vector
303244877,16808,https://api.github.com/repos/dotnet/coreclr/issues/16808,tannergooding,1,0,0,0,0,0,this mostly resolves
303231361,16806,https://api.github.com/repos/dotnet/coreclr/issues/16806,jherby2k,5,0,0,0,0,0,i cant find any information about a net standard i really want to use the new span-ified methods like stream.read in my class libraries but it looks like that stuff isnt in system.memory but rather the net core sdk any other way to get these apis or do i have to wait for net standard and is there any eta on that
302986635,16796,https://api.github.com/repos/dotnet/coreclr/issues/16796,ww898,15,0,0,0,0,0,"hi there,is there plans to enable feature_profapi_attach_detach in coreclr do you have any plans will you did it separately on linux and windows"
302818886,16782,https://api.github.com/repos/dotnet/coreclr/issues/16782,glasperfan,1,0,0,0,0,0,the tryparse method naming pattern is designed to improve performance as documented on msdn consider the tryparse pattern for members that may throw exceptions in common scenarios to avoid performance problems related to exceptions.datetimes tryparseexact currently fails to catch a common scenario where the position of the month and day are reversed in the input string and input format an example would be trying to parse as day - month - year using a minimal parsing program the following metrics were recorded all experiments made tryparseexact call on varying input dates the times averaged over several runs.__update more accurate metrics posted in a comment below.__test test description time ms all parse successfully with format yyyy-dd-mmthh:mm:ss all fail to parse due to format error format is yyyyz-dd-mmthh:mm:ss switch month and day position t format input like t repeat t now with perf fix to gregoriancalendar performance profiling showed that of the slowdown was due to exception handling and the throw can be traced to when the calendar verifies whether the parsed date is a valid one including a basic constraint check on the month and day and avoiding the exception in trytodatetime prevents this perf issue.while this change address the scenario above there is future work to be done to avoid exception handling in the tryparse call path
302787820,16779,https://api.github.com/repos/dotnet/coreclr/issues/16779,tannergooding,1,0,0,0,0,0,this modifies the test templates and generatetests.csx to use named arguments rather than indexed arguments when formatting.this makes it easier to modify the templates without breaking everything
302787332,16778,https://api.github.com/repos/dotnet/coreclr/issues/16778,tannergooding,1,0,0,0,0,0,this resolves
302732811,16777,https://api.github.com/repos/dotnet/coreclr/issues/16777,tannergooding,1,0,0,0,0,0,fyi caroleidt fiigii
302587407,16772,https://api.github.com/repos/dotnet/coreclr/issues/16772,fiigii,1,0,0,0,0,0,this pr .
302157984,16750,https://api.github.com/repos/dotnet/coreclr/issues/16750,fiigii,1,0,0,0,0,0,we have updated numargsofhwintrinsics so the intrinsics that have variable number of parameters can be table-driven
301940867,16723,https://api.github.com/repos/dotnet/coreclr/issues/16723,sdmaclea,0,0,0,0,0,1,using a bootstrap cli arm/ubuntu native builds can build to completion.i was able to get this to work by built bootstap cli based on dotnet-sdk-..-preview--linux-x fix crossgen with merged no longer a separate step use to enable using bootstrap cli disable sos build diff git a/src/.nuget/microsoft.netcore.runtime.coreclr/runtime.linux.microsoft.netcore.runtime.coreclr.props b/src/.nuget/microsoft.netcore.runtime.coreclr/runtime.linux.microsoft.netcore.runtime.coreclr.propsindex ebb..b a/src/.nuget/microsoft.netcore.runtime.coreclr/runtime.linux.microsoft.netcore.runtime.coreclr.props b/src/.nuget/microsoft.netcore.runtime.coreclr/runtime.linux.microsoft.netcore.runtime.coreclr.props nativebinary include=$(bindir)sosdocsunix.txt nativebinary include=$(bindir)system.private.corelib.dll nativebinary condition=$(_platformdoesnotsupportcreatedump true include=$(bindir)createdump architecturespecificlibfile include=$(bindir)sos.netcore.dll architecturespecifictoolfile include=$(bindir)crossgen itemgroup project>diff git a/src/build.proj b/src/build.projindex fce..b a/src/build.proj b/src/build.proj list the projects that need to be built itemgroup project condition=$(skipsos true include=toolbox\sos\netcore\sos.netcore.csproj project include=mscorlib\system.private.corelib.csproj itemgroup build using bootstrap cli export dotnetbootstrapclitarpath=
301355241,16682,https://api.github.com/repos/dotnet/coreclr/issues/16682,7sharp9,2,0,0,0,0,0,there is no documentation on performance testing with osx while running on osx is fine there are points where you need to figure out why certain functions are slow or where memory is allocated it would be great if even simple ways to do this were documented at the moment there is no information on osx like there is on linux pointers would be greatly appreciated
301315785,16680,https://api.github.com/repos/dotnet/coreclr/issues/16680,jkotas,1,0,0,0,0,0,fixes dotnet/corefx
301181414,16664,https://api.github.com/repos/dotnet/coreclr/issues/16664,nerzhulart,1,0,0,0,0,0,we call libdbgshim.dylib via pinvoke on mono on osx when debugging net core and prior everything works fine.i see something suspicious at runtime startup thread thread frame xca libmscordaccore.dylib ensurestacksize(unsigned long frame x libmscordaccore.dylib initialize(int char const const unsigned int frame xe libmscordaccore.dylib pal_registermodule frame xb libdbgshim.dylib loadregisterlibrarydirect(void char const int frame xc libdbgshim.dylib loadlibraryexa frame xea libdbgshim.dylib runtimestartuphelper::invokestartupcallback(char void frame xbcf libdbgshim.dylib pal_runtimestartuphelper::invokestartupcallback frame xbaa libdbgshim.dylib pal_runtimestartuphelper::startuphelperthread frame xbe libdbgshim.dylib startuphelperthread(void frame xcf libdbgshim.dylib corunix::cpalthread::threadentry(void frame xfffaddc libsystem_pthread.dylib _pthread_body frame xfffaddd libsystem_pthread.dylib _pthread_start frame xfffaddcd libsystem_pthread.dylib thread_start the whole threads dump that code with ensurestacksize function was added only on branch
301170709,16663,https://api.github.com/repos/dotnet/coreclr/issues/16663,sandreenko,1,0,0,0,0,0,this is a draft pr to show the general ideas of prs that i will start publishing soon and get feedback on early stage commit separate fgsetblockhasgcsafepoint and fgcomputereachabilitysets they are different things that should not be together and need different algorithms commit creates successors lists for blocks that will be used later in the pr for merge i think i will replace linked list with vectors for both preds and succs yes we already have several functions that return successors for example getsucc( compiler number however neither of them match fgcomputepreds behavior because we have mess with exception blocks commit optimize fgsetblockhasgcsafepoint to use a linear algorithm o(n jithashtable access time the previous algorithm was slow and did not run new iteration if bbf_gc_safe_point changed but bbreach did not however because we did many extra iteration for bbreach we did not hit this case and because missing bbf_gc_safe_point does not affect correctness commit optimize fgcomputereachabilitysets use classic iterative algorithm its complexity is sum for all node of f(node where f(node is number of loops that include this node before we have number of nodes depth of the biggest nested loop these changes fix these changes doesnt show any measurable throughput diff on system.private.corelib with pintool.what is not included in this pr but will be made as part of work on fgremoveunreachableblocks and bbf_loop_head will be separated fgremoveunreachableblocks will be rewritten to use primitive block liveness linear scan not it is using reachability sets why fgcomputereachabilitysets will be called only once when all unreachable blocks are deleted now we recalculate it for each iteration that we can have more on arm because of the special hack for exception unwinding optimize variables liveness in the same way.all these changes will be extracted in a separate class with headers and other comments
301113200,16659,https://api.github.com/repos/dotnet/coreclr/issues/16659,mikedn,3,0,0,0,0,0,avoid unnecessary checked and signed arithmetic handle special cases such as cast between same size types and from byte sized types the jit is unable to optimize these cases currently.contributes to it would be nice to address some of the problems this code exposes in the jit but that will take a while so for now lets fix the source code
300885959,16648,https://api.github.com/repos/dotnet/coreclr/issues/16648,jkotas,0,0,0,1,0,0,cas leftovers
300859860,16646,https://api.github.com/repos/dotnet/coreclr/issues/16646,fiigii,1,0,0,0,0,0,this pr updates the table-driven framework to unify throwing pnse from r instructions on bit platforms and simplify sse/sse intrinsic code(close implements sse insert and extract and marks sse as complete.@caroleidt tannergooding ptal
300607057,16622,https://api.github.com/repos/dotnet/coreclr/issues/16622,sywhang,0,0,0,4,0,0,fixes issue enable logging inner exception on calls to environment.failfast(bool ex) pasted below is an example inner exception log produced with this fix for this program failfast:oops at system.environment.failfast(system.string system.exception at internal.runtime.augments.environmentaugments.failfast(system.string system.exception at system.environment.failfast(system.string system.exception at program.main()inner exception details:system.argumentexception my ae system.nullreferenceexception my nre at program.d at program.c at program.b end of inner exception stack trace at program.b at program.a at program.main() here is the program used to produce the log above. class program static void main try a catch(exception ex environment.failfast(oops ex static void a b static void b try c catch exception ex throw new argumentexception(my ae ex static void c d static void d throw new nullreferenceexception(my nre i will follow up with another pr to address the duplicate system.environment.failfast(system.string system.exception appearing in the failfast exception stack trace but this pr addresses the more important problem of inner exception details getting dropped from the log
300588162,16621,https://api.github.com/repos/dotnet/coreclr/issues/16621,xoofx,9,0,0,0,0,0,even if we have a struct constraint activator.createinstance
300534951,16619,https://api.github.com/repos/dotnet/coreclr/issues/16619,CarolEidt,2,0,0,0,0,0,currently the jit introduces unnecessary copies when passing structs by value.this impacts both the by-ref passing as in the x windows abi as well as the x unix abi though the impact is worse in the latter case.this is especially problematic for small structs on x unix which are passed in registers but needlessly forced to memory span
300379360,16588,https://api.github.com/repos/dotnet/coreclr/issues/16588,stephentoub,1,0,0,0,0,0,contributes to add tests in corefx separately.cc jkotas gspp
300360185,16577,https://api.github.com/repos/dotnet/coreclr/issues/16577,janvorli,2,0,0,0,0,0,port it was found that we incorrectly try to restore ymm registers in rtlrestorecontextwhen the processor supports xstate but doesnt have ymm registers this changefixes that by testing the ymm presence flag too
300344868,16574,https://api.github.com/repos/dotnet/coreclr/issues/16574,sandreenko,1,0,0,0,0,0,"this phase has an algorithm with quadratic time and we need a separate phase to see its timings,now it goes to allocate objects phase inv/meth mcycles time ms of total max ms create eh funclets optimize layout allocate objects it is a part of"
300248534,16568,https://api.github.com/repos/dotnet/coreclr/issues/16568,CarolEidt,2,0,0,0,0,0,the gt_arr_bounds_check and gt_simd_chk nodes shouldnt need to be separate operators as their semantic differences are captured in the gtthrowkind on the gentreeboundschk node in addition a gt_hw_intrinsic_chk is being added which is also not really needed.it may be that there are some entanglements with existing array bounds check elimination or other code that will need to be sorted before merging these.category:implementationtheme:bounds-checksskill-level:expertcost:medium
299980303,16551,https://api.github.com/repos/dotnet/coreclr/issues/16551,jkotas,1,0,0,0,0,0,fix
299885907,16535,https://api.github.com/repos/dotnet/coreclr/issues/16535,benaadams,0,0,0,0,0,1,cc ahsonkhan tarekgh jkotas
299860011,16532,https://api.github.com/repos/dotnet/coreclr/issues/16532,dagood,1,0,0,0,0,0,this version includes a fix to start unblocking dependency auto-update flow after github stopped allowing weak cryptographic standards yesterday dotnet/core-eng
299573001,16517,https://api.github.com/repos/dotnet/coreclr/issues/16517,CarolEidt,0,0,0,1,0,0,this is the next phase of building refpositions incrementally.the big pictures is that instead of creating treenodeinfo with the register requirements for each node the build methods in linearscan build the refposition s directly putting the defs in a deflist for when the consuming node builds the corresponding uses.there are zero diffs for crossgen of frameworks tests across all the x x altjits arm arm and x/ux aside from a small number of improvements due to some rmw handling changes
299542880,16513,https://api.github.com/repos/dotnet/coreclr/issues/16513,echesakovMSFT,2,0,0,0,0,0,currently when build linux/arm coreclr on linux/x dev machine the following two sets of user environments must be installed x/arm compiler for native build x/x for cross-components used for crossgen/aot to improve performance. purpose adapting crossgen and coreclr to be able to generate bit readytorun images on a bit host without requiring to install x/x linux environment such changes include but not limited to replacing expessions like sizeof(void with target specific macro target_pointer_size prs replacing usages of macro win with target_bit as we do in ryujit prs use emitter::code_t rather than ssize_t and size_t in emitarm.cpp and emitarm.h pr cross-bitness support for ryujit pr modify cmakelists.txt build.sh build.cmd to allow hostarch=x and targetarch=arm replacing sizeof(objheader sizeof(object with target-specific constants pr tbd how we are going to validate the result test that x/arm and x/arm crossgens produce the binary identical images as a short term goal we do this for system.private.corelib.dll @jkotas vitek-karas russkeldorph
299297024,16502,https://api.github.com/repos/dotnet/coreclr/issues/16502,alpencolt,1,0,0,0,0,0,we are applying coreclr for devices with low ram and interesting to reduce applications memory consumption but as you understand such kind of optimizations decrease overall performance usually.so there is idea to make coreclr configuration which enable some jit optimization like jit pitching or disable like inlining which also enable some runtime optimizations which decrease memory consumption.is it possible to merge such configuration to upstream may be do you have already some ideas or proposal for it?@jkotas janvorli bruceforstall cc dmitri-botcharnikov gbalykov kvochko sergign mlabiuk
298383351,16444,https://api.github.com/repos/dotnet/coreclr/issues/16444,mikedn,0,0,0,3,0,0,when loading a typ_simd local field movsd should be used not movups unlike ins_move_extend ins_load does the right thing and its consistent with indirs.no diffs.fixes
298048743,16434,https://api.github.com/repos/dotnet/coreclr/issues/16434,benaadams,1,0,0,0,0,0,"allows string.equals of all forms to inline for the null and ref equality parts.remove case default inline throw as stringspanhelpers.checkstringcomparison already deals with out of rangededuplicate calls to stringspanhelpers.checkstringcomparison and always use it rather than in some if branches so the case default can be removed)add getcasecompareofcomparisonculture that converts stringcomparison to compareoptions with a single when comparison is a culture.dedupe the calls using it.remove the now other duplicated code for equals)resolves consider removing string.isascii fast paths as compareordinalignorecase(readonlyspan,readonlyspan"
297947154,16423,https://api.github.com/repos/dotnet/coreclr/issues/16423,sandreenko,1,0,0,0,0,0,pr stopped sync most folders between tf and git and the comment there says after this is merged i will get tfs and git back in sync there have been changes in superpmi that were made after the stopped syncing that directory and then resume the mirror after thats complete ill clean up the lingering gitmirror files that are no longer needed.but the second part was not done and the lingering gitmirror files are still there.delete them after this change we have gitmirror only in toolbox and jit folders and one gitmirrorselective in the root dir
297442755,16398,https://api.github.com/repos/dotnet/coreclr/issues/16398,kevingosse,3,0,0,0,0,0,not much but it appears in the output of the dumpgcdata sos command
297225775,16392,https://api.github.com/repos/dotnet/coreclr/issues/16392,eerhardt,6,0,0,0,0,0,vectorize string.indexof(char using the same algorithm as spanhelpers.indexof(byte also plan on doing the same for string.lastindexof which is why i marked this as wip i wanted to get early feedback on the approach to ensure continuing this work is worth the effort perf resultsi ran the following tests test code windows desktop click to expand)machine macbook air click to expand)machine lenvo carbon x click to expand)machine tanners q click to expand)as you can see for short strings there is a little degradation especially when the match is towards the beginning of the string but for longer strings where the match is towards the end or doesnt match at all the gains are substantial./cc benaadams
297017133,16382,https://api.github.com/repos/dotnet/coreclr/issues/16382,jkotas,0,0,0,1,0,0,coreclr implementation of this method triggers jiting of the given method only.it does not walk a subset of callgraph to provide cer guarantees because of cersare not supported by coreclr.fixes
297004249,16380,https://api.github.com/repos/dotnet/coreclr/issues/16380,kbaladurin,1,0,0,0,0,0,it allows to remove deallocation in destuctor that can lead to uaf for static historgams objects during shutdown this patch fixes
296939786,16371,https://api.github.com/repos/dotnet/coreclr/issues/16371,pprice,1,0,0,0,0,0,dotnet version csharp float heapfloats float*)marshal.allochglobal(sizeof(float heapfloats f heapfloats f this works float buffer new float buffer heapfloats buffer heapfloats this does not float bufferd new float bufferd heapfloats will exit here bufferd heapfloats will produce: dotnet.exe has exited with code x). native callstack kernelbase.dll!wil::details::debugbreak(void unknown non-user code symbols loaded coreclr.dll!ilcodestream::emitstind_t(localdesc ptype line c symbols loaded coreclr.dll!arrayoplinker::emitstub line c symbols loaded coreclr.dll!generatearrayopstub(arraymethoddesc pmd line c symbols loaded coreclr.dll!methoddesc::doprestub(methodtable pdispatchingmt line c symbols loaded coreclr.dll!prestubworker(transitionblock ptransitionblock methoddesc pmd line c symbols loaded coreclr.dll!theprestub line unknown symbols loaded external code annotated frame coreclr.dll!calldescrworkerinternal line unknown symbols loaded inline frame coreclr.dll!calldescrworkerwithhandler(calldescrdata line c symbols loaded coreclr.dll!methoddesccallsite::calltargetworker(const unsigned int parguments unsigned int preturnvalue int cbreturnvalue line c symbols loaded inline frame coreclr.dll!methoddesccallsite::call(const unsigned int line c symbols loaded coreclr.dll!runmain(methoddesc pfd short piretval int stringargs ptrarray line c symbols loaded. snip notes does not fail on net framework runtime this will only reproduce on debug configuration builds not release this seems to happen to any d array of pointers i tried byte float and long looks like ilcodestream::emitstind_t hits unreachable_msg(unexpected type passed to emitstind_t and raises a check
296822482,16360,https://api.github.com/repos/dotnet/coreclr/issues/16360,AndyAyersMS,1,0,0,0,0,0,we should add a beginphase that sets some state in the compiler instance to track the currently active phase and then rework the whole phase structure to automatically follow a begin do end pattern.this would allow us to do a couple of useful things add the currently active phase name to assert messages this would make triaging asserts a bit easier also we can tell if were in the middle of inlining we should add that information to asserts as well allow for phase-selective jit dumps either a single phase a set of phases or a range of phases allow for phase-selective dump suppression have a consistent pattern in dumps for phase boundariesif we supported a limited stack of active phases we could introduce sub-phases this way as well.category:implementationtheme:jit-coding-styleskill-level:intermediatecost:medium
296778921,16356,https://api.github.com/repos/dotnet/coreclr/issues/16356,vitek-karas,2,0,0,0,0,0,"running the build.cmd script on windows from vs development environment without having git on path fails the build in a really weird way which is hard to figure out.if this happens the error reported is: e:\coreclr\bin\obj\_version.h error rc newline in constant e:\coreclr\bin\obj\windows_nt.x.debug\src\tools\crossgen\crossgen.vcxproj looking into this the version.h has a line like this: #define ver_productversion_str builtby vitkaras-vitkarasd branch git is not recognized as an internal or external command,operable program or batch file. if the build really needs git which in this case it could put some unknown string instead into the version then it should fail up front with a clear error message currently it fails during compilation and keeps on trying to compile and so on"
296564025,16348,https://api.github.com/repos/dotnet/coreclr/issues/16348,tannergooding,1,0,0,0,0,0,currently the emitter has a set of unit tests genamdemitterunittests and genarmemitterunittests which can be used for validating that the emitted byte code is correct for various scenarios.however this does not currently work in coreclr itself due to a dependency on the closed source msvcdis disassembler.given the number of new instructions being supported and the number of general improvements being made to the emitter for the hardware intrinsics feature it would be beneficial to update these tests such that they can be run as part of coreclr.category:correctnesstheme:testingskill-level:intermediatecost:small
296263155,16336,https://api.github.com/repos/dotnet/coreclr/issues/16336,ghost,1,0,0,0,0,0,decimal type is essentially a struct of int as shown here specified byte array to allocate bytes and then call random.nextbytes on the buffer and then de-reference that byte array as decimal this causes the coreclr and microsoft clr to crash without exception being thrown or any console output being shown as to why this crashed. csusing system;using system.componentmodel;using system.runtime.interopservices;namespace randomsnippet class program static void main(string args console.writeline(sizeof(decimal console.writeline(marshal.sizeof
296089618,16320,https://api.github.com/repos/dotnet/coreclr/issues/16320,AndyAyersMS,0,0,0,1,0,0,may help users find workarounds for cases where the jits hit somekind of implementation limit as in or
296061456,16318,https://api.github.com/repos/dotnet/coreclr/issues/16318,kouvel,1,0,0,0,0,0,port of a portion of to release/..fixes divide by pointer size was removed to produce the proper offset
295488374,16277,https://api.github.com/repos/dotnet/coreclr/issues/16277,kkokosa,1,0,0,0,0,0,due to changes in c and span more and more stackalloc usages may become popular like: span(&pthread uint_ptr limit reinterpret_cast(pthread->getcachedstacklimit fc_return_bool(current limit size));}fcimplend ps i am not sure whether stack guard size should be taken into consideration here or not
295354671,16268,https://api.github.com/repos/dotnet/coreclr/issues/16268,CarolEidt,2,0,0,0,0,0,if we have a block copy from an enregisterable struct today thats just simd to a different type target it needs to be marked as address-taken because the destination type is whats used for the copy and all non-enregisterable destination types expect their source in memory.fix
295333663,16266,https://api.github.com/repos/dotnet/coreclr/issues/16266,benaadams,6,0,0,0,0,0,proposal csharp methodimpl(methodimploptions.nonsharedgeneric if you had for example ifeaturecollection.get(tfeature instance
295208911,16253,https://api.github.com/repos/dotnet/coreclr/issues/16253,mmitche,1,0,0,0,0,0,fix two errors remove unneeded signed symbol catalog injection build definition is not importing becuase of duplicated task name
294878361,16239,https://api.github.com/repos/dotnet/coreclr/issues/16239,AndyAyersMS,4,0,0,0,0,0,add test case showing that in constructors the exact type of this is not generally known to devirtualize we need to rely on type propagation from the newobj .related discussion in
294591735,16220,https://api.github.com/repos/dotnet/coreclr/issues/16220,AndyAyersMS,6,0,0,0,0,0,enable struct promotion in methods where the jit is also emtting a stack guard.not allowing promotion seems like an unnecessary limitation and leads to poorperformance in methods with both span and stackalloc.closes
294525525,16215,https://api.github.com/repos/dotnet/coreclr/issues/16215,AndyAyersMS,0,0,0,0,0,1,in methods with stack security checks we should modify the epilog codegen so the rare throw path requires the taken branch also when there are multiple return points it would be nice to have just one throw helper sequence instead of one per return.current codegen is something like: asm lea rcx reloc mov rcx qword ptr rcx cmp qword ptr rbp rcx je short g_m_ig call corinfo_help_fail_fastg_m_ig nop g_m_ig lea rsp rbp+ah pop rbx pop rsi pop rdi pop r pop r pop r pop r pop rbp ret category:cqtheme:basic-cqskill-level:intermediatecost:medium
294522238,16214,https://api.github.com/repos/dotnet/coreclr/issues/16214,jkotas,2,0,0,0,0,0,prep-work for moving string.manipulation.cs to shared partition avoiding manually managed code overhead makes it quite a bit faster as well in some cases for example: hello.replace(a b x faster hello.replace(e a x faster x a.replace(a b x faster
294208017,16197,https://api.github.com/repos/dotnet/coreclr/issues/16197,alexandrnikitin,4,0,0,0,0,0,"ive been playing with span feature and notice that its performance is relatively slower and the generated assembly code looks bulky im comparing an array on heap new int unsafe stack allocated array stackalloc int stack allocated span span(buffer the code can be found here stack allocated span is almost times slower than unsafe stack allocated array i have net core preview but also tried x with system.memory package from myget you can find the repro code is in this repository my question is what am i doing wrong or these results are expected?the results i get inibenchmarkdotnet=v os=windows redstone fall creators update intel core i-u cpu ghz haswell cpu logical cores and physical coresfrequency hz resolution ns timer=tsc.net core sdk=..-preview host net core preview framework bit ryujit core net core preview framework bit ryujitjob=core runtime=core method mean error stddev scaled arraybenchmark ns ns ns unsafebenchmark ns ns ns spanbenchmark ns ns ns spanunsafebenchmark ns ns ns the assembly code span generates: asmffc feeaf spantest.spanbenchmarks.spanbenchmark span x stackalloc int ffc feeb b mov eax,ffc feeb a push ffc feeb a push ffc feebb ffc dec raxffc feebe f jne ffc feebffc feeb d lea rax, rsp ffc feeb mov qword ptr rbp+h ,rspffc feeb d xor edx,edxffc feeba mov qword ptr rbp+h ,rdxffc feebe mov qword ptr rbp+h ,raxffc feeb b mov rax,qword ptr rbp+h ffc feeb d lea rdx, rbp+h ffc feeba mov qword ptr rdx ,raxffc feebd c mov dword ptr rbp+h ,h var sum ffc feeb ceaf vmovdqu xmm,xmmword ptr rbp+h ffc feeba ceaf vmovdqu xmmword ptr rbp+h ,xmmffc feeb c xor eax,eax for int i i x.length i ffc feeb d xor edx,edxffc feeb bd mov ecx,dword ptr rbp+h ffc feeb c test ecx,ecxffc feeb e jle ffc feebc sum x i ffc feebb cb mov r,qword ptr rbp+h ffc feebf cca movsxd r,edxffc feeb add eax,dword ptr r+r for int i i x.length i ffc feeb ffc inc edxffc feeb bd cmp edx,ecxffc feeba cef jl ffc feebb return sum ffc feebc bcfccdf mov rcx,fcdfcch compared to unsafe stack allocation: asmffc feaeb spantest.spanbenchmarks.unsafebenchmark int x stackalloc int ffc feaeb b mov eax,ffc feaeb a push ffc feaebb a push ffc feaebd ffc dec raxffc feaeb f jne ffc feaebffc feaeb d lea rax, rsp ffc feaeb mov qword ptr rbp+ ,rsp var sum ffc feaeba d xor edx,edx for int i i i ffc feaebc c xor ecx,ecx sum x i ffc feaebe cc movsxd r,ecxffc feaeb add edx,dword ptr rax+r for int i i i ffc feaeb ffc inc ecx for int i i i ffc feaeb f cmp ecx,hffc feaeba cf jl ffc feaebe return sum ffc feaebc bc mov eax,edx"
293892306,16175,https://api.github.com/repos/dotnet/coreclr/issues/16175,ayende,2,0,0,0,0,0,for performance reasons it is very common to use thread local values under load the thread pool might be spawning new threads and running requests on them.that will cause our code to allocate some resources for this.after the load it over the thread pool will start reducing the number of active threads but we have to rely on the gc to clean up such resources usually by relying on the gc collecting the thread static values and then running the finalizers.our code is structured so well have very little gc runs hence the need to do thread local stuff and it can take a long time for the gc to actually get around to cleaning these.ideally i would like to have threadpool.currentthreadpoolthreadclosing event that would be called as one of the last stages of closing a thread pool thread allow us to proactively cleanup any manged unamanged resources for that thread early on.for that matter the corollary for that threadpool.currentthreadpoolthreadstarting might also be useful because we can do the initialization of state there and save up on checks but that is of far less importance i think
293639098,16156,https://api.github.com/repos/dotnet/coreclr/issues/16156,mikedn,0,0,0,0,0,3,to set some expectations this is primarily opened for testing and discussion it may turn that it does not work or its too expensive or whatever
293364616,16140,https://api.github.com/repos/dotnet/coreclr/issues/16140,tannergooding,1,0,0,0,0,0,this should resolve the other issues in caroleidt fiigii
293361868,16138,https://api.github.com/repos/dotnet/coreclr/issues/16138,GrabYourPitchforks,10,0,2,0,0,1,the current implementation of convert.toint(bool uses branching to return or to its caller making it prone to branch mispredictions this pr makes the implementation branchless in my win x testbed application this results in a increase in tps for calls to this routine when the input values are random before ms for mm calls after ms for mm calls.)this might seem esoteric but it matters because it can be used as a springboard to help developers write their own high-performance branchless routines for example the statement int skiplastchunk isfinalblock in the base decoder routine can utilize this to become branchless by being rewritten as int skiplastchunk convert.toint(isfinalblock disassembly of convert.toint(bool before the change amd): asm assume rb contains value and edi will receive the result test rd rd jne if_trueif_false xor rd rd jmp finishedif_true mov rd finished mov edi rd disassembly after the change: asm test rd rd setne dil movzx edi dil for non-random values e.g all test inputs are already true or false the modified code performs of the original code i dont see a real difference above the normal noise.open issue you can eke out even higher performance if youre willing to forego the normalization logic i didnt want to risk changing the existing convert.toint(bool behavior where its guaranteed to return or
293300015,16133,https://api.github.com/repos/dotnet/coreclr/issues/16133,eerhardt,1,0,0,0,0,0,this requires the runtime to change to recognize the vector classes in either system.numerics.vectors.dll or in system.private.corelib.dll to do this i added the intrinsic attribute to vector
293119334,16122,https://api.github.com/repos/dotnet/coreclr/issues/16122,hmanner,1,0,0,0,0,0,it looks like the threadabortexception is not always re-thrown by the runtime see below for a sample program that reproduces the issue causing an infinite thread loop.i have reproduced this on two bit systems running net framework and respectively.i can not reproduce on net framework the issue goes away if forcing usage of the legacy jit compiler with the following config runtime uselegacyjit enabled runtime> i have reproduced with the following program built using visual studio enterprise version targeting net framework any cpu release build: using system;using system.threading;namespace consoleapp class program static bool started false static void main(string args start thread var thread new thread(threadloop thread.start while started abort thread console.writeline($aborting thread thread.abort private static void threadloop console.writeline($thread started int cnt while true try if started console.writeline($thread loop started true catch threadabortexception console.writeline($threadabortexception cnt the output when reproducing: thread startedthread loopaborting threadthreadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception threadabortexception continuing forever) i am aware of issue but it does not sound like the exact same issue.any thoughts on this
292802621,16097,https://api.github.com/repos/dotnet/coreclr/issues/16097,sdmaclea,1,0,0,0,0,0,start sharing hwintrinsic code.@tannergooding caroleidt fiigii ptal
292657052,16095,https://api.github.com/repos/dotnet/coreclr/issues/16095,tannergooding,1,0,0,0,0,0,fyi fiigii caroleidt mikedn
292635884,16092,https://api.github.com/repos/dotnet/coreclr/issues/16092,CarolEidt,1,0,0,0,0,0,move code for building refposition s and interval s out of lsra.cpp into lsrabuild.cpp also move common code from lsraarm*.cpp and lsraxarch.cpp to lsrabuild.cpp.maintain the listnodepool on the linearscan object to be used by all the building methods.rename treenodeinfoinit methods to build to more accurately reflect the next round of changes where they will build the refposition s directly
292621177,16089,https://api.github.com/repos/dotnet/coreclr/issues/16089,kouvel,0,0,0,1,0,0,fixes
292606859,16088,https://api.github.com/repos/dotnet/coreclr/issues/16088,tannergooding,2,0,0,0,0,0,updated the hardware intrinsic nodes to never be optimized away under the general assumption that users will be hand optimizing their code.however in some cases such as when inlining or when constant parameters are passed it may still be beneficial to optimize away any dead or unreached code.we should update the hwintrinsic nodes to properly set and track the sideeffecting flag.category:cqtheme:intrinsicsskill-level:intermediatecost:small
292490421,16079,https://api.github.com/repos/dotnet/coreclr/issues/16079,AndyAyersMS,2,0,0,0,0,0,see discussion in dotnet/corefx#. c#using system;using system.runtime.compilerservices;public class program private static int array new int static program public static void main(string args int index movenext(ref index movenext(ref index methodimpl(methodimploptions.noinlining private static void movenext(ref int index int tmp index index tmp array.length tmp methodimpl(methodimploptions.noinlining private static void movenext(ref int index int tmp index if tmp array.length tmp index tmp the code for movenext contains the following branch-around branch sequence: asm cmp dword ptr rcx eax je short g_m_ig eb jmp short g_m_igg_m_ig c xor eax eaxg_m_ig mov dword ptr rdx eax category:cqtheme:flowgraphskill-level:expertcost:small
292250045,16066,https://api.github.com/repos/dotnet/coreclr/issues/16066,tannergooding,3,0,0,0,0,0,this may get removed by whatever direction we decide to track these nodes longterm such as making them indir nodes getting a full isa marked as fullyimplemented means that people can start using it in more realistic code which will allow us to get some basic benchmarks and usage scenarios covered
292184622,16058,https://api.github.com/repos/dotnet/coreclr/issues/16058,mikedn,2,0,0,0,0,0,replace typedreference with unsafe.as it generates far less code and with the help of aggresiveinlining it allows exchange
291768217,16027,https://api.github.com/repos/dotnet/coreclr/issues/16027,sandreenko,0,0,0,3,0,0,there are unsafe renames gentreeptr a b gentree a b it is fixed in the first commit const gentreeptr const gentree it is fixed in the second commit.it requires some additional work to delete constgentreeptr until that it is wip
291400903,16005,https://api.github.com/repos/dotnet/coreclr/issues/16005,CarolEidt,1,0,0,0,0,0,the specific failure in was due to a problem with the avx encoding of the pinsrw instruction that was exposed when avx is enabled but avx is not the code generator generates the sse operand form but this is an instruction that needs to be encoded with the dst duplicated when using avx encodings so it needs to be added to isdstdstsrcavxinstruction() .investigating this and adding additional test coverage revealed that conversions to unsigned were not implemented correctly for out-of-range values and providing the same behavior as scalar conversion is complex and costly with unknown benefit as this is not expected to be a common scenario so dont recognize these as intrinsics revert to the il implementation).also fix the test to cover more cases.fix
291322693,16000,https://api.github.com/repos/dotnet/coreclr/issues/16000,swgillespie,0,0,0,0,0,1,this pr implements the defining and firing dynamic events portion of the standalone gc eventing spec defining eventsunder this scheme a new dynamic event can be added by adding a macro describing it to src\gc\gcevents.h for example this macro invocation defines a new dynamic event gcmynewdynamicevent has a level of verbose has the single keyword gc and has a payload consisting of two uint_t s: c++dynamic_event(gcevent gceventlevel_verbose gceventkeyword_gc uint_t uint_t) the general syntax for dynamic_event is dynamic_event() where arguments are zero or more types that form the payload of the dynamic event dynamic events are always associated with the default etw provider and not the private one.under the hood the definition macro invocation results in two functions being generated inthe above example these two functions are generated: c++inline bool gceventenabledgcevent return gceventstatus::isenabled(gceventprovider_default gceventkeyword_gc gceventlevel_verbose);}templateinline void gceventfiregcevent(eventactualarguments arguments firedynamicevent(gcevent arguments...);} firedynamicevent is a helper templated method that serializes the event payload into a binary format and sends the binary payload across the gc/ee interface via igctoclreventsink::firedynamicevent where the event is handed off to the platform logger(s firedynamicevent is a variadic template whose template arguments are the types of the event payload specified in the declaration and whose actual arguments are the values that will form the payload of the event firing eventsthe above two auto-generated functions allow us to hide the template complexity between the two macros used in event_enabled and fire_event .for example the following code would check if the above dynamic event is enabled and if it is fires the event: c++if event_enabled(gcevent fire_event(gcevent note that this exactly the syntax for firing a known event at the call site there is no distinction between a known event and a dynamic one.on the ee side of the gc/ee interface the ee defines a single event for dynamic events called gcdynamicevent whose level is logalways and whose keyword consists of all keywords that are used by the gc to fire events this ensures that the gcdynamicevent will always be enabled on the underlying etw provider if there ever is a dynamic event that is enabled.this is an example etw payload that i received when testing this feature with the above dynamic event: (note that perfview which produced this event dump is not aware what this event is because i havent installed the manifest that i built the payload is the most interesting part of this snippet serializing event payloadspayload serialization is driven by the eventserializationtraits in src\gc\gcevent_serializers.h it should be implemented for all types that will be serialized as event payloads this pr provides only one such implementation for uint_t but new implementations can be added as they are needed for new dynamic events.the serialization scheme is extremely simple and doesnt preclude more sophisticated serialization schemes in the future the provided implementation of eventserializationtraits for uint_t serializes a uint_t as a four-byte little-endian integer but the code in this file is not opinionated at all about how things are serialized
291315199,15998,https://api.github.com/repos/dotnet/coreclr/issues/15998,cemeyer,0,0,0,1,0,0,"move src/pal/inc/rt include from global cmakelists to src to avoidinclude conflict in test code foreignthreadexceptionsnative.cpp thread functional memory cassert pal rt assert.h).update build instructions to include needed components ninja,lttng-ust python).change int_t definition to be explicitly signed to match freebsdincludes.add missing elfw definition when libunwind does not define it.freebsd alloca is defined in stdlib.h so include that instead ofalloca.h on freebsd"
290970995,15983,https://api.github.com/repos/dotnet/coreclr/issues/15983,sandreenko,2,0,0,1,0,0,based on discussion in we want to delete gentreeptr and other ptr types.because they are inconsistent they confuse intellisense so if you have a function declaration with gentreeptr and the imdlementation is declared with gentree it wont allow you to go to definition/declaration e.g compiler.h: bool gthasref(gentree tree ssize_t lclnum bool defonly); compiler.cpp: bool compiler::gthasref(gentreeptr tree ssize_t lclnum bool defonly vs doesnt see this implementation.this pr deletes all ptr types except gentreeptr
290247040,15954,https://api.github.com/repos/dotnet/coreclr/issues/15954,jkotas,5,0,0,0,0,0,empty program executes about managed methods today in release build initialization of arraypool logging arraypooleventsource is responsible for of them when the arraypool initialization is commented out i am back to about where we used to to be historically.is the arraypool logging valueable enough to contribute this much to startup cost of empty program can we make it cheaper or not have it
290160059,15947,https://api.github.com/repos/dotnet/coreclr/issues/15947,GrabYourPitchforks,0,0,0,0,0,3,see for perf measurements.there are four specific optimizations being considered here tweak the flow graph of trycopyto e.g single return statement to encourage code gen to inline the method remove the fixed statement from the copyto core implementation in order to avoid the overhead of setting up pinned locals on the stack this also allows code gen to perform a tail call rather than a standard call into the core memmove implementation accept nuint as a parameter to the copyto core implementation to take advantage of trycopyto being inlined allowing code gen to be more efficient with how it emits mov movsxd instructions create a ref-based memmove implementation which is a sister to the pointer-based implementation right now only span calls into this but presumably other types like array could be changed to do so.the perf measurements in show how some of these interplay with each other for example the test case which copies a span
290147140,15944,https://api.github.com/repos/dotnet/coreclr/issues/15944,BruceForstall,0,0,0,1,0,0,"if the user doesnt specify a specific corefx commit hash to use in run-corefx-tests.py,try to find the matching commit hash in the coreclr repro if thematching hash cant be found use head.we find the matching corefx commit hash by first parsing filedependencies.props at the root of the coreclr repro looking for this microsoftprivatecorefxnetcoreapppackageversion>..-preview-- this determines the corefx package version that matches next we look for the version.txtfile in the package cache e.g coreclr_root>\packages\microsoft.private.corefx.netcoreapp\..-preview--\version.txt the contents of this file is exactly the git commit hashwe need to use e.g abeaafddfdbcc the version.txt file is created when the corefx package is restored,which happens when doing one of windows tests\runtests.cmd generatelayoutonly non-windows build-test.sh generatelayoutonlyit would also be possible to not depend on the package alreadybeing downloaded but instead download the correct package here,using the determined microsoftprivatecorefxnetcoreapppackageversionpackage version e.g then extracting the zip archive to find the version.txt file.this might get easier if the corefx commit hash is added directly to dependencies.props asdiscussed in ci to build a generatelayoutonly drop for corefx testing,specifically to cause the corefx package to be restored so wecan determine its version"
289816707,15922,https://api.github.com/repos/dotnet/coreclr/issues/15922,fiigii,2,0,0,0,0,0,to avoid the conditional compile flag if corert when using hardware intrinsics in mscorlib/corefx we can move hardware intrinsic definition from coreclr/src/mscorlib/src to coreclr/src/mscorlib/shared net native just needs to build with xxx.platformnotsupported.cs files so that issupported would always return false before corert compilers support hardware intrinsics.logging the discussion to jkotas caroleidt benaadams eerhardt tannergooding sdmaclea
289460840,15908,https://api.github.com/repos/dotnet/coreclr/issues/15908,tannergooding,1,0,0,0,0,0,currently the emitter has support for emitting byte avx instructions throughout most of the emitoutput code paths in the emitter.however the support for emitting byte sse instructions only exists in a couple of the emitoutput code paths and requires non-trivial work to enable elsewhere.we should plumb the rest of this support through the emitter in order to enable several of the byte sse and sse intrinsics on machines which dont support the vex encoding non-avx machines).this will also allow the math.round math.ceiling and math.floor intrinsics to be enabled for these architectures as well
289254021,15898,https://api.github.com/repos/dotnet/coreclr/issues/15898,MichalStrehovsky,0,0,1,0,0,0,this file is the poster child of a class that is runtime specific
289119631,15896,https://api.github.com/repos/dotnet/coreclr/issues/15896,tarekgh,1,0,0,0,0,0,from wstaelens on january not sure if this is normal or not tested in a solution with net and in visual studio c interactive window var a datetime.utcnow.tostring(ffffhhmmyytssddmm datetime ts bool test datetime.tryparseexact(a ffffhhmmyytssddmm null system.globalization.datetimestyles.none out ts);index was outside the bounds of the array system.datetimeparse.matchabbreviatedtimemark(ref system.__dtstring system.globalization.datetimeformatinfo ref system.datetimeparse.tm system.datetimeparse.parsebyformat(ref system.__dtstring ref system.__dtstring ref system.parsinginfo system.globalization.datetimeformatinfo ref system.datetimeresult system.datetimeparse.dostrictparse(string string system.globalization.datetimestyles system.globalization.datetimeformatinfo ref system.datetimeresult system.datetimeparse.tryparseexact(string string system.globalization.datetimeformatinfo system.globalization.datetimestyles out system.datetime copied from original issue microsoft/dotnet
288442733,15858,https://api.github.com/repos/dotnet/coreclr/issues/15858,4creators,1,0,0,0,0,0,fixes this pr updates clr-configuration-knobs.md documentation file with current data from clrconfigvalues.hand jitconfigvalues.h files new script has been written in c and can be run xplat with support of csi c scripting was chosen due to the following reasons wanted to test how effective is c at typical scripting task in comparison to bash and m tried to apply general dogfooding principle starting with non critical part of repo wanted to remove dependency on m in documentation scripts hoped to gain some insights into strengths and weaknesses of c csi based scriptingit seems that with current state of csi scripting more complex regex matching i.e paretheses stack)is very inefficient at least times slower than simple string search therefore it was not usedin this pr except for c string literal matching.to unify documentation there have been some editorial changes introduced into c++clrconfigvalues.h and jitconfigvalues.h files removed duplicated in clrconfigvalues.h config declarations from jitconfigvalues.h consistent formatting of knobs category names located in comments as well as comment formatstarting with instead of for ease of parsing upper cased all first letters in all knobs descriptions and moved question marks at the end putting them inside parentheses minor white space fixes in clrconfigvalues.hknobs are now presented in tables splitted into categories in alphabetical order thissignificantly improves searching and reading.there are some problematic knobs which i hope to fix during code review
288159169,15841,https://api.github.com/repos/dotnet/coreclr/issues/15841,adamsitnik,3,0,0,0,0,0,yesterday i had to go through using your build instructions they were quite good but slightly outdated i decided to update them so the onboarding will be easier for others.the key things are create your own nuget.config file which points to the right folder. xmlexenetcoreapp.win-x..-preview-- this fixes cc jkotas
287989970,15836,https://api.github.com/repos/dotnet/coreclr/issues/15836,tannergooding,1,0,0,0,0,0,resolves
287937081,15829,https://api.github.com/repos/dotnet/coreclr/issues/15829,tannergooding,1,0,0,0,0,0,emitinsbinary currently duplicates a lot of checks is hard to follow and could overall use a good refactoring.an example of this duplication is how it does a iscontained check times for src and times for dst in the first lines of the method it also does a isusedfromspilltemp check times for src and times for dst .it also splits the analysis for a particular node type out into multiple places in the method rather than keeping it contained and ends up doing checks even when a previous check may have invalidated the latter from being possible
287929552,15828,https://api.github.com/repos/dotnet/coreclr/issues/15828,tannergooding,1,0,0,0,0,0,currently we have several emitins methods to support the various address modes we emit.these include emitins_r_ar(instruction ins emitattr attr regnumber ireg regnumber base int disp emitins_r_ai(instruction ins emitattr attr regnumber ireg ssize_t disp emitins_r_arr(instruction ins emitattr attr regnumber ireg regnumber base regnumber index int disp emitins_r_arx(instruction ins emitattr attr regnumber ireg regnumber base regnumber index unsigned mul int disp emitins_r_ax(instruction ins emitattr attr regnumber ireg regnumber reg unsigned mul int disp) in most cases these are all doing the same thing and the difference is the parameters that are passed in basereg/base indxreg/index scale/mul and offs/disp).these values are general pulled from an indir node which correctly sets the defaults on these when unused reg reg_na scale offs it may be useful and would allow us to simplify some other code if we combined these into a single emitins_r_a method and relied on the correct defaults being set when they are unused adding in asserts to ensure that they are correct of course emitins_r_a(instruction ins emitattr attr regnumber reg regnumber basereg regnumber indxreg size_t scale ssize_t offs) there are some others in the form of emitins_a*_r that could probably also be combined into a single emitins_a_r methodcategory:implementationtheme:emitterskill-level:intermediatecost:medium
287651277,15823,https://api.github.com/repos/dotnet/coreclr/issues/15823,benaadams,9,0,0,0,0,0,resolves
287495159,15809,https://api.github.com/repos/dotnet/coreclr/issues/15809,kbaladurin,1,0,0,0,0,0,improve collected delegate calls diagnostic improve umentrythunkcode::poison to produce diagnostic message store freed thunks into fifo free list in this case it takes longer before the thunks get reusedexample corerun delegategc.dllpress esc to stopregister_callback:xfafac force gc!!!upcall failfast a callback was made on a garbage collected delegate of type delegategc!delegategc.program+callback::invoke at delegategc.program.upcall at delegategc.program.upcall at delegategc.program.myview_keyevent(system.consolekeyinfo at delegategc.program.main(system.string )aborted core dumped
286903624,15783,https://api.github.com/repos/dotnet/coreclr/issues/15783,AndyAyersMS,1,0,0,0,0,0,some notes from discussion in in compound call expressions like: a().b(c()); where b is virtual and a is inlined we may well end up generating two spill temps for a one to hold the result of a while c is invoked and another as a return spill temp for a this can block type propagation from a to the virtual call site and so block devirtualization pre-inlinetmp call acall ccallvirt tmp post-inlinetmp tmp may have improved typetmp tmp tmp will have as declared return typecall ccallvirt tmp; it seems plausible that when attempting to inline a and seeing that it needs a return spill temp the jit could try and reuse the existing stack spill temp instead of creating a new temp.category:cqtheme:importerskill-level:expertcost:medium
286655269,15781,https://api.github.com/repos/dotnet/coreclr/issues/15781,benaadams,0,0,0,2,0,0,switch off edi boundary for asyncremoves end of stack trace from previous location where exception was thrown resolves
286645666,15780,https://api.github.com/repos/dotnet/coreclr/issues/15780,jkotas,2,0,0,0,0,0,from nicolasdorier on august using netcore win it seems the throw keyworusing the throw keyword loose all the initial stacktrace information you can workaround with exceptiondispatchinfo.capture(ex).throw but this seems like a bug to me. using system;namespace consoleapp class program static void main(string args try dostuff catch(exception ex console.writeline(ex.stacktrace private static void dostuff try throw new exception(boom catch(exception ex throw actual output exception line at consoleapp.program.dostuff in c:\users\nicolasdorier\documents\visual studio projects\consoleapp\consoleapp\program.cs:line at consoleapp.program.main(string args in c:\users\nicolasdorier\documents\visual studio projects\consoleapp\consoleapp\program.cs:line expected output exception line at consoleapp.program.dostuff in c:\users\nicolasdorier\documents\visual studio projects\consoleapp\consoleapp\program.cs:line at consoleapp.program.main(string args in c:\users\nicolasdorier\documents\visual studio projects\consoleapp\consoleapp\program.cs:line workaround using exceptiondispatchinfo.capture(ex).throw(); : using system;using system.runtime.exceptionservices;namespace consoleapp class program static void main(string args try dostuff catch(exception ex console.writeline(ex.stacktrace private static void dostuff try throw new exception(boom catch(exception ex exceptiondispatchinfo.capture(ex).throw throw copied from original issue dotnet/corefx
286638548,15779,https://api.github.com/repos/dotnet/coreclr/issues/15779,benaadams,3,0,0,0,0,0,using async and exceptiondispatchinfo in other areas ends up outputting lots of lines that are end of stack trace from previous location where exception was thrown i do get that its technically correct as it is where the exception was saved and restored so a stitch point just not sure what benefit it imparts to a user looking at the stack trace.example system.exception exception of type system.exception was thrown at executioncontexttest.program.d__.movenext end of stack trace from previous location where exception was thrown at executioncontexttest.program.d__.movenext end of stack trace from previous location where exception was thrown at executioncontexttest.program.d__.movenext end of stack trace from previous location where exception was thrown at executioncontexttest.program.d__.movenext end of stack trace from previous location where exception was thrown at executioncontexttest.program.d__.movenext() im not sure the benefit this has over resolving async aside system.exception exception of type system.exception was thrown at executioncontexttest.program.d__.movenext at executioncontexttest.program.d__.movenext at executioncontexttest.program.d__.movenext at executioncontexttest.program.d__.movenext at executioncontexttest.program.d__.movenext() for async the traces could be prefix if it is an async method as its known while resolving the async method for clues:example system.exception exception of type system.exception was thrown at async executioncontexttest.program.d__.movenext at async executioncontexttest.program.d__.movenext at async executioncontexttest.program.d__.movenext at async executioncontexttest.program.d__.movenext at async executioncontexttest.program.d__.movenext() and with resolving async that could becomeexample at async executioncontexttest.program.exceptiontrace(int)+movenext at async executioncontexttest.program.exceptiontrace(int)+movenext at async executioncontexttest.program.exceptiontrace(int)+movenext at async executioncontexttest.program.exceptiontrace(int)+movenext at async executioncontexttest.program.main(string )+movenext() if it only output indicating when an async method was actually suspended and resumed it would be more of an interesting marker but thats not what it currently does.does it currently provide benefits thoughts? aside xunit removes its own stacks but leaves in the edi lines so you end up with at system.io.compression.compressionstreamunittestbase.d__.movenext in d:\j\workspace\windows-tgrou---fac\src\common\tests\system\io\compression\compressionstreamunittestbase.cs:line end of stack trace from previous location where exception was thrown end of stack trace from previous location where exception was thrown end of stack trace from previous location where exception was thrown cc stephentoub tmat noahfalk aelij jkotas danmosemsft
286447812,15766,https://api.github.com/repos/dotnet/coreclr/issues/15766,AndyAyersMS,0,0,0,2,0,1,if the jit sees that an inlinee has multiple return sites or has gc ref localsit will choose to return the inline result via a temp the jit was not assigninga type to that temp and so losing track of some type information.so for inlinees returning ref types initially type the return spill temp withthe declared return type of the method.when importing we may discover that particular return sites will return morespecific types if all discovered return sites agree we can update the returntype for the spill temp to match the consensus improved type.this can lead to removal of some type checks and also to devirtualization.addresses issues discussed in and
286369826,15755,https://api.github.com/repos/dotnet/coreclr/issues/15755,jkotas,5,0,0,0,0,0,from hmm i wonder if there are sufficient guarantees that by ref like types only live on the stack for the jit to be able to eliminate gc write barriers when writing to fields of such types yes there are it would be nice optimization to have.cc mikedncategory:cqtheme:barriersskill-level:expertcost:small
286104760,15731,https://api.github.com/repos/dotnet/coreclr/issues/15731,GrabYourPitchforks,1,0,0,0,0,0,when writing to a span
286082295,15723,https://api.github.com/repos/dotnet/coreclr/issues/15723,GrabYourPitchforks,3,0,0,0,0,0,currently the jitter is smart enough to elide bounds checks when forward-iterating over arrays or spans as in the below sample. csharpbyte array;for int i i array.length i consume array i } it would help certain tight loops if the jitter could also recognize the reverse-iteration pattern and elide the bounds checks in that scenario as well. csharpbyte array;for int i array.length i or any non-negative const i consume array i } this optimization would save a cmp and jae instruction in these tight loops and in certain cases it would also allow omitting the stack frame setup that normally accompanies methods that might throw exceptions category:cqtheme:bounds-checksskill-level:expertcost:medium
285868741,15716,https://api.github.com/repos/dotnet/coreclr/issues/15716,CarolEidt,1,0,0,0,0,0,when building refposition s in the treenodeinfoinit methods it is very complex and messy to have the setting of the debug-only minregcandidatecount spread all over instead set them for all the refposition s for a given node after they have been created.this required the ability to create an iterator marking the end of the list prior to creating the new ones.in the process eliminated the use of auto from lsra.cpp in the interest of strong typing as well as avoiding the confusion of having things with refposition in their name that are actually iterators
285600846,15694,https://api.github.com/repos/dotnet/coreclr/issues/15694,tannergooding,0,0,0,0,0,1,"rationalecurrently vectorview and there should be a property for each supported value of t i.e float double byte short int long sbyte ushort uint and ulong ).ex vectordebugview would have public byte byteview get public float singleview get etc notesin doing a prototype for this proposal i found that the debugger would always see as the value of the underlying struct i initially attempted to add serialization support but that did not resolve the issue however adding private fields to the structs allowed it to work im guessing the debugger is marshalling the type or something similar).ex i had to change vector)) debuggerdisplay({debuggerdisplay,nq}) public struct vector"
285503134,15685,https://api.github.com/repos/dotnet/coreclr/issues/15685,benaadams,3,0,0,0,0,0,changes asm ebfaf call corinfo_help_getshared_gcstatic_base b mov rbx gword ptr rax dfff lea ecx rdi ce shr ecx d xor edx edx fffff cmp ecx xffff jbe short g_m_ig ce shr ecx ba mov edx g_m_ig fff cmp ecx jbe short g_m_ig ce shr ecx c add edx g_m_ig ff cmp ecx jbe short g_m_ig ce shr ecx c add edx g_m_ig f cmp ecx jbe short g_m_ig ce shr ecx c add edx g_m_ig f cmp ecx jbe short g_m_ig de shr ecx ffc inc edxg_m_ig dca lea ebp rdx+rcx be mov rcx gword ptr rsi b mov rd dword ptr rcx+ to: asm ebfaf call corinfo_help_getshared_gcstatic_base b mov rbx gword ptr rax dfff lea ecx rdi ce shr ecx ffbdc lzcnt ecx ecx fd neg ecx df lea ebp rcx be mov rcx gword ptr rsi b mov rd dword ptr rcx+ /cc fiigii
285353255,15680,https://api.github.com/repos/dotnet/coreclr/issues/15680,benaadams,5,0,0,0,0,0,pinnedbuffermemorystream drop allocation for zero length array ansicharmarshaler converttomanaged use stackallocd span
285244088,15675,https://api.github.com/repos/dotnet/coreclr/issues/15675,benaadams,1,0,0,0,0,0,currently net initiated blocking wait can be detected either using synchronizationcontext and/or tpletw for tasks.however blocking that happens as a result of sys calls cannot be easily detected thread.sleep sync i/o file.read blocking sockets )on windows you need to listen to the kernel cswitch etw events however this requires elevated privileges and only a single listener can be listening per system rather than per process listening to its own events also it makes it more difficult to pull a stacktrace compared to an eventsource based approach.adding an eventsource for blocking calls would assist in detecting them and also be cross platform./cc stephentoub vancem
285157041,15670,https://api.github.com/repos/dotnet/coreclr/issues/15670,tannergooding,1,0,0,0,0,0,currently build.cmd will build the product build the tests and create core_root directory for running the tests.there exists a switch for building just the product and a switch for building tests and creating the core_root directory but i cannot find a switch which will create the core_root directory without building the tests as well.i propose such a switch should be added this would help cut down the inner loop time for the scenario where you are iterating on the product and have already built all the tests which can still take a significant time for the up-to-date check given the sheer number
285061050,15666,https://api.github.com/repos/dotnet/coreclr/issues/15666,mikedn,3,0,0,0,0,0,gt_box doesnt do anything so it should just get the vn of its sole operand this allows assertion prop to see that the result of box is not null since the box operand is the result of an object allocation which is never null
284070182,15617,https://api.github.com/repos/dotnet/coreclr/issues/15617,tannergooding,1,0,0,0,0,0,as per the title this splits the existing tests into isa specific tests.this makes it easier to determine what instructions have coverage and the coverage actually provided for said instruction
283406792,15582,https://api.github.com/repos/dotnet/coreclr/issues/15582,fiigii,3,0,0,0,0,0,this pr implements multiply intrinsics of avx/avx/sse
283055554,15572,https://api.github.com/repos/dotnet/coreclr/issues/15572,ChadNedzlek,2,0,0,0,0,0,its very unexpected from a callers perspective to call a method like c#public static void dostuff(memory.empty which will lead to the expected callstack or if the dostuff method can actually handle null then the expected behavior
282596782,15551,https://api.github.com/repos/dotnet/coreclr/issues/15551,sdmaclea,1,0,0,0,0,0,it would be nice to keep hwintrinsic tests in platform/namespace specific directories.i plan to add the arm tests into tests/jit/hwintrinsics/arm it would be nice to move the xarch ones into a subdirectory xarch x or something like that dotnet/jit-contrib for opinions@fiigii since this will likely affect your work can you do this at your convenience
282566351,15546,https://api.github.com/repos/dotnet/coreclr/issues/15546,ahsonkhan,1,0,0,0,0,0,fixes the tests disabled in after the change to readonlyspan indexer propagates to corefx.cc ektrah vsadov jkotas krzysztofcwalina
282334681,15538,https://api.github.com/repos/dotnet/coreclr/issues/15538,tannergooding,8,0,0,0,0,0,this implements basic codegen support for all currently declared sse intrinsics except for the store intrinsics
282198980,15524,https://api.github.com/repos/dotnet/coreclr/issues/15524,echesakovMSFT,4,0,0,0,0,0,this replaces usages sizeof(void or sizeof(size_t in clrjit with macro target_pointer_size or in some cases with macro regsize_bytes when referring to target arch pointer size target arch gen-purpose register size
281885979,15508,https://api.github.com/repos/dotnet/coreclr/issues/15508,morganbr,1,0,0,0,0,0,system.hashcode was recently added in order to make high-quality fast hashing easy we should replace usage of hashhelpers.combine an internal low-quality hash combiner with hashcode.combine it should lead to better distribution in dictionaries and the hashing should be nearly as fast
281852629,15506,https://api.github.com/repos/dotnet/coreclr/issues/15506,fiigii,6,0,0,0,0,0,status of intel hardware intrinsic work at this time we have enabled all the infrastructures for intel hardware intrinsic and certain scalar/simd intrinsics the next step is to implement specific intel hardware intrinsics optimizing mscorlib using intel hardware intrinsicthe base class library mscorlib is used by every net core program so its performance is critical and we can use hardware intrinsics to improve performance of mscorlib by leveraging modern intel architecture instructions for instance we experimented rewriting the nonrandomized hash function of string with sse.crc intrinsic in a micro-benchmark the result showed that crc version provided x (-bit)/ .x (-bit performance gain on short strings and x (-bit)/ .x (-bit gain hashing for longer strings.! image capturing optimization candidatesthis issue attempts to capture a list of optimization candidates in mscorlib for taking advantage of intel hardware intrinsics we are looking for popular use cases from the community and mscorlib authors and their input on how such methods could be optimized for example we use method xyz intensively and if xyz were to be optimized using intrinsic a and b we may get x performance gain that kind of information could help steer subsequent intrinsic work with highly demanded hardware intrinsics and many uses cases to have higher implementation priority in addition listed below are some general guidelines we plan to use when considering optimization candidates we would prioritize bit simd intrinsics that operate over vector
281645333,15500,https://api.github.com/repos/dotnet/coreclr/issues/15500,mikedn,1,0,0,0,0,0,i also removed a couple of const_cast uses from gentree.h there are others in the jit source code not sure if its worth going after all now but it would be nice to avoid adding new ones.i only added a const overload for asx not for asxref and its associated property id say that those properties should be avoided in new code
281600335,15497,https://api.github.com/repos/dotnet/coreclr/issues/15497,ahsonkhan,2,0,0,0,0,0,as part of adding apis to unsafe that are used by apis in system.memory.cc jkotas krzysztofcwalina terrajobst weshaggard joshfree mikedn
281529482,15491,https://api.github.com/repos/dotnet/coreclr/issues/15491,AndyAyersMS,3,0,0,0,0,0,heres an example similar to that came up in some span conversion efforts in corefx: c static readonlyspan
281269711,15483,https://api.github.com/repos/dotnet/coreclr/issues/15483,CarolEidt,3,0,0,0,0,0,update linearscan section of ryujit-overview and add lsra-detail
281195863,15476,https://api.github.com/repos/dotnet/coreclr/issues/15476,benaadams,4,0,0,0,0,0,as a condition of a while it doesnt elide the check csharpwhile uint)i uint)entries.length not elided if entries i .hashcode hashcode comparer.equals(key entries i .key changing it to an if break does elide the check csharpdo if uint)i uint)entries.length break elided if entries i .hashcode hashcode comparer.equals(key entries i .key category:cqtheme:bounds-checksskill-level:expertcost:small
281172795,15474,https://api.github.com/repos/dotnet/coreclr/issues/15474,echesakovMSFT,1,0,0,0,0,0,use macro countof instead of explicit sizeof(arr sizeof(arr or sizeof(arr sizeof(*arr in clrjit if countof is not defined by a compiler there is a fallback definition for countof in stdmacros.h
281147781,15472,https://api.github.com/repos/dotnet/coreclr/issues/15472,benaadams,2,0,0,0,0,0,e.g. csharpvar i buckets hashcode buckets.length ; will introduce a range check even though its always safe though maybe not for length category:cqtheme:bounds-checksskill-level:expertcost:small
281125492,15469,https://api.github.com/repos/dotnet/coreclr/issues/15469,gbalykov,1,0,0,0,0,0,this pull request adds memory footprint gc latency level.this pull request is based on the commit by maoni parameters for memory_consumption level are almost the same as for default balanced level which is same as the base except for gen min_size which is set equal to gen min_size large heap compacting is not included in this pull request.tizen xamarin gui applications base is ddaefabeaefcbc)test|base gc heap kb startup time s)|memory_consumption level gc heap kb startup time s)----|---------|----helloworld.tizen settings.tizen.mobile volumecontroller.tizen.mobile appcommon.tizen.mobile emailui.tizen.mobile applicationcontrol.tizen.mobile snsui.tizen.mobile applicationstoreui.tizen.mobile puzzle.tizen.mobile system_info.tizen.mobile galleryui.tizen.mobile calculator.tizen.mobile average gc heap size reduction startup time increase gc gui benchmarks:test|base gc heap kb startup time s)|memory_consumption level gc heap kb startup time s)----|---------|----gc test gc test fasta nbody spectral norm average gc heap size reduction startup time increase maonicc kvochko dmitri-botcharnikov
281106856,15467,https://api.github.com/repos/dotnet/coreclr/issues/15467,eerhardt,2,0,0,0,0,0,using matrixx by value methods are significantly slower than using corresponding ref overloads see rejected adding these ref overloads to system.numerics.vectors to avoid api clutter and because the performance benefit of the ref overloads is not significant.however the benchmarks showed a benefit for matrixx we should investigate how much of the matrixxbyref benefit can be matched with better codegen for the byvalue case and then implement any improvements.cc caroleidt category:cqtheme:vector-codegenskill-level:expertcost:medium
280867544,15459,https://api.github.com/repos/dotnet/coreclr/issues/15459,benaadams,1,0,0,0,0,0,byes less asm asm bytes)one less instruction per loopno stack push poptail call into array:cleartotal bytes of diff of base)ptal jkotas
280685536,15453,https://api.github.com/repos/dotnet/coreclr/issues/15453,benaadams,1,0,0,0,0,0,split resize expand and rehashrehashing is only used in string key variant so it doesnt need to be compiled in every expandrehashing doesnt expand the dictionary so it can reuse the existing arraysuse magicnumberremainder rather than idiv in expand and rehash
280654695,15448,https://api.github.com/repos/dotnet/coreclr/issues/15448,jashook,0,0,0,1,0,0,this change will start using build-test.sh generatelayoutonly to buildthe coreoverlay directory for use with runtest.sh.note that there are many small changes the following are a short summary build-test.sh add a generate layout only step which will only setup the coreroot but not build tests fixes restore issues on centos ubuntu osx netci.groovy use build-test.sh generate layout to setup the core_root change runtest to use coreoverlay it no longer builds the coreoverlay runtest.sh copy all dylib and so dependencies for the tests directly into core_root instead of the tests paththis fixes
280456245,15435,https://api.github.com/repos/dotnet/coreclr/issues/15435,cod7alex,0,0,0,0,0,4,adds usage of span and stackalloc for strings that are not large allows to avoid allocations of int arrays.benchmarks method mean after mean before mean diff allocated after allocated before allocated diff splitcharlength us us kb kb splitcharlength us us kb kb splitcharlength us us kb kb splitstringlength us us kb kb splitstringlength us us kb kb splitstringlength us us kb kb splitstringarraylength us us kb kb splitstringarraylength us us kb kb splitstringarraylength us us kb kb benchmark code stephentoub
280281616,15424,https://api.github.com/repos/dotnet/coreclr/issues/15424,fiigii,1,0,0,0,0,0,remove the definition and usages of typ_char from ryujit.fix
280258671,15420,https://api.github.com/repos/dotnet/coreclr/issues/15420,swgillespie,0,0,0,1,0,0,fixes the underlying perf bug that caused and is probably slowing down the ci a lot.the problem here is that tests/dir.props attempts to re-calculate buildversionfile and does so incorrectly despite the value already being set at the time that buildversionfile is evaluated in tests/dir.props officialbuildid is not set which results in buildversionfile being buildversion-.props from there all of the projects in the test build get into a nasty loop the build is expecting a buildversion-(current date e.g props file to be present as the version props file on the start of a test project build this file is checked for existence and if it doesnt exist the createorupdatecurrentversionfile target is fired createorupdatecurrentversionfile gathers version information by invoking git twice and a handful of other programs in order to figure out who is doing the build and what time it is occuring createorupdatecurrentversionfile saves this version info to what it believes to be buildversionfile which has been changed to be something incorrect buildversion-.props usually this file exists already and so nothing happens.because the version file that is being generated has an unexpected name msbuild always triggers createorupdatecurrentversionfile which hits the disk at least twice for git for every project in the transitive closure of the project being built i first noticed this bug when i saw that a bunch of tests that compile with ilasm were building very slowly and it turns out that this is because each ilasm test references another project so the above loop was occurring twice for a total of git invocations for every il test build.this pr removes the assignment to buildversionfile in tests/dir.props because as far as i can tell buildversionfile already has the right value assigned to it when tests/dir.props is imported and theres no need to re-assign it
280251957,15419,https://api.github.com/repos/dotnet/coreclr/issues/15419,benaadams,1,0,0,0,0,0,up to x speed up for finding value types x for finding object types improve dictionary findentry cq improve dictionary tryinsert cq use equalitycomparer.default only from bases buckets so the dont be set to on each resizeadds kb of base to system.private.corelib.ni.dll method containskeysimplepositive_intkey iequalitycomparer containskeysimplenegative_intkey iequalitycomparer containskeysimplepositive_stringkey iequalitycomparer containskeysimplenegative_stringkey iequalitycomparer containskeysimplepositive_objectkey iequalitycomparer containskeysimplenegative_objectkey iequalitycomparer after method containskeysimplepositive_intkey devirtualized containskeysimplenegative_intkey devirtualized containskeysimplepositive_stringkey iequalitycomparer containskeysimplenegative_stringkey iequalitycomparer containskeysimplepositive_objectkey virtual containskeysimplenegative_objectkey virtual method items current single func change containskey_single_yes_intkey ns ns x containskey_single_no_intkey ns ns x containskey_all_intkey ns ns x containskey_single_yes_stringkey ns ns x containskey_single_no_stringkey ns ns x containskey_single_yes_objectkey ns ns x containskey_single_no_objectkey ns ns x add_intkey ns ns x add_stringkey ns ns x add_objectkey ns ns x presizedadd_intkey ns ns x presizedadd_stringkey ns ns x presizedadd_objectkey ns ns x performance-wise multipath was faster but that increased code-gen by kb
280025238,15411,https://api.github.com/repos/dotnet/coreclr/issues/15411,benaadams,2,0,0,0,0,0,less adventurous than ref locals in tryinsert ref return findentry use equalitycomparer.default default comparer is null rather than via interface move null key check to inlinable methods so can be elided
279961392,15408,https://api.github.com/repos/dotnet/coreclr/issues/15408,CarolEidt,1,0,0,0,0,0,currently lsra iterates over all the free registers and then iterates again if it has to find a register to spill it would probably be more efficient as well as more effective to combine these passes in particular it would avoid the situation where we make a bad register choice for a critical interval simply because it is the only free register when it may be better to spill a less important interval .in particular it seems like this may be the best approach to address category:cqtheme:register-allocatorskill-level:expertcost:medium
279915190,15404,https://api.github.com/repos/dotnet/coreclr/issues/15404,CarolEidt,0,0,0,1,0,0,generate treenodeinfo into the map when building refpositions.add some new methods and flags for former gtlsrainfo functionality thats used outside of lsra gentree::getregisterdstcount number of registers defined by a node lir::flags::regoptional gtdebugflags::gtf_debug_node_lsra_addedfix
279489978,15378,https://api.github.com/repos/dotnet/coreclr/issues/15378,brianrob,5,0,0,0,0,0,useful for getting a snapshot of thread count and what threads are doing this would used in the performance profiling controller
279488373,15376,https://api.github.com/repos/dotnet/coreclr/issues/15376,brianrob,1,0,0,0,0,0,rather than forcing a trace file to be written to disk make it possible for the in-proc controller of tracing to get at the trace in-memory this allows the trace creator to do whatever it wants with the trace e.g send it out over http
279353506,15370,https://api.github.com/repos/dotnet/coreclr/issues/15370,MichalStrehovsky,1,0,0,0,0,0,marking as wip because i would like to x run all the tests on this x review the changes coming in with people who know about the affected parts of the codebase x see if we need to put more code under feature_default_interfaces x figure out how we want to merge this are we okay with the individual commits or do we want to do some rebasing
278636689,15342,https://api.github.com/repos/dotnet/coreclr/issues/15342,BruceForstall,0,0,0,1,0,0,fixes bad codegen in system.math.sign(long): return unchecked((int)(value long)((ulong)-value where the flag-setting low part of the decomposed neg was removedas dead by the constant right shift with constant even thoughthe flag setting is needed by the upper part.fixes the mathsign failure of
278635737,15341,https://api.github.com/repos/dotnet/coreclr/issues/15341,tannergooding,4,0,0,0,0,2,this is the start of fiigii eerhardt viktorhofer
278541963,15322,https://api.github.com/repos/dotnet/coreclr/issues/15322,stephentoub,7,0,0,0,0,0,also reduces the amount of unsafe code used.benchmark results benchmark mean before mean after improvement split_noseps_nosplits split_sep_nosplits split_seps_nosplits split_seps_nosplits split_manyseps_nosplits split_noseps_splits split_sep_splits split_seps_splits split_seps_splits split_manyseps_splits split_noseps_manysplits split_sep_manysplits split_seps_manysplits split_seps_manysplits split_manyseps_manysplits benchmark using system;using benchmarkdotnet.attributes.jobs;using benchmarkdotnet.attributes;using benchmarkdotnet.running; inprocess public class program public static void main benchmarkrunner.run
278439930,15319,https://api.github.com/repos/dotnet/coreclr/issues/15319,ans-ashkan,3,0,0,1,0,0,executing the following code: private static void main(string args var ar new double fillto(ref ar console.writeline(string.join ar.select(a a.tostring()).toarray()));}public static void fillto(ref double dd int n if dd.length n return double old dd double d double.nan if old.length d old dd new double n for int i i old.length i dd n old.length i old i for int i i n old.length i dd i d;} the result in debug mode is but in release mode is tested on net framework and net core also posted to stack overflow
277813472,15272,https://api.github.com/repos/dotnet/coreclr/issues/15272,stephentoub,0,0,0,1,0,0,one of the biggest costs when invoking int.tostring and similar methods is in fetching the current culture accessing its number information etc and if a culture is provided explicitly there are still costs related to casts but when the default format is used for non-negative integer values the number format information isnt used at all and we can skip the associated costs this improves formatting perf in such cases by upwards of cc jkotas ahsonkhan krzysztofcwalina before:! image
277596640,15256,https://api.github.com/repos/dotnet/coreclr/issues/15256,AndyAyersMS,1,0,0,0,0,0,"sinkwhitespace is one of the hotter methods in msbuild in some scenarios jit produces this assembly: asmg_m_ig push rdi push rsi ec sub rsp bf mov rsi rcx bfa mov rdi rdxg_m_ig eb jmp short g_m_igg_m_ig ff inc dword ptr rdi g_m_ig bf mov ecx dword ptr rdi b mov edx dword ptr rsi bca cmp ecx edx da jge short g_m_ig bca cmp ecx edx d jae short g_m_ig c movsxd rcx ecx fbcec movzx rcx word ptr rsi+*rcx fff cmp ecx fa jg short g_m_ig f cmp ecx e je short g_m_ig df lea edx rcx fa cmp edx jbe short g_m_ig fa cmp ecx e je short g_m_ig f cmp ecx fc sete cl fbc movzx rcx cl eb jmp short g_m_igg_m_ig b mov ecx g_m_ig eb jmp short g_m_igg_m_ig d xor edx edx eafd call system.globalization.charunicodeinfo:internalgetcategoryvalue(int,int):ubyte cf add eax f cmp eax ja short g_m_ig b mov ecx eb jmp short g_m_igg_m_ig c xor ecx ecxg_m_ig c test ecx ecx b jne short g_m_igg_m_ig c add rsp e pop rsi f pop rdi c retg_m_ig edcf call corinfo_help_rngchkfail cc int some things that could be improved on redundant branch at top of ig lack of register promotion for the string length unnecessary materialization of the boolean value for char.iswhitespace note the value of ecx is set for all predcessors of ig so theres no need to test the value there see likely the latin whitespace test can be better expressed as a compare tree or maybe via some magic branchless hash the values returning true are x-xd x x and xa not whitespace is possibly the case to optimize for stretch promote the ref param within the loop body.category:cqtheme:basic-cqskill-level:expertcost:small"
277485212,15244,https://api.github.com/repos/dotnet/coreclr/issues/15244,fiigii,1,0,0,0,0,0,this pr implements the new simd types vector
277218424,15238,https://api.github.com/repos/dotnet/coreclr/issues/15238,stephentoub,1,0,0,0,0,0,as part of this i needed to fix-up several functions that parsed strings assuming they end with which no longer holds once we switch to using spans.i left the existing signatures with todos to be removed once these changes have propagated through to corefx and the contracts have been updated.also switched various call sites to using a cast rather than asreadonlyspan updated string.format stringbuilder.appendformat to use the new span-based support to avoid substring allocations removed some todos that were left in the codebase from some of my previous changescontributes to jkotas krzysztofcwalina ahsonkhan
277124184,15232,https://api.github.com/repos/dotnet/coreclr/issues/15232,kouvel,1,0,0,0,0,0,consider the following lower initial delay between adding threads when there is starvation maybe ms instead of ms increase the number of threads that are added per delay initially maybe as function of proc count instead of as the current number of worker threads increases beyond the minimum configured worker thread count increase the delay between adding threads up to a max which could be the current default delay decrease the number of threads that are added per delay up to a min of
276703296,15207,https://api.github.com/repos/dotnet/coreclr/issues/15207,sfmskywalker,1,0,0,0,0,0,i already reported this issue here but realized this repo might be more appropriate if not ill close it otherwise ill close the other finalizer no longer called in net core after gc.collect gc.waitforpendingfinalizersas of net core an objects finalizer is no longer called when calling gc.collect and gc.waitforpendingfinalizers generalto be clear the following code works as advertised in net framework and earlier net core and earlier but not in net core csharp testclass public class garbagecollectiontest testmethod description(asserts that an un-rooted objects finalizer will be called public void garbagecollectiontest instantiate a spy to record that the foo finalizer is called var spy new spy instantiate a new foo var foo new foo(spy unroot foo foo null force a collection gc.collect gccollectionmode.forced blocking true wait for all finalizers to have executed gc.waitforpendingfinalizers assert that foos finalizer is called warning this assertion fails in net core but works in net core and net framework and before assert.istrue(spy.finalizeriscalled private class spy public bool finalizeriscalled get set private class foo foo spy.finalizeriscalled true public foo(spy spy this.spy spy private readonly spy spy unit test output:! image demonstrate the issue i created a unit test project for the following frameworks which all share the same cs file net framework passing net core passing net core passing net core failing * garbagecollectiontests.zip
276471519,15200,https://api.github.com/repos/dotnet/coreclr/issues/15200,mikedn,1,0,0,0,0,0,the iterator model isnt a very good fit for block successor iteration these iterators are quite large allsuccessoriter has bytes on bit hosts and the need to maintain iterators current and end only make things worse when iterators need to be stored in containers ssabuilder::topologicalsort uses stacks containing iterators and one containing basicblock pointers visiting a block practically requires pushing bytes containing a lot of redundant stuff the second iterator should not be needed the block pointer is already present in the first iterator and it appears twice in allsuccessoriter the compiler pointer isnt really needed and also appears twice in allsuccessoriter this change extracts the iteration logic into position classes that contain only the state need to maintain the current successor these classes can then be used to build iterators or other mechanism that are more useful in some scenarios an enumerator for example.this reduces memory usage by cmk_arraystack drops by more than half and also provides a small reduction in instructions retired.mem stats diff data
276204910,15176,https://api.github.com/repos/dotnet/coreclr/issues/15176,brianrob,0,0,0,1,0,0,due to the current throughput issues we are disabling automatic performance pr jobs.they will still run post-merge and can be requested via trigger phrase.these will be back once throughput issues are addressed.filed to bring these runs back.cc valenis adiaaida
276137561,15167,https://api.github.com/repos/dotnet/coreclr/issues/15167,stephentoub,0,0,0,1,0,0,contributes to jkotas ahsonkhan
275584939,15136,https://api.github.com/repos/dotnet/coreclr/issues/15136,noahfalk,12,0,0,0,0,0,im making this issue as an informal way to flag other issues and discussions that might be relevant to building net profiling tools this is similar to the net announcements repo but given that profiling is a small crowd i didnt want to create noise for everyone or be very formal about it follow the issue if this is something you care about hopefully it works well but if not we can try something else.please dont do discussion directly in this issue just links thanks
275553545,15134,https://api.github.com/repos/dotnet/coreclr/issues/15134,BruceForstall,0,0,0,5,0,1,ryujit/arm jit is now named clrjit.dll was named protojit.dll).arm legacy_backend jit is now named legacyjit.dll was named clrjit.dll
275525058,15130,https://api.github.com/repos/dotnet/coreclr/issues/15130,AndyAyersMS,4,0,0,0,0,0,from some discussion over in dotnet/csharplang both the for and foreach cases have suboptimal cq in the for case there is a redundant branch in the inner loop.in the foreach case the enumerators movenext is not inlined if we force this and movenextrare inline then the jit is not able to optimize away the version check overhead in the inner loop.without the inlines the foreach is rougly x slower than the for with the inlines this drops to x or so. c static int sumfor(list
275197857,15108,https://api.github.com/repos/dotnet/coreclr/issues/15108,mikedn,5,0,0,0,0,0,i have various pending work that improves ssabuilder co memory usage and performance maybe its good to have an issue to track all that.it looks like with the changes i have now some already merged the memory usage of ssabuilder can be halved perhaps even more and theres also a drop in instruction retired of total instructions retired cant measure just instructions retired during ssa construction x improve df/idf computation and storage x stop computing all idfs up front looks like theres simply no need to do this insertphifunctions can compute each idf when needed and that allows reusing a single blkvector for all idfs x improve ssa dom tree memory usage eliminate duplicate ssa number bookkeeping memory ssa should not reuse lclssavardsc the definition location information is not used and it wastes memory a valuenumpair is sufficient possibly wrapped in a ssamemdef remove uninit_ssa_num its not actually needed and it just wastes memory in the ssa arrays improve fgexcludefromssa this is called many times and its pretty large ssabuilder should call it once for every variable and then set a bit looks like there are some spare bits available in lclvardsc that everyone else checks stop creating ssa numbers and vns for variables that are excluded from ssa when compinitmem is true ssabuilder::renamevariables assigns ssa numbers to all variables x improve ssabuilder::topologicalsort we can use a single stack and avoid some object copying improve ssa renaming improve dom tree walking we may be able to stop pushing all the dom tree children of a node and instead use iterators similar to topologicalsort consider chaining phis and phi_args manually using gtsetstmtinfo and fgsetstmtseq is expensive.some of this dom tree stuff renaming may apply to copy propagation as well since in its current form it mirrors ssa construction.once all of this is done it may be worth investigating extracting dominance related code into a separate class and merging with fgcomputedoms co.category:throughputtheme:ssaskill-level:expertcost:large
274948100,15076,https://api.github.com/repos/dotnet/coreclr/issues/15076,jkotas,1,0,0,0,0,0,from readonlyspan.trycopyto is but the buffer.memmove its using for the actual copy is so theres in there that going to something other than the actual copy the trace shows in the readonlyspan.trycopyto body and in the span.copyto body that trycopyto calls if were looking to optimize for such percentages id prefer to see us start by looking at making trycopyto faster as thatll accrue to many other scenarios
274721426,15069,https://api.github.com/repos/dotnet/coreclr/issues/15069,stephentoub,0,0,0,1,0,0,the end result of this pr is a tryformat method being added to boolean sbyte byte int int int uint uint uinthowever most of the commits lead up to that by porting code from corert to the shared partition corerts formatting implementation is a managed port of the native formatting implementation in coreclr this then moves coreclr back to using the same managed implementation ive split this into a bunch of commits to help make it easier to review the primary goals here are exposing tryformat on our primitive types consolidating on a single managed parsing/formatting implementation shared across coreclr/corert not regressing performancethe first commit brings the core numberbuffer type to the shared partition until weve entirely removed formatting from native code we still need numberbuffer to play well with the number type thats used for the remaining decimal double and float formatting in the runtime.the next commit moves the integer parsing logic into shared this parsing logic was already in managed code in coreclr with almost identical code in corert this rationalizes the two and moves that to shared.the next commit rationalizes a difference between number in coreclr and numberbuffer in corert coreclr had a buffer for chars whereas corert for there doesnt appear to be any necessary reason to have the larger size so this consolidates to the the next commit separates out the decimal and floating-point parsing logic and moves it to shared the formatting logic for decimal double single remain in native for now.then a bunch of commits add in optimizations that were causing the managed implementation to be significantly slower than the native many of these involve reviewing the native code and making the managed implementation look more like it e.g using pointers more to avoid bounds checks and the like.additionally several commits delete now dead code such as the majority of the formatting implementation from the runtime.finally two commits add additional features one adds the new tryformat methods that build on this managed formatting and another that uses tryformat in stringbuilder to avoid string allocations in methods like stringbuilder.append(int).i ran a bunch of benchmark.net tests locally though theres a lot of fluctation on my machine my takeaways are there are significant improvements in the new implementation for g the default and d upwards of x appears to be faster in the managed implementation e and f are slower in the managed implementation the rest appear to be within noise in one direction or the other.theres likely room for further improvement and it should hopefully be easier now that its managed and shared with corert we can also look at reducing the amount of unsafe code involved switching over to using spans as we determine it doesnt regress perf impactfully.i also did not do a lot to clean up the formatting of the code from corert that can be done subsequently.note too that this port enables tryformat which is allocation-free compared to tostring which needs to of course allocate the resulting string.cc jkotas vancem atsushikan krzysztofcwalina danmosemsft contributes to to to
273694830,15019,https://api.github.com/repos/dotnet/coreclr/issues/15019,JimsC,0,0,0,0,2,0,coreclrc#luac/c++c#c#dllimportc/c++coreclrcoreclrcoreclr
273300344,15002,https://api.github.com/repos/dotnet/coreclr/issues/15002,stephentoub,1,0,0,0,0,0,a recent fix around semaphoreslims spinning has led to it spinning even when spinning isnt necessary resulting in measurable overheads when trying to acquire a semaphore that has count available this fixes that by putting back the check to avoid spinning if count is known to be available.fixes kouvel benaadams timings for doing wait/release repeatedly on a semaphore with count available...before method mean error stddev waitasync ns ns ns wait ns ns ns wait ns ns ns after method mean error stddev waitasync ns ns ns wait ns ns ns wait ns ns ns
273260541,15000,https://api.github.com/repos/dotnet/coreclr/issues/15000,mikedn,0,0,0,1,0,0,i have to do a lot of cleanup before its ready theres way too much unrelated refactoring in this but using plain old singly linked list saves cmk_ssa memory and retired instructions without hurting code readability imo
273126208,14991,https://api.github.com/repos/dotnet/coreclr/issues/14991,tmds,3,0,0,0,0,0,as reported by emanuelbalea here
272732561,14968,https://api.github.com/repos/dotnet/coreclr/issues/14968,jkotas,6,0,0,0,0,0,the managed code often wants to have a strong control where to load native dlls from for example our own code in system.drawing.common the discussion in has more example of similar use cases.we should consider adding imperative native dll loading apis to make this easier
272419619,14950,https://api.github.com/repos/dotnet/coreclr/issues/14950,GCCFeli,1,0,0,0,0,0,is there any plan to get an ios build
272407844,14948,https://api.github.com/repos/dotnet/coreclr/issues/14948,vancem,1,0,0,0,0,0,if you only install vs now the common scneario)and build coreclr it will fail with com with a class_not_registered errorthis is because a build-tools package is depending on an old com objectthat has gone way in vs.while we sort getting a proper fix this makes the work-around whichis registering the dll by hand discoverable.see for details.@lt russellhadley briansull
272263661,14927,https://api.github.com/repos/dotnet/coreclr/issues/14927,tarekgh,2,0,0,0,0,0,currently we support enabling the globalization invariant mode through app config switch we need to have a way to enable this globally to use it in the alpine docker image the way we are going to support that is by allowing enabling the mode through a global environment variable.the way this will work is if the application declared the app config switch system.globalization.invariant well honor that setting and will not read the environment variable if the app didnt declare the config switch well try to read the environment variable dotnet_system_globalization_invariant and honor it if it is declared otherwise if the config switch nor the environment variable is declared well assume the invariant mode is off and the app required to run with full globalization and icu would be required on linux based platforms
272084381,14922,https://api.github.com/repos/dotnet/coreclr/issues/14922,stephentoub,0,0,0,2,0,0,adds a ref struct enumerator and a corresponding getenumerator method to each.contributes to to jkotas ahsonkhan krzysztofcwalina vsadov
272060028,14917,https://api.github.com/repos/dotnet/coreclr/issues/14917,BruceForstall,1,0,0,0,0,0,we need to be able to use complus_altjitngen when running x-hosted arm-targeted crossgen of system.private.corelib.dll and others so we need a proper jit to be built and dropped to the bin\product\windows_nt.arm.debug\x directory for example next to crossgen.exe as with clrjit.dll
271723778,14894,https://api.github.com/repos/dotnet/coreclr/issues/14894,jkotas,2,0,0,0,0,0,fixes
271648543,14890,https://api.github.com/repos/dotnet/coreclr/issues/14890,AndyAyersMS,6,0,0,2,0,0,currently if you newobj a struct via a constructor call the jit assumes the structs old value may be read during the construction of the new value so the pattern emitted is zero temp obj storage call constructor on temp obj copy temp obj to the destination when the final destination is register promoted all this tends to get cleaned up but when the final destination cant be register promoted the code the jit produces can be surprisingly large and slow.for instance given c#valuetask();valuetaskawaiter
271562389,14884,https://api.github.com/repos/dotnet/coreclr/issues/14884,4creators,2,0,0,0,0,0,currently cmake is used according to standard pattern where only cpp file are included into targets with library or executable however this pattern breaks some usability of cmake created visual studio projects since they do not include header files by default and it is necessary to search for them in vs project dependencies directory containing several hundred files or scroll to top of code file and click open file on include directive obviously none of this is convenient even for medium sized code files.if proposal will be accepted i could provide pr with required changes
271503991,14878,https://api.github.com/repos/dotnet/coreclr/issues/14878,4creators,1,0,0,0,0,0,currently crossgen runs compilation as a single threaded task it would significantly improve performance of several crossgen dependent scenarios if crossgen native component compilation could be run as a multithreaded task.my understanding is that ryujit by default supports multithreaded compilation of methods if this could be exploited by crossgen it would enable several orders of magnitude faster native components compilation
271460665,14876,https://api.github.com/repos/dotnet/coreclr/issues/14876,stilettk,1,0,0,0,0,0,"descriptioncurrently when passing ienumerable to insertrange the following algorithm is used if ienumerable is inserted to the end of a list index size it enumerates it and appends elements to the end of underlying array if ienumerable is inserted in the middle of list index size it simply enumerates it and calls insert for each element.the second approach is quite complex suppose that we insert ienumerable with m elements to the list with n elements to the position k n in each insert there is an array.copy call which is o(n-k so the current complexity is o(m*n suggestionthere are faster algorithm to accomplish this ienumerable is enumerated and added to the end of the list like when adding to the end this in o(m swap arrays segments k n and n n+m for example this algorithm has o(n-k+m)=o(n+m complexity so the resulting complexity will be o(m o(n+m o(max(m n)) .for example a,b,c is being inserted in to the position k the algorithm steps will be a,b,c a,b,c things to considerunlike current algorithm there is no intermediate results in case of exception list might end up in incorrect state right now just part of ienumerable will be added on the other hand some other methods may have the same behavior as well for example array.reverse"
271164927,14863,https://api.github.com/repos/dotnet/coreclr/issues/14863,jcdickinson,6,0,0,5,0,1,migrated pull request the original pr for full discussion on the code.fixes proposal add system.hashcode to make it easier to generate good hash codes in corefx.works by maintaining the xxhash state variables v v length as well as a queue of values that fall outside of the block size bytes ints the seed is initialized to random bytes.tests against known xxhash vectors are provided in the original pull request performance inibenchmarkdotnet=v os=windows redstone processor=intel core i-mq cpu ghz haswell processorcount=frequency hz resolution ns timer=tsc.net core sdk host net core framework bit ryujit defaultjob net core framework bit ryujit method mean error stddev scaled unsafe ns ns ns calls no inlining ns ns ns unrolled no inlining ns ns ns calls inlining ns ns ns unrolled inlining ns ns ns deviations from xxhash length is stored as the number of hashed fields not bytes it is multiplied at the end by so that it behaves exactly like xxhash the structure wont accept more than uint.maxvalue values failing with an overflowexception this is to prevent the possibility of it re-initializing the code that mixes in individual bytes is omitted this struct only accepts int rd party codesubmission containing materials of a third party author project license comments cyan xxhash bsd reference not copied code cc morganbr
271127892,14859,https://api.github.com/repos/dotnet/coreclr/issues/14859,justinvp,1,0,0,0,0,0,cc ahsonkhan
271079554,14850,https://api.github.com/repos/dotnet/coreclr/issues/14850,AndyAyersMS,1,0,0,0,0,0,when prejitting the jit assesses whether each root method is a potentialinline candidate for any possible caller methods deemed un-inlinable in anycaller are marked in the runtime as noinline to save the jit some worklater on when it sees calls to these methods.this assessment was too conservative and led to prejit-ordering dependencesfor inlines it also meant that prejitting was missing some inlines thatwould have happened had we not done the prejit root assessment.this change removes some of the prejit observation blockers these mostlywill enable more prejit methods to become candidates we also now track whena method argument reaches a test.when we are assessing profitability for a prejit root assume the call sitebest possible case.also update the inline xml to capture the prejit assessments.this increases the number of inlines considered and performed when prejittingand will also lead to slightly more inlining when jitting however we do notexpect a large througput impact when jitting the main impact of this changeis that inlining when prejitting is now just as aggressive as inlining whenjitting and the decisions no longer depend on the order in which methods areprejitted.closes closes
271030913,14846,https://api.github.com/repos/dotnet/coreclr/issues/14846,tannergooding,1,0,0,0,0,0,both of these methods should be updated to be intrinsic and generate a single instruction on platforms that support it.on x architectures they should be generating ucomisd and ucomiss respectively.category:cqtheme:basic-cqskill-level:intermediatecost:medium
270700069,14819,https://api.github.com/repos/dotnet/coreclr/issues/14819,lt72,1,0,0,0,0,0,debugging instructions should carry the information on how to acquire symbols whether that happens through a tool or by manual download or both all locations of the symbols should be clearly documented.e.g the debugging instruction page should carry a link to the core-setup and the download links page on dlc
270509895,14815,https://api.github.com/repos/dotnet/coreclr/issues/14815,AndyAyersMS,2,0,0,0,0,0,merge the legacypolicy and enhancedlegacypolicy into a unified policy thatbehaves like the enhancedlegacypolicy rename this policy to the defaultpolicysince it is in fact the default inline policy.we had been keeping the legacypolicy around in case we ever needed to revertback to the initial ryujit inline behavior but that safeguard no longer seemsnecessary.remove some of the checks in flowgraph.cpp that alter behavior based on policyas they are no longer needed.remove the jit config setting that allowed selection of the legacypolicy.this is the first stage in fixing
270377800,14794,https://api.github.com/repos/dotnet/coreclr/issues/14794,lt72,1,0,0,0,0,0,how about something like: dotnet get-runtime-symbols defaults to runtime and libraries that best match the cli version) dotnet get-runtime-symbols
269340711,14738,https://api.github.com/repos/dotnet/coreclr/issues/14738,shravan2x,1,0,0,0,0,0,this is a cross post from and i am also posting here under the recommendation of benaadams._i run a number of asp net core servers on ubuntu this is the htop view of one of the processes:! image process appears to be using g of virt i understand that this is not actually allocated memory but is the highest among all processes running on the entire system this is view of a number of apps:! image one of the xg virts is an asp.net core app and every other app in the m range is mono the actual asp.net server itself runs on kestrel is very simple and serves only static pages via mvc is there a reason for such a high virt why does an app that only serves static pages have m of private memory im aware some other language like php or even plain html might be better suited for my use but i use asp since it is more customizable and fun to work with)please note that since this scenario lies on a production server the version is i apologize if it has already been resolved in another issue. update this issue still persists on net core and asp.net core
269338391,14737,https://api.github.com/repos/dotnet/coreclr/issues/14737,jkotas,1,0,0,0,0,0,make enumequalitycomparer sealed this helps with jit optimizations delete sbyteenumequalitycomparer and shortenumequalitycomparer because of they are not needed anymore the optimization that they were introduced for is done by the jit now deleted forwardedfrom attributes on types that do not need them
269225626,14727,https://api.github.com/repos/dotnet/coreclr/issues/14727,ahsonkhan,0,0,0,2,0,0,fixes pr ektrah vsadov jkotas krzysztofcwalina
269166146,14720,https://api.github.com/repos/dotnet/coreclr/issues/14720,Petermarcu,3,0,0,0,0,0,daniel commented on wed oct getting this error while moving a site from asp.net core on mono to asp.net core on net core dbug microsoft.aspnetcore.mvc.internal.controlleractioninvoker executed action method daniel.web.controllers.shorturlcontroller.index daniel.web returned result microsoft.aspnetcore.mvc.contentresult.process is terminating due to stackoverflowexception abort ld_library_path=/tmp/ssltest aspnetcore_environment=development how do i get a full stack trace for the stackoverflowexception to determine where its coming from
268533125,14698,https://api.github.com/repos/dotnet/coreclr/issues/14698,AndyAyersMS,1,0,0,0,0,0,see commits for details.as per usual i need to finish off the implementation for spmi and prepare desktop for jit interface changes.also still looking at diffs
268215333,14681,https://api.github.com/repos/dotnet/coreclr/issues/14681,masonwheeler,2,0,0,0,0,0,weve all had it happen we go to load a program or load an assembly into our program and it fails with an assembly not found error on some assembly we didnt ask for that doesnt look at first glance like it has anything to do with what were trying to load generally its a dependency of a dependency of a dependency of a dependency of what we actually care about and the actual problem to be fixed could lie at any point along that dependency chain.knowing what this chain is is the information that we need to resolve the issue but its not provided which makes fixing these problems like pulling teeth sometimes.it would be great if we could get a stacktrace of the dependency chain so that instead of simply saying could not load file or assembly foo version culture=neutral publickeytoken=ccbffcdddd the system cannot find the file specified.it would then continue on and say while loading assembly bar version culture=neutral publickeytoken=ccbffcdddd while loading assembly baz version culture=neutral publickeytoken=ccbffcdddd while loading assembly qux version culture=neutral publickeytoken=ccbffcddddhow much work would it be to fix this up
267782264,14659,https://api.github.com/repos/dotnet/coreclr/issues/14659,janvorli,1,0,0,0,0,0,currently the build.sh init-tools.sh build-packages.sh and build-test.sh contains copies of the same code e.g for host rid detection we should move the shared code to a shared shell script file so that we have just one copy of that code later on it would be ideal to share that code even between all of our repos
267606014,14655,https://api.github.com/repos/dotnet/coreclr/issues/14655,benaadams,17,0,0,5,0,41,allows a developer to determine correct overload called for async and iterators from a stacktrace.matches the complier generated containing type to the source method using method.declaringtype statemachineattribute.statemachinetype attribute to allow the stack trace to resolve the mangled method name to the correct overload also appends the statemachine method name with for iterators addressing exception of type system.exception was thrown at program.recursiveasync(int count at program.recursiveasync(int count at program.recursiveasync(int count at program.methodasync at program.main(string args) instead of the current: system.exception exception of type system.exception was thrown at program.d__.movenext at program.d__.movenext at program.d__.movenext at program.d__.movenext at program.d__.movenext() iterators system.exception exception of type system.exception was thrown at program.range(int start int end)+movenext at program.range(int start int end)+movenext at program.main(string args) instead of the current: system.exception exception of type system.exception was thrown at program.d__.movenext at program.d__.movenext at program.main(string args) builds on the other prs for improving async stacktrace readability hide post exception stack frames remove edi boundary for async which removed the async noise at system.runtime.exceptionservices.exceptiondispatchinfo.throw at system.runtime.compilerservices.taskawaiter.throwfornonsuccess(task task at system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task task at system.runtime.compilerservices.taskawaiter.validateend(task task at system.runtime.compilerservices.taskawaiter.getresult at end of stack trace from previous location where exception was thrown resolves stephentoub tmat noahfalk aelij
267487438,14652,https://api.github.com/repos/dotnet/coreclr/issues/14652,benaadams,0,0,0,2,0,0,follow on from from stack trace at system.runtime.exceptionservices.exceptiondispatchinfo.throw at system.runtime.compilerservices.taskawaiter.throwfornonsuccess(task task at system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task task at system.runtime.compilerservices.taskawaiter.validateend(task task at system.runtime.compilerservices.taskawaiter.getresult cc stephentoub noahfalk jkotas ptal
267389492,14646,https://api.github.com/repos/dotnet/coreclr/issues/14646,mazong1123,0,0,0,0,0,5,implemented grisu algorithm when calling double.tostring try grisu first if it fails fall back to dragon.fix
267341289,14644,https://api.github.com/repos/dotnet/coreclr/issues/14644,noahfalk,1,0,0,0,0,0,weve been making progress testing apis and fixing issues the description in this doc had gotten well out of date
267279065,14623,https://api.github.com/repos/dotnet/coreclr/issues/14623,AndyAyersMS,1,0,0,0,0,0,optimize fixed sized locallocs of bytes or less to use local buffers.also optimize the degenerate byte case.allow inline candidates containing localloc but fail inlining if anyof a candidates locallocs do not convert to local buffers.the byte size threshold was arrived at empirically larger values didnot enable many more cases and started seeinge size bloat because oflarger stack offsets.we can revise this threshold if we are willing to reorder locals and seefixed sized cases larger than bytes.closes also add missing handler for the callsite is in try region this wasan oversight
267228135,14616,https://api.github.com/repos/dotnet/coreclr/issues/14616,sdmaclea,1,0,0,0,0,0,dotnet/jit-contrib dotnet/arm-contrib ptalthere is a large overlap overlap between xarch and arm in most cases individual intrinsic lines are identical in a few cases the set of supported base types is different multiply dot product this list could grow as simd is debugged and tested xarch has a few more internal intrinsicseventually these lists could be merged but keeping them separate until simd is functional on arm seems appropriate
267059398,14608,https://api.github.com/repos/dotnet/coreclr/issues/14608,benaadams,7,0,0,0,0,0,follow on from but also works for debug build and doesnt rely on jit behaviorcurrently from looking at a stack trace theres a lot of noise but perhaps more importantly there isnt enough detail to tell what overloads of a method were called for async and iterators due to the name mangling prior to movenext() .this pr seeks to address both these issues so that using the stack trace output is a more productive experience whether trying to identify causes from logs and what code to look at or just to not be daunting to new developers also provide opt-outs to previous behavior and allow future extensibility).it adds the following internal items to system.diagnotsics will seek api review to make public) csharp flags internal enum stacktraceformattingoptions none excludestacktracehiddenattribute excludedispatchboundaries excludeinnerexceptionboundaries resolveasyncmethods resolveiteratormethods public partial class stacktrace internal static stacktraceformattingoptions formattingoptions get set stacktraceformattingoptions.excludestacktracehiddenattribute stacktraceformattingoptions.excludedispatchboundaries stacktraceformattingoptions.resolveasyncmethods stacktraceformattingoptions.resolveiteratormethods;} the default formatting is excludestacktracehiddenattribute excludedispatchboundaries resolveasyncmethods resolveiteratormethods .adding stacktracehidden to a method will drop it from the stacktrace and adding it to the class/struct will drop all of its methods from the trace.for async methods and users of exceptiondispatchinfo excludestacktracehiddenattribute outputs at program.d__.movenext() instead of at system.runtime.exceptionservices.exceptiondispatchinfo.throw at system.runtime.compilerservices.taskawaiter.throwfornonsuccess(task task at system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task task at system.runtime.compilerservices.taskawaiter.validateend(task task at system.runtime.compilerservices.taskawaiter.getresult at program.d__.movenext() for throwhelper methodsoutputs system.invalidoperationexception collection was modified enumeration operation may not execute at system.collections.generic.list .enumerator.movenextrare at system.collections.generic.list .enumerator.movenext() instead of system.invalidoperationexception collection was modified enumeration operation may not execute at system.throwhelper.throwinvalidoperationexception_invalidoperation_enumfailedversion at system.collections.generic.list .enumerator.movenextrare at system.collections.generic.list .enumerator.movenext() so they act as in-place throw s resolveiteratormethods outputs at system.linq.enumerable.skipwhileiterator tsource (ienumerable source func predicate)at program.iterator(int count int value instead of at system.linq.enumerable.d__ .movenext()at program.d__.movenext resolveasyncmethods outputs at program.valuetaskasync(string name at program.tasktasync(int count instead of at program.d__.movenext at program.d__.movenext excludedispatchboundaries drops end of stack trace from previous location where exception was thrown excludeinnerexceptionboundaries drops included by default end of inner exception stack trace resolves noahfalk ptal
267021219,14600,https://api.github.com/repos/dotnet/coreclr/issues/14600,BruceForstall,0,1,0,0,0,0,in the case where the dst lives on the stack after the firstgcref/byref was copied we never set the type back to non-gcfor subsequent copies using the same temp register
266951380,14593,https://api.github.com/repos/dotnet/coreclr/issues/14593,mikedn,2,0,0,0,0,0,the wip bot that was added recently seems like a bad idea well a good idea implemented badly it should add a no merge tag not fail the build its annoying to see that a pr build fails instantly after a commit
266917175,14590,https://api.github.com/repos/dotnet/coreclr/issues/14590,jkotas,1,0,0,0,0,0,the flag was getting overwritten when both corinfo_flg_intrinsic and corinfo_flg_jit_intrinsic are set
266692966,14582,https://api.github.com/repos/dotnet/coreclr/issues/14582,briansull,1,0,0,0,0,0,removed unused fields of icon nodes the union of gticonhdl gticonhdl and gticoncpx gtiiconcls is not usedremoved unused handle args from gtnewiconhandlenode and gtnewicomembhndnode
266483904,14564,https://api.github.com/repos/dotnet/coreclr/issues/14564,benaadams,5,0,0,2,0,0,currently the only way to drop something from a stack trace is if it inlines or if it isnt in the stack so this change changes the stack when the exception is thrown.it passes the exceptions back to be thrown at the location rather than throwing in place removing from stack)! throw change exception resolving functions are not a participant of the exception or trace nothing wrong has happened in or before them and they are not in the direct path they are orthogonal to it so having the throw where it currently is doesnt add value.make sure validateend inlines with the extra exception check remove by inlining as now)so outputs system.exception exception of type system.exception was thrown at program.d__.movenext in c:\stacktraceasync\program.cs:line end of stack trace from previous location where exception was thrown at program.d__.movenext in c:\stacktraceasync\program.cs:line end of stack trace from previous location where exception was thrown at program.d__.movenext in c:\stacktraceasync\program.cs:line end of stack trace from previous location where exception was thrown at program.d__.movenext in c:\stacktraceasync\program.cs:line end of stack trace from previous location where exception was thrown instead of system.exception exception of type system.exception was thrown at program.d__.movenext in c:\stacktraceasync\program.cs:line end of stack trace from previous location where exception was thrown at system.runtime.exceptionservices.exceptiondispatchinfo.throw at system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task task at program.d__.movenext in c:\stacktraceasync\program.cs:line end of stack trace from previous location where exception was thrown at system.runtime.exceptionservices.exceptiondispatchinfo.throw at system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task task at program.d__.movenext in c:\stacktraceasync\program.cs:line end of stack trace from previous location where exception was thrown at system.runtime.exceptionservices.exceptiondispatchinfo.throw at system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task task at program.d__.movenext in c:\stacktraceasync\program.cs:line end of stack trace from previous location where exception was thrown main call site change extra in async method looks to be diffg_m_ig mov rcx rax call corinfo_help_throw call taskawaiter:handlenonsuccessanddebuggernotification(ref nop test rax rax jne short g_m_ig issues/questions line numbers go out of sync can edi exceptions be passed and thrown later loss of info for from previous location where exception was thrown is adding inline info breaking change for stack trace parsers to to joperezr noahfalk tmat davidfowl davkean nickcraver
266375664,14562,https://api.github.com/repos/dotnet/coreclr/issues/14562,sunnycase,7,0,0,0,1,0,we are writing a wrapper between coreclr and mono api to make unity games running on top of coreclr repo link now we have encountered some issues about object model conflicts between mono and coreclr object issuein mono an object header is inside of the object ctypedef struct monovtable vtable monothreadssync synchronisation monoobject the first field of an object starts at offset of bytes in mono.where in coreclr an object header is before the object c++class object protected ptr_methodtable m_pmethtab the first field of an object starts at offset of bytes in coreclr.when unity making a fcall it writes the first field in a object which is at offset of bytes in mono but in fact the field is at bytes in coreclr then it crashes solutions move objheader back into object x we tried compare but failed in gc currently gc has a close contact with object model it is hard to modify add bytes padding after m_pmethtab it definitely works compare but this solution will take more memory usage arraybase issuearrays defination in mono ctypedef struct monoobject obj bounds is null for szarrays monoarraybounds bounds total number of elements of the array guint max_length we use double to ensure proper alignment on platforms that need it double vector mono_zero_len_array monoarray; arrays defination in coreclr c++class arraybase public object{private this must be the first field so that it directly follows object this is because object::getsize looks at m_numcomponents even though it may not be an array the values is shifted out if not an array so its ok dword m_numcomponents dword pad what comes after this conceputally is typehandle elementtype only present if the method table is shared among many types arrays of pointers int bounds rank the bounds are only present for multidimensional arrays int lowerbounds rank valid indexes are lowerbounds i index i lowerbounds i bounds i ...}; it seems arraybase is also a core type used in gc even a free object is a arraybase if we change the arraybases layout gc will not work once again conclusionwill it be possible to decouple object arraybase layout between gc and ee if its ok we will be very appreciate that you will save us a lot of time thanks
266337704,14560,https://api.github.com/repos/dotnet/coreclr/issues/14560,jkotas,0,0,0,2,0,1,disable code to handle multiple appdomains use more efficient object array accessor
266325343,14557,https://api.github.com/repos/dotnet/coreclr/issues/14557,CarolEidt,1,0,0,0,0,0,the op of an interlocked instruction is an address the instructions implicitly do an indirection this makes sense because interlocked instructions are fundamentally operands on memory locations however this complicates codegen first because op doesnt hold the type of the memory location see issues the type must either be on the interlocked instruction which is problematic if the node isnt actually producing a value or we must use the type of op which is what is currently done for xarch second because emitter::emitinsbinary expects to see an indirection we create one to pass to that method would probably be better to simply redefine these nodes to take a value i.e an indirection of a memory location instead of an address
265969612,14534,https://api.github.com/repos/dotnet/coreclr/issues/14534,CarolEidt,3,0,0,0,0,0,this is in preparation for tuning these for both throughput and code quality
265890659,14527,https://api.github.com/repos/dotnet/coreclr/issues/14527,stephentoub,1,0,0,0,0,0,timer currently uses a global lock to protect a single queue of timers and any operation to create/change/fire/delete a timer takes that same lock this leads to a scalability problem for code that operates on lots of timers.this change partitions this single queue into n queues which all operate independently in the net framework implementation theres already logically such a split with one queue/lock per appdomain and this change utilizes the same underlying support in the runtime as such contention is distributed across the n locks helping scalability.note that this change does not help the case where a timer fires it could even add a small amount of additional overhead to such a case as there are more likely to be multiple vm callbacks to fire timers one per queue whereas previously thered be just one for all timers however it potentially makes a significant impact to the throughput of creating and deleting timers which we expect to be the common case for high-throughput timers e.g creating a timer to help timeout an operation that will likely complete before the timeout simple repro: c#using system;using system.diagnostics;using system.threading.tasks;using system.threading;class program static void main var tasks new task environment.processorcount while true for int i i tasks.length i tasks i task.run(async for int j j j using var t new timer(delegate null await task.yield var sw stopwatch.startnew task.waitall(tasks console.writeline(sw.elapsed.totalseconds on my quad core with the yield commented out so that creation and disposal will definitely happen from the same thread before this produces results like: ..... whereas after it produces results like: ..... uncommenting the await in order to put the disposal back into the thread pool before: ..... and after: ..... note that all of this was done with the server gc with the workstation gc everything takes a lot longer as allocation/gc becomes more expensive with the await before: ..... and after: ..... i also included two additional commits when a timer does fire were currently queueing a work item that then fires the timer we can instead just queue the timer object directly task.delay currently allocates four objects task timer timerholder timerqueuetimer two of which are wrappers and unnecessary with our internals access this drops it from four to two task timerqueuetimer).fixes kouvel tarekgh vancem jkotasps i purposefully stuck with a change that i thought could be ported to the net framework however given that appdomains arent an issue in net core i think a better longer-term solution would be rewriting timer to be entirely managed potentially with p/invokes if needed rather than having any code in the vm
265883978,14523,https://api.github.com/repos/dotnet/coreclr/issues/14523,CarolEidt,4,0,0,0,0,0,as new instructions have been added for sse and avx the existing encoding tables arent adequately expressive resulting in a great deal of conditional code that impacts throughput this should be refactored both for throughput as well as to avoid complex conditional code that is harder to maintain.this will contribute to the resolution of category:implementationtheme:emitterskill-level:expertcost:medium
265451477,14503,https://api.github.com/repos/dotnet/coreclr/issues/14503,justinvp,1,0,0,0,0,0,make use of the new language support
265446452,14501,https://api.github.com/repos/dotnet/coreclr/issues/14501,briansull,1,0,0,0,0,0,when classifying the size of integer constants use new method fitsin and existing method fitsini
265347596,14493,https://api.github.com/repos/dotnet/coreclr/issues/14493,alpencolt,1,0,0,0,0,0,its possible to build not only arm-target altjit on x-host but armel ryujit now too pass protononjit armel option of build.sh script to specify target platform this option can be also used for other cross builds in future.for running cross-jit execute as:complus_altjit complus_altjitname=libprotononjit.so corerun name of the option is discussable i set it to default values: x armx arm but it may be mandatory for protononjit im afraid that it can break ci so didnt do it.@dotnet/arm-contrib
265335784,14491,https://api.github.com/repos/dotnet/coreclr/issues/14491,AndyAyersMS,1,0,0,0,0,0,we should be verifying that release and checked jits produce the same code.currently this requires some ad-hoc testing we could leverage the information in the jit event stream to automate this the current event stream includes a method length which can be used as a first indicator of diffs it can miss detecting some kinds of diffs but it should work out fairly well contains some ideas for enhancing this to include extra information to further refine detection of diffs.category:correctnesstheme:testingskill-level:intermediatecost:medium
265240042,14490,https://api.github.com/repos/dotnet/coreclr/issues/14490,ashishnegi,1,0,0,0,0,0,hii am trying to debug a crash dump on linux but i am not able to load any symbols.here are the steps i tried i downloaded coreclr symbols from download which are symbols i unzipped symbols.nupkg into a folder with all dbgs in one folder all so files are in folder allso . asnegi@asnegi-vm ryu/ryu/coreclr/runtimes/linux-x/native ls ltotal drwxrwxr-x asnegi asnegi oct allso-rwxrwxrwx asnegi asnegi jul corerun-rwxrwxrwx asnegi asnegi jul corerun.dbg-rwxrwxrwx asnegi asnegi jul createdump-rwxrwxrwx asnegi asnegi jul createdump.dbg-rwxrwxrwx asnegi asnegi oct dotnet..dmp-rwxrwxrwx asnegi asnegi jul ilasm-rwxrwxrwx asnegi asnegi jul ilasm.dbg-rwxrwxrwx asnegi asnegi jul ildasm-rwxrwxrwx asnegi asnegi jul ildasm.dbg-rwxrwxrwx asnegi asnegi jul libclrjit.so.dbg-rwxrwxrwx asnegi asnegi jul libcoreclr.so.dbg-rwxrwxrwx asnegi asnegi jul libcoreclrtraceptprovider.so.dbg-rwxrwxrwx asnegi asnegi jul libdbgshim.so.dbg-rwxrwxrwx asnegi asnegi jul libmscordaccore.so.dbg-rwxrwxrwx asnegi asnegi jul libmscordbi.so.dbg-rwxrwxrwx asnegi asnegi jul libsosplugin.so.dbg-rwxrwxrwx asnegi asnegi jul libsos.so.dbg-rwxrwxrwx asnegi asnegi jul libsystem.globalization.native.a-rwxrwxrwx asnegi asnegi jul sosdocsunix.txt-rwxrwxrwx asnegi asnegi jul system.globalization.native.so.dbg-rwxrwxrwx asnegi asnegi jul system.private.corelib.dll-rwxrwxrwx asnegi asnegi jul system.private.corelib.pdb dump is also present in same folder dotnet..dmp i then start lldb with asnegi@asnegi-vm ryu/ryu/coreclr/runtimes/linux-x/native lldb c dotnet..dmp usr/share/dotnet/dotnet(lldb plugin load allso/libsosplugin.so(lldb setsostid c mapped sos os tid xc to lldb thread index lldb set clrstackambiguous command set possible matches settings setclrpath setsostid(lldb sos clrstackos thread id xc child sp ip call sitegetframecontext failed unknown>(lldb target modules list daabae-cdc-fb-e-bfafb-bdf usr/share/dotnet/dotnet fcf---bf-fbde-dfc lib/x_-linux-gnu/libdl.so lib/x_-linux-gnu/libdl-..so fef-db-c-ca-eefcbb-db lib/x_-linux-gnu/libpthread.so ef-ca-fafd-bdb-dcf-dad usr/lib/x_-linux-gnu/libstdc++.so usr/lib/x_-linux-gnu/libstdc++.so ffad-e-ca-a-ae-aeff lib/x_-linux-gnu/libm.so lib/x_-linux-gnu/libm-..so ae-cd-c-baa-afaae-cff lib/x_-linux-gnu/libgcc_s.so ae-a--f-beb-ddc lib/x_-linux-gnu/libc.so lib/x_-linux-gnu/libc-..so f-f-eb-e-abffb-aea lib/ld-linux-x-.so faecf-ff-c-fec-adace-adcebb usr/share/dotnet/host/fxr/../libhostfxr.so fadde-a--fcd-ffe-aebe usr/share/dotnet/shared/microsoft.netcore.app/../libhostpolicy.so fcaaf-e-e-dab-f usr/share/dotnet/shared/microsoft.netcore.app/../libcoreclr.so fce-f-cae-f-cafedadd-dcaf lib/x_-linux-gnu/librt.so lib/x_-linux-gnu/librt-..so feb-f-e-c-edb-a usr/lib/x_-linux-gnu/libunwind.so bfcf-cea-e-a-ac-cad lib/x_-linux-gnu/libuuid.so ee-ea-a-beb-dcbb-ab usr/lib/x_-linux-gnu/libunwind-x_.so aed--ea-fb-bebc-e lib/x_-linux-gnu/liblzma.so efcf-db-e-cf-aabc-bbdcc usr/share/dotnet/shared/microsoft.netcore.app/../libcoreclrtraceptprovider.so home/asnegi/ryu/ryu/coreclr/runtimes/linux-x/native/./libcoreclrtraceptprovider.so.dbg fb-ad-e-ca-fda-aaac usr/lib/x_-linux-gnu/liblttng-ust.so c-be-cde-ba-bbdeaf-ebce usr/lib/x_-linux-gnu/liblttng-ust-tracepoint.so cf-c--a-bdaa-cfaee usr/lib/x_-linux-gnu/liburcu-bp.so aa-db-c--ab-cbc usr/lib/x_-linux-gnu/liburcu-cds.so fe-b-fcb-cd-afba-adf usr/share/dotnet/shared/microsoft.netcore.app/../libclrjit.so ffacba-b-abc-e-bebbf-eea usr/share/dotnet/shared/microsoft.netcore.app/../system.globalization.native.so abc-cf-b-c-eed usr/lib/x_-linux-gnu/libicuuc.so ecccc-d-efb-a-dccbf-fcadd usr/lib/x_-linux-gnu/libicudata.so afdef-fde-bd-ee-cacbe-fcce usr/lib/x_-linux-gnu/libicuin.so bbece-cc-dcf-a-aaf-ea usr/share/dotnet/shared/microsoft.netcore.app/../system.native.so feb-be-ed-cf-ef-de usr/lib/x_-linux-gnu/libssh.so fa-dfd-bc-ae-cb-dafb lib/x_-linux-gnu/libssl.so daae-bf--dd-bdb-b lib/x_-linux-gnu/libcrypto.so cac-be--be-febb-ab usr/lib/x_-linux-gnu/libxml.so eff--bd-b-dfed-ee lib/x_-linux-gnu/libbz.so bb-f-ba-fb-fdf-bcf lib/x_-linux-gnu/libz.so eb-cc-ab-d-dbda-fda lib/x_-linux-gnu/libgcrypt.so a-fd-aeb-a-cdcdb-ffe lib/x_-linux-gnu/libgpg-error.so cecdf-fa--fe-ed-dbd usr/lib/x_-linux-gnu/libsnappy.so usr/lib/x_-linux-gnu/libsnappy.so dce-df-ba-e-bcbabfd-b usr/lib/x_-linux-gnu/liblz.so usr/lib/x_-linux-gnu/liblz.so fdf-be-af-fc-cdfd-bf lib/x_-linux-gnu/libcgroup.so. observation as you can see libcoreclr.so is at location fcaaf-e-e-dab-f usr/share/dotnet/shared/microsoft.netcore.app/../libcoreclr.so it is not picking unstripped binaries from my current folder i am not able to see any stack.expected it should load symbols from local folder.please tell me the right steps to debug.extra details dotnet version lldb version note i also tried with so and dbg files in same folder with crash_dump
265148685,14481,https://api.github.com/repos/dotnet/coreclr/issues/14481,rartemev,0,0,0,1,0,0,fixed issue the problem was about stack overflow check via probing for enormous frame size rhel uses linux kernel which maps new stack pages just in case they are already allocated using rsp otherwise it produces sigsegv.with the fix additional stack space is being allocated page by page on every iteration it goes over the frame size after probe stack pointer is restored
265138010,14474,https://api.github.com/repos/dotnet/coreclr/issues/14474,AndyAyersMS,1,0,0,0,0,0,the goal of tier is to jit code as quickly as possible currently this is done by having tier enable the minopts mode in the jit which disables all optimization but there are good reasons to believe that running some optimizations in tier can improve the speed of jitting.to first order the time it takes to jit a method especially when lightly optimizing is proportional to the amount of code the jit produces for the method so any cheap optimization that reduces the overall size of the generated code is a candidate for running in tier some ideas enable the importer branch folding enable the early type opts that feed importer branch folding perhaps doubly relevant since rr prejitting will leave generic code to the jit so tier will see more generic instantations then normal and these are the method bodies that often can be greatly simplified by early type opts these opts are also pretty cheap other kinds of simple expression tree simplifications maybe some parts of morph are cheap enough to enable avoid inline expansion of helpers tricky because while this helps jit time it slows down the jitted code but we hope not to run the tier code very often so it seems like it could pay off perhaps inline very small methods i have some older and perhaps flawed data that indicates this should be tp win but recent results havent borne this out but it is worth revisiting certainly inlining small methods often reduces code size and it should cut down on the number of jit invocations.there are notes about this scattered about in other issues will track these down and link them back here.category:throughputtheme:optimizationskill-level:expertcost:medium
265134157,14473,https://api.github.com/repos/dotnet/coreclr/issues/14473,AndyAyersMS,3,0,0,0,0,0,unbox.any gets optimized if it is immediately preceded by a box to the same type we ought to be able to check for other sources of type information and perhaps do similar optimizations.effectively wed call gtgetclasshandle on the input operand and if we had an exact result wed be able to remove the type test and manifest the unbox as a copy.category:cqtheme:importerskill-level:expertcost:small
265133719,14472,https://api.github.com/repos/dotnet/coreclr/issues/14472,AndyAyersMS,4,0,0,0,0,0,a fairly common pattern especially after inlining is to see a box that feeds an isinst and if that succeeds an unbox.any for example: c#using system;using system.collections.generic;using system.runtime.compilerservices;internal class objectequalitycomparer
265133369,14471,https://api.github.com/repos/dotnet/coreclr/issues/14471,AndyAyersMS,2,0,0,0,0,0,will optimize sucessful isinst(x or castclass(x to be simply x however the successful cast may give us better type information about x than we had before and right now we lose that information.we attempt this type improvement for some of the unoptimized cases when the result is produced in a temp see the last few lines of impcastclassorisinsttotree however blindly setting the type to the cast type may not always be better for instance casting from a known class to an interface type isnt really providing much in the way of useful information.so we should only do this sort of thing when the target type is a class and weve cast from supertype to subtype or from an interface to a class type.category:cqtheme:importerskill-level:expertcost:small
265074372,14462,https://api.github.com/repos/dotnet/coreclr/issues/14462,vancem,4,0,0,0,0,0,there is a hot lock in system.threading.timerqueuetimer that shows up when people use alot of timeouts or task.delays below is a simple program that causes tasks to be each delaying seconds in msec the program keeps cores at cpu and over half of that is in contention on the one lock in system.threading.timerqueuetimer in the change close and fire methods)name--module coreclr coreclr!jit_monenterworker_inlinegetthread_getthread_patchlabel system.private.corelib!timerqueuetimer.change system.private.corelib!system.threading.timerqueuetimer.close system.private.corelib!system.threading.timerqueuetimer.fire()thus this lock can get hot we have seen this in a variety of scenarios mostly in cases where we have many cpus e.g or and thus have many outstanding delays note that we dont actually have problem with the data structure it is o(n where every time a timer fires but not when it is canceled the problem is simply the scalability the fact that we have one lock using system;using system.threading.tasks;namespace timerscalability class program static void main(string args console.writeline(starting running tasks that each delay second msec at a time task tasks new task for(int i i tasks.length i tasks i task.factory.startnew(taskbody console.writeline(waiting task.whenall(tasks).wait console.writeline(done static async task taskbody console.writeline(task starting task.currentid for int i i i await task.delay console.writeline(task done task.currentid
265059533,14460,https://api.github.com/repos/dotnet/coreclr/issues/14460,morganbr,1,0,0,0,0,0,one of the valuable aspects of spanlpbuffer); would marshal the spans underlying pointer pinning as necessary reverse interop is a bit trickier for example the native signature of heapalloc is: lpvoid winapi heapalloc(_in handle hheap in dword dwflags in size_t dwbytes); if we wanted a span wrapping the returned pointer an ideal p/invoke would look like: static extern span
265057325,14458,https://api.github.com/repos/dotnet/coreclr/issues/14458,AndyAyersMS,1,0,0,0,0,0,there is already some diversity in jit codegen for instance the jit can be instructed or may on its own decide whether to generate optimized or minimally optimized code or use avx/sse and certain hw instructions or to enable vector codegen etc.this diversity is about to increase substantially with the advent of fine-grained hw intrinsics and tiering.for diagnostic purposes it would be useful to know key attributes of the code the jit generated for each method for instance which target-specific triggers that is which issupported intrinsics were encountered during codegen and how they evaluated could be tri state yes/no/maybe depending on where we end up with evaluation of these when prejitting what codegen mode the jit used for the method minops debug tier fullopt what codegen mode was requested by the vm some kind of hw checksum to fingerprint the generated native code maybe via some abstracted isa representation to avoid being overly sensitive on absolute or relative address literals though there is also some merit in being able to use the checksum to re-validate existing code whether some out-of-band signal eg complus setting influenced jit behavior whether the method was optimized with ibc and if so whether it was classified as hot/cold if prejitted whether prejitting was fragile or used rr codegen this is perhaps available by looking back at the module load event if jitted what triggered jitting was it multicore jit tiering preparemethod method call etc.we have a subset of this now but it is not comprehensive.having this would make it easier to verify that the jit generates the intended kinds of code.the fingerprinting could come in handy for quick automated diff testing that would work in release or as part of an automated diagnostics package for root-causing correctness or performance regressions we can do some of this now with the method size information but a hash would be more collision-proof.cc noahfalk category:proposaltheme:runtimeskill-level:intermediatecost:medium
265036490,14456,https://api.github.com/repos/dotnet/coreclr/issues/14456,fiigii,1,0,0,2,0,0,"implement crc popcnt lzcnt intrinsics these three intrinsics have ulong / long overloads that generate bit rex prefixed instructions so calling to these bit intrinsic should be guarded by environment.isbitprocess as well as issupported otherwise the runtime would throw platformnotsupportedexception . csharpif sse.issupported environment.isbitprocess ulong res sse.crc(longnum,longnum this pr implements throwing platformnotsupportedexception when calling an intrinsic on improper hardware for all the hardware intrinsics"
264767033,14438,https://api.github.com/repos/dotnet/coreclr/issues/14438,wtgodbe,1,0,0,0,0,0,this fixes the following issues index.json publishing since only index.json gets published per blob and our intermediate blobs publish binaries for release checked and debug we want to make sure that only the release build publishes the index.json without this change there is a race condition and the build will only pass if release wins sync.cmd in symbol publish we needed to update this for the new intermediate blob structure forgot to port this from the test branch sync.cmd in publish the working directory wasnt set.@karajas ptal
264693399,14435,https://api.github.com/repos/dotnet/coreclr/issues/14435,swgillespie,0,0,0,1,0,0,rendered view pr introduces a design document for the process of loading and initializing a standalone gc it is styled after the way that the jit loads standalone jits and it does not deviate much from the prior art.design reviews and comments greatly appreciated
264472478,14420,https://api.github.com/repos/dotnet/coreclr/issues/14420,AndyAyersMS,1,0,0,0,0,0,work in progress pr to get some broader testing
264167834,14404,https://api.github.com/repos/dotnet/coreclr/issues/14404,parjong,1,0,0,0,0,0,this commit allows developers to build s.p.corelib.dll without building sos.netcore.dll via running the following command build.cmd arch release windowsmscorlib p:skipsos=true
263994245,14393,https://api.github.com/repos/dotnet/coreclr/issues/14393,mikedn,1,0,0,0,0,0,remove the need to allocate a temp register to hold the bit mask required by floating point neg/abs so we can generate: asmce vxorps xmm xmmword ptr reloc rwd instead of asmceadc vmovss xmm dword ptr reloc rwd cec vxorps xmm xmm this requires emitter support to generate byte aligned constants
263836822,14388,https://api.github.com/repos/dotnet/coreclr/issues/14388,xoofx,1,0,0,0,0,2,currently with structlayout we can define both the size via size field and the field packing via pack field unfortunately it doesnt cover the case in c where you can have an alignment attribute directly on the struct that indicates how this struct should be aligned when used for example in another struct.this is actually quite a limitation when for example you want to have a struct that maps to a vector simd intrinsic as their natural alignment is usually not the alignment of the component for a vectorf the align of this struct in c would be sizeof(float while it would be xsizeof(float for the intrinsic.this could also help in regular interop scenarios where this align attribute is actually specified on the c struct note as this is an api change but most of the work would be in coreclr not sure if this is the right place to post this instead of corefx let me know if you can move it there structlayout.align the proposal is to add a new property align on structlayout : c public sealed class structlayoutattribute attribute public int align by default the alignment is meaning that it will take the natural alignment of the struct which is the default today otherwise it will take the alignment specified by this field.cc jkotas caroleidt
263657250,14381,https://api.github.com/repos/dotnet/coreclr/issues/14381,AndyAyersMS,2,0,0,0,0,0,handle cases where a gettype call on a generically typed objectfeeds into a type equality comparison.these calls have constraint prefixes for value classes the constrainttells us the type and so we can avoid the box and call and just constructthat type directly for ref classes the type test can usually reduce toa method table comparison.also handle cases that arise in prejiited code better by generalizinghow the jit looks for class handles from type construction trees.added test cases.closes
263510822,14360,https://api.github.com/repos/dotnet/coreclr/issues/14360,Petermarcu,1,0,0,0,0,0,we get a lot of feedback that people have trouble figuring out the right dependencies to install in order to run their self contained applications in some cases including the binary or static linking is not a good choice but in others it may be a fine choice we need to make some progress here and get down to just a few easy to identify and high level dependencies other than the experience of getting the dependencies many of them contribute some size to our docker images so if we can link away some of it that would be another benefit.here is an example issue isnt specific to coreclr it also needs to happen in corefx but i think the static linking option is more relevant to coreclr
263338789,14353,https://api.github.com/repos/dotnet/coreclr/issues/14353,BruceForstall,2,0,0,0,0,0,fix propagate gtf_except bits from the end of gt_field_list lists to the beginning to avoid missing flags on tree asserts.fix for ryujit/arm gt_bitcast needs to be a multiregop.this is required when a varargs function which includes the tailcallhelper needs to pass a double in integer registers we can end upwith gt_putarg_reg/long(gt_bitcast/long(double tree)) .fixed various gentree node flags dumping issues
263302479,14350,https://api.github.com/repos/dotnet/coreclr/issues/14350,CarolEidt,3,0,0,0,0,0,these are preparatory changes for eliminating gtlsrainfo.register requirements should never be set on contained nodes this includes setting isdelayfree and restricting to byte registers for x this results in net positive diffs for the framework eliminating incorrect setting of hasdelayfreesrc though a net regression for the tests on x including many instances of effectively the same code the regressions are largely related to issue improve consistency of isvalue any node that can be contained should produce a value and have a type e.g gt_field_list some value nodes gtk_novalue isnt set are allowed to have typ_void in which case isvalue should return false this simplifies isvalue any node that can be assigned a register should return true for isvalue e.g gt_lockadd putarg_stk doesnt produce a value get type from its operand this requires some fixing up of simd operands unused gt_long nodes shouldnt define any registerseliminate isnoregcompare by setting type of jtrue operand to typ_void set gtf_set_flags on the operand to ensure it is not eliminated as dead code
262974712,14332,https://api.github.com/repos/dotnet/coreclr/issues/14332,sdmaclea,2,0,0,0,0,0,jashook please assign this to me i will start looking at this tomorrow.cc dotnet/arm-contrib dotnet/jit-contrib
262826106,14320,https://api.github.com/repos/dotnet/coreclr/issues/14320,jkotas,1,0,0,0,0,0,isascii needs to enumerate the whole string to check the chars and then caches the result so it can be actually slowing things down in situations where were only going to be operating on a string once which is probably fairly common
262687536,14317,https://api.github.com/repos/dotnet/coreclr/issues/14317,AndyAyersMS,1,0,0,0,0,0,handle some type equality cases we couldnt get previously involving runtime lookups.not ready for merging just yet but want to get some test exposure
262541039,14307,https://api.github.com/repos/dotnet/coreclr/issues/14307,fiigii,0,0,0,1,0,0,see discussion in for details
262533497,14305,https://api.github.com/repos/dotnet/coreclr/issues/14305,AndyAyersMS,5,0,0,0,0,0,to better support high-level optimizations it makes sense to try and defer or encapsulate some of the more complex runtime lowerings in the jit ir here are some thoughts on the matter.motivations high-level optimizations would prefer to see logical operators even if complex rather than a complex tree or tree sequence many times these operators become dead and cleaning up after them can be complex if theyve been expanded sometimes these operators can be abstractly simplified if they are partially dead for instance a box used only to feed a type test can become a type lookup properties of these operators are not always evident from their expansions and the expansions can vary considerably making reparsing within the jit to recover information lost during expansion problematic often of these operators have nice properties invariant nonfaulting and would be good candidates for hoisting but their complex shape makes this difficult/costly often the equivalence of two such operators can be stated rather simply as equivalence of some abstract inputs making cse/value numbering simple.possible candidates for this kind of encapsulation include runtime lookup static field access box already semi-encapsulated unbox cast/isint allocation already encapsulated class initializationthe downside to encapsulation is that the subsequent expansion is context dependent the jit would have to ensure that it could retain all the necessary bits of context so it could query the runtime when it is time to actually expand the operation this becomes complicated when these runtime operators are created during inlining as sometimes inlining must be abandoned when the runtime operator expansions become complex so it could be this approach becomes somewhat costly in space given the amount of retained context per operator or in time since we likely must simulate enough of the expansion during inlining to see if problematic cases arise).wed also have more kinds of operations flowing around in the ir and would need to decide when to remove/expand them this can be done organically removing the operations just after the last point at which some optimization is able to reason about them initially perhaps theyd all vanish after inlining or we could repurpose the object allocation lowering to become a more general runtime lowering.instead of full encapsulation we might consider relying initially on partial encapsulation like we do now for box introduce a thin unary encapsulation wrapper over a fully expanded tree that identifies the tree as an instance of some particular runtime operation and possibly as in box keeping tabs on related upstream statements with enough information to identify the key properties expansion would be simple the wrapper would disappear at a suitable downstream phase simply replaced by its content these thin wrappers would not need to capture all the context but just add a small amount of additional state current logic for abandoning inlines in the face of complex expansion would apply so no new logic would be needed.as opportunities arise we can then gradually convert the thin wrappers to full encapsulations most upstream logic should not care that much since presumably the expanded subtrees once built do not play any significant role in high-level optimization so their creation could be deferred.so im tempted to say that thin encapsulation gives us the right set of tradeoffs and start building upon that the likely first target is the runtime lookups feeding type equality and eventually type cast operations then probably static field accesses feeding devirtualization opportunities.if youre curious what this would look like heres a prototype master..andyayersms:wrapruntimelookup heres an example using the prototype in this case the lookup tree is split off into an earlier statement but at the point of use we can still see some information about what type the tree intends to look up a new jit interface call not present in the fork above can use this to determine if the types are possibly equal or not equal even with runtime lookups for one or both inputs. fgmorphtree bb stmt before c-g jtrue void cns_int int c-g eq int c-g call int system.type.op_equality c-g arg call help ref helper.corinfo_help_typehandle_to_runtimetype arg runtimelookup long xffcc class lcl_var long v loc c-g arg call help ref helper.corinfo_help_typehandle_to_runtimetype arg cns_int(h long xffcc class by default the wrapper just evaporates in morph: optimizing call to type:op_equality to simple compare via eqoptimizing compare of types-from-handles to instead compare handlesfgmorphtree bb stmt after g jtrue void cns_int(h long xffcc class j----+-n ne int lcl_var long v loc but in morph and upstream it can be used to trigger new optimizations.category:implementationtheme:irskill-level:expertcost:medium
262434930,14297,https://api.github.com/repos/dotnet/coreclr/issues/14297,migueldeicaza,16,2,0,0,1,0,"while we love to make fun of our java brothers for their naming conventions out of lack of support our community has resorted to rolling a spectrum of dependency injection frameworks mocking frameworks and developers find themselves over and over writing boilerplate code or consuming large libraries that use di and other unpleasant approaches that make it difficult to follow the code.this is an issue based on a public twitter discussion a few weeks/months ago.the idea is that the runtime should provide a mechanism by which developers could swap out individual implementations of classes and possibly even individual methods either via an external configuration option or at runtime.this would allow developers to hardcode things that today are left to assorted meta-runtimes built as libraries sweat and despair.for example dotnet run remap:system.console=mylibrary.dll,miguel.console dotnet run remap:system.net.httpclient=mybetterlibrary.dll,mybetterhttp.httpclient this support could also be surfaced at runtime so for any classes that have yet to be loaded we could perform the swapping: using system.net;class demo static void main assembly a assembly.loadfrom mybetterhttpclient.dll var newhttpclient a.gettype verifiedhttpclient runtimeservices.swap typeof httpclient newhttpclient davidfowl"
262230416,14287,https://api.github.com/repos/dotnet/coreclr/issues/14287,tannergooding,1,0,0,1,0,0,fyi josephtremoulet andyayersms viktorhofer danmosemsft new fastest implementation at this point im pretty certain the only reason it isnt even faster is because the q processor the official benches use likely doesnt support the optimization where movups is as fast as movaps it looks like that optimization was added in the subsequent microarchitecture
262150134,14283,https://api.github.com/repos/dotnet/coreclr/issues/14283,stephentoub,1,0,0,0,0,0,on misconfigured systems getsystemtimepreciseasfiletime may drift quickly from getsystemtimeasfiletime we want to use the former though as a workaround/heuristic when checking whether we have getsystemtimepreciseasfiletime invoke both and ensure theyre close falling back to getsystemtimeasfiletime if it seems like the precise variant has run away.closes vancem jkotas
262101953,14282,https://api.github.com/repos/dotnet/coreclr/issues/14282,janvorli,1,0,0,0,0,0,the latest xcode cannot successfully build coreclr pal there areseveral issues first it complains that min max macros cannot be definedin c code since they would collide with the std::min and std::maxfunctions second some of the headers that pal includes pull in declarationsof several template classes that we explicitly define in pal and alsothe new operator declaration.to fix that i have undefined the min and max macros for pal and replacedtheir usage by the std::min max functions i have also removed the manualdeclaration of the colliding template classes and new operator and addedinclusion of the proper c headers instead.the pal was including non-pal safemath.h and to make this change compatible with it i have added definition of use_stl that makes safemath.h include type_trait from stl instead of our local trimmed copy.i have also removed some dead code that i have discovered during the process.fixes
261799172,14272,https://api.github.com/repos/dotnet/coreclr/issues/14272,ahsonkhan,1,0,0,0,0,0,cc jkotas andyayersms from andy if you are building with you may need this patch c folks elevated to on by default apparently a windows ask but older sdks have the bad pattern
261737251,14263,https://api.github.com/repos/dotnet/coreclr/issues/14263,fir3pho3nixx,3,0,0,0,0,0,hiis this the right repo to expose assembly versioning/binding issues if you can help me redirect that would be amazing i just think the versioning madness needs some exposure with your teams and i am trying to help at the moment we are publishing packages in castle.core where we have gone with a major version only strategy using the assemblyversionattribute the reason we are doing this is because we have heaps of users on our issue tracker complaining about transitive dependencies where castle.core is used for arguments sake by frameworks like moq where upgrades are chucking up assembly binding errors they sometimes make the mistake of making castle.core an explicit dependency granted we try steer them in the right direction however i would like to know what is happening inside the clr to sort this out as we are hacking our way through the sdk to sort this can you please advise on this it is a big problem for the open source community many thanks
261684403,14256,https://api.github.com/repos/dotnet/coreclr/issues/14256,AndyAyersMS,2,0,0,0,0,0,if the jit sees a successful type equality check where one of the two types being compared is known to the jit subsequent operations should be able leverage the fact that the other type is now known too.example thanks to ilexp: c#using system;using system.runtime.compilerservices;public struct genericstruct
261456768,14244,https://api.github.com/repos/dotnet/coreclr/issues/14244,AndyAyersMS,6,0,0,0,0,0,refactor the type equality optimizations embedded in morph so that they canalso be invoked earlier in particular during importation this allows theimporter to short-circut importing blocks that are provably unreachable forinstance in generic methods with type specialization via equality the jitwill now selectively import just the applicable regions of the method in somecases this means the jit may avoid importing eh regions and so remove eh froma specialized method all together.also generalize the handle compare pattern to look through the handle indirsthat can arise when prejitting.running the type opts early also improves jit throughput a little
261247310,14237,https://api.github.com/repos/dotnet/coreclr/issues/14237,SeriousM,3,0,0,0,0,0,hi i dont know where i should put this questions to get qualified opinions and answers so i put it into this issue board if this was wrong im very sorry.with microsofts research project pex the assembly microsoft.extendedreflection was created to wrap the native clrprofiler with managed code to get the callback hooks into managed net code.microsoft ships a current version vith vs c:\program files x)\microsoft visual studio\\enterprise\common\ide\extensions\microsoft\pex\microsoft.extendedreflection.dll so i assume that the work on microsoft.extendedreflection is not stopped yet.ive seen that coreclr profiler is getting some attention and im curious if there will be a new version of microsoft.extendedreflection for coreclr profiler or even getting support for it?beside of that could someone please help me to get some documentation on microsoft.extendedreflection or at least the xml files the current available documentation is either very outdated or not available at all for the latest version.thank you all very much
261064201,14225,https://api.github.com/repos/dotnet/coreclr/issues/14225,fiigii,1,0,0,0,0,0,this codegen issue was detected from sqrtdouble and sqrtsinge benchmarks of a hot loop in sqrtdouble shows the second operand of vsqrtsd always set to xmm the default value of vex.vvvv in ryujit). asmblock vaddsd xmm xmm qword ptr rip+xd vsqrtsd xmm xmm xmm xmm is not allocated to vsqrtsdvaddsd xmm xmm xmminc edicmp edi xjl xfcbfefe block this codegen introduces false register dependency on xmm that causes obviously higher cpi meanwhile we recommend that keep the second operand same as the third one rather than same as the destination for this kind of instructions code execution time vsqrtsd dst xmm src s vsqrtsd dst dst src s vsqrtsd dst src src s the codegen after this change asmblock vaddsd xmm xmm qword ptr rip+xd vsqrtsd xmm xmm xmmvaddsd xmm xmm xmminc edicmp edi xjl xfecdaab block
261055397,14223,https://api.github.com/repos/dotnet/coreclr/issues/14223,AndyAyersMS,3,0,0,0,0,0,the changes for devirtualizing the equalitycomparer.default calls dont kick in in cases where the user can optionally supply a custom comparer see for instance dictionary
261031158,14221,https://api.github.com/repos/dotnet/coreclr/issues/14221,kbaladurin,1,0,0,0,0,0,fix typo in setdebuggerregdisplayfromregdisplay esi eax
260833290,14214,https://api.github.com/repos/dotnet/coreclr/issues/14214,stephentoub,1,0,0,0,0,0,contributes to kouvel tarekgh benaadams geoffkizer
260810798,14208,https://api.github.com/repos/dotnet/coreclr/issues/14208,vancem,11,0,0,2,0,2,it has been noted that for some applications notably applications like msbuild or visual studio that manipulate many file paths or deserialize large text-based payloads e.g json or xml tend to have many duplicated strings we could reduce the size of the gc heap by interning them that is using the same string for all instances of a particular string value the runtime already does this for string literals but strings that are constructed at runtime do not benefit to implement this you need a table that remembers all the existing strings that is indexed by string value while you could do this table lookup check when strings are first created this is not likely to be a good approach because many strings have very short lifetimes and it would slow down all strings creation instead the idea is to do the interning check when as part of promoting the object from gc generation to gc generation this is a nice place to do it because most strings die before reaching gen however if they do make it they are expensive strings in that they are likely to live a long time thus it makes sense to de-dup at that pointanother nice aspect of this feature is that it does not need to be perfect you dont have to dedup everything thus the hash table you keep can be of fixed size with replace on collision semantics which is simple and bounded and tends to favor younger strings all good things the expectation is that typical apps have of their gc heap be strings some measurements we have seen is that for at least some applications of strings all may be duplicated so this might save of the gc heap not huge but the feature is not that difficult either the first step to build enough of a prototype so that we can run it on a number of interesting apps and get a feel for how much gc space would save us and how much overhead this would add to gen and gen gcs
260434213,14178,https://api.github.com/repos/dotnet/coreclr/issues/14178,stephentoub,3,0,0,7,0,0,previously when a task-returning async method would yield for the first time there would be four allocations the task the state machine object boxed to the heap a context runner object and a delegate that points to the boxed state machines movenext method a recent pr changed this to avoid the separate box object and the runner but that still left the task and the delegate.this pr avoids the delegate as well in a common case for async methods that only ever await task/task that arent using a custom sync context/scheduler and for which tracing isnt enabled we know the inner workings of both the builder and the awaiter and can thus bypass the awaiters pattern apis instead of creating the delegate that gets passed to the awaiter and then stored in the wrapped tasks continuation slot/list we can instead just store the boxed state machine directly in the slot/list as a simple example just to highlight the allocation difference: c#using system;using system.threading;using system.threading.tasks;class program static async task main for int i i i await somemethod static async task somemethod await task.run thread.sleep before:! image kouvel tarekgh jkotas@andyayersms i had to workaround and and the workaround for isnt stellar so ill be happy to undo it once that issue is addressed.@benaadams itd be good to know if/how this affects your scenarios
260425544,14177,https://api.github.com/repos/dotnet/coreclr/issues/14177,stephentoub,2,0,0,0,0,0,"consider: c#using system;class program static void main foo static void foo(t input if typeof(t typeof(int console.writeline(((int)(object)input).tostring else try console.writeline(else catch exception e console.writeline(e the jitdisasm for foo is: g_m_ig push rbp push rsi ec sub rsp dc lea rbp rsp+h f mov qword ptr rbp-h rsp bf mov esi ecxg_m_ig eaabfdff call system.globalization.numberformatinfo:get_currentinfo():ref cbc mov r rax bce mov ecx esi d xor rdx rdx eaedf call system.number:formatint(int,ref,ref):ref bc mov rcx rax eefcffff call system.console:writeline(ref nopg_m_ig df lea rsp rbp-h e pop rsi d pop rbp c retg_m_ig cc intg_m_ig df lea rsp rbp-h e pop rsi d pop rbp c retg_m_ig push rbp push rsi ec sub rsp b mov rbp qword ptr rcx c mov qword ptr rsp+h rbp dd lea rbp rbp+h g_m_ig bca mov rcx rdx efbfbffff call system.console:writeline(ref ddffffff lea rax g_m_igg_m_ig c add rsp e pop rsi d pop rbp c ret but if i remove the try/catch and just leave the console.writeline from the try block: c#using system;class program static void main foo static void foo(t input if typeof(t typeof(int console.writeline(((int)(object)input).tostring else console.writeline(else the else is removed as expected: g_m_ig push rsi ec sub rsp bf mov esi ecxg_m_ig ebbfdff call system.globalization.numberformatinfo:get_currentinfo():ref cbc mov r rax bce mov ecx esi d xor rdx rdx ebaf call system.number:formatint(int,ref,ref):ref bc mov rcx rax efcffff call system.console:writeline(ref nopg_m_ig c add rsp e pop rsi c ret this is also impacting the ability for foo to be inlined i.e even with aggressiveinlining it wont be inlined if the try/catch exists in the else branch.cc andyayersms category:cqtheme:flowgraphskill-level:intermediatecost:small"
260327628,14174,https://api.github.com/repos/dotnet/coreclr/issues/14174,AndyAyersMS,1,0,0,0,0,0,a couple of ideas that might improve throughput when inlining.during inlining the jit must walk the arguments to the original call and determine how to propagate the values into the inline body doing this entails some case analysis depending on the shape of the arg tree and the kinds of uses in the arg in the inlinee body.when call arguments are the return values from inlined calls the jit will see gt_ret_expr placeholder nodes these placeholders have conservative side effect flags and obscure the shape of the arg tree the inliner could walk back through these nodes to the actual tree and use that tree instead for example: c#int r return int x(int val int y x(r this would apply when inlining x into y .a similar thing might be possible earlier when importing x to be inlined if th;e jit tunnels through the return placeholders it could directly substitute r s return value into the body of x .a likely way to catch both of these cases is to revise the inlarginfo for an inlinee when the argnode is a gt_ret_expr
260069413,14160,https://api.github.com/repos/dotnet/coreclr/issues/14160,tannergooding,1,0,0,0,0,0,this is still a wip but this is meant to give an overview of ieee binary floating-point arithmetic.the sections that are there are essentially done minus any formatting/spelling errors i introduced).im working on detailing the operations and recommended operations sections next these detail handling of specific inputs for the available operations.the other sections exception handling expression evaluation and reproducible results are less important but i will be working on filling those in as well
259867177,14139,https://api.github.com/repos/dotnet/coreclr/issues/14139,sdmaclea,1,0,0,0,0,0,this adds the emitters and runtime code necessary to generate tbz tbnz cbz and cbnz it does not yet adjust code generation.i had a previous change which also implemented code generation but it needed rework this code was tested with that change and is passing of tests it seems best to start reviewing this separately as it is orthogonal.depending on time frame i may amend this change with the lowering/codegen piece but i would prefer merging this first to keep them independent.@briansull this is the type of code you reviewed for me in the past ptal.cc dotnet/arm-contrib dotnet/jit-contrib
259700399,14134,https://api.github.com/repos/dotnet/coreclr/issues/14134,tannergooding,2,0,0,0,0,0,sse added the roundss and roundsd instructions for machines which support them we should support emitting them for the round ceiling and floor methods in system.math and system.mathf
259655170,14125,https://api.github.com/repos/dotnet/coreclr/issues/14125,AndyAyersMS,10,0,0,0,0,2,mark equalitycomparer.default s getter as intrinsic sothe jit knows there is something special about it extend the jitsnamed intrinsic recognizer to recognize this method.add a new jit interface method to determine the exact type returnedby equalitycomparer.default given t compute the return type bymirroring the logic used in the actual implementation.invoke this interface method when trying to devirtualize calls wherethe this object in the call comes from equalitycomparer.default .handle both the early and late devirtualization possibilties.the devirtualized method can then be inlined if devirtualizationhappens early inlining uses the normal jit heuristics here.closes
259652482,14122,https://api.github.com/repos/dotnet/coreclr/issues/14122,erozenfeld,3,0,0,0,0,0,"the jit currently doesnt emit bswap instructions we could add recognition of byte swap pattern to morph similar to what we do for rotation).this came up in e.g., public static uint reverseendianness(uint value return value xffu value xffu value xffu value xffu category:cqtheme:basic-cqskill-level:intermediatecost:small"
259622738,14119,https://api.github.com/repos/dotnet/coreclr/issues/14119,tannergooding,1,0,0,0,0,0,this splits system.math and system.mathf into partial classes so that parts of the code can be shared with corert.the changes on the native side are comdouble and comsingle now export a fmod function which wraps fmod comdouble and comsingle now export a modf function which matches the native signature comdouble and comsingle no longer export a round functionthe changes on the managed side are a few more aggressiveinlining attributes to match corert round is now implemented in managed code roundinternal is directly inlined now truncate calls a new modf private function rather than internaltruncate which itself called splitfraction copysign is a new private function directly implemented in managed code this supports round )everything else is just moving the types around between the files or non functional changes such as adding braces that were previously missing using a ternary expression instead of if/else when we are selecting between two return values using the keyword rather than full type name this seems to be the more common and recommended behavior
259335151,14107,https://api.github.com/repos/dotnet/coreclr/issues/14107,sdmaclea,1,0,0,0,0,0,dotnet/jit-contrib dotnet/arm-contrib ptal
259322123,14101,https://api.github.com/repos/dotnet/coreclr/issues/14101,sdmaclea,1,0,0,0,0,0,mikedn dotnet/arm-contrib
259269181,14096,https://api.github.com/repos/dotnet/coreclr/issues/14096,mikem8361,0,0,0,1,0,0,update build scripts docs and build pipeline docker images to clang/llvm/lldb
258927925,14065,https://api.github.com/repos/dotnet/coreclr/issues/14065,fiigii,1,0,0,0,0,0,currently ryujit generates avx instructions vex-encoding when avx is available floating-point calculations and simd code use vex-encoding instructions on avx-capable machines haswell and above simd vectors system.numerics.vector
258347523,14033,https://api.github.com/repos/dotnet/coreclr/issues/14033,sam-piper,1,0,0,0,0,0,"weve recently ported our asp.net core application running on net framework to use net core and we are seeing critical failures in our kestrel logs now like this: assert failureexpression recursive resource lookup bug application is shutting down...description infinite recursion during resource lookup within system.private.corelib this may be a bug in system.private.corelib or potentially in certain extensibility points such as assembly resolve events or cultureinfo names resource name argumentnull_genericstack trace at system.sr.internalgetresourcestring(string key at system.sr.getresourcestring(string resourcekey string defaultstring at system.argumentnullexception..ctor(string paramname at system.runtime.loader.assemblyloadcontext.getloadcontext(assembly assembly at system.reflection.assembly.loadfromresolvehandler(object sender resolveeventargs args at system.appdomain.onassemblyresolveevent(runtimeassembly assembly string assemblyfullname at system.reflection.runtimeassembly._nload(assemblyname filename string codebase evidence assemblysecurity runtimeassembly locationhint stackcrawlmark stackmark intptr pprivhostbinder boolean throwonfilenotfound boolean forintrospection boolean suppresssecuritychecks intptr ptrloadcontextbinder at system.reflection.runtimeassembly.internalgetsatelliteassembly(string name cultureinfo culture version version boolean throwonfilenotfound stackcrawlmark stackmark at system.resources.manifestbasedresourcegroveler.getsatelliteassembly(cultureinfo lookforculture stackcrawlmark stackmark at system.resources.manifestbasedresourcegroveler.grovelforresourceset(cultureinfo culture dictionary localresourcesets boolean tryparents boolean createifnotexists stackcrawlmark stackmark at system.resources.resourcemanager.internalgetresourceset(cultureinfo requestedculture boolean createifnotexists boolean tryparents stackcrawlmark stackmark at system.resources.resourcemanager.internalgetresourceset(cultureinfo culture boolean createifnotexists boolean tryparents at system.resources.resourcemanager.getstring(string name cultureinfo culture at system.sr.internalgetresourcestring(string key at system.sr.getresourcestring(string resourcekey string defaultstring at system.argumentnullexception..ctor(string paramname at system.runtime.loader.assemblyloadcontext.getloadcontext(assembly assembly at system.reflection.assembly.loadfromresolvehandler(object sender resolveeventargs args at system.appdomain.onassemblyresolveevent(runtimeassembly assembly string assemblyfullname at system.reflection.runtimeassembly._nload(assemblyname filename string codebase evidence assemblysecurity runtimeassembly locationhint stackcrawlmark stackmark intptr pprivhostbinder boolean throwonfilenotfound boolean forintrospection boolean suppresssecuritychecks intptr ptrloadcontextbinder at system.reflection.runtimeassembly.internalgetsatelliteassembly(string name cultureinfo culture version version boolean throwonfilenotfound stackcrawlmark stackmark at system.resources.manifestbasedresourcegroveler.getsatelliteassembly(cultureinfo lookforculture stackcrawlmark stackmark at system.resources.manifestbasedresourcegroveler.grovelforresourceset(cultureinfo culture dictionary localresourcesets boolean tryparents boolean createifnotexists stackcrawlmark stackmark at system.resources.resourcemanager.internalgetresourceset(cultureinfo requestedculture boolean createifnotexists boolean tryparents stackcrawlmark stackmark at system.resources.resourcemanager.internalgetresourceset(cultureinfo culture boolean createifnotexists boolean tryparents at system.resources.resourcemanager.getstring(string name cultureinfo culture at system.sr.internalgetresourcestring(string key at system.sr.getresourcestring(string resourcekey string defaultstring at system.threading.tasks.taskcanceledexception..ctor(task task at system.runtime.compilerservices.taskawaiter.throwfornonsuccess(task task at system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task task) we are using en-au as our default culture this stack trace appears to identify a known issue that has been resolved but not released dotnet/coreclr/issues however none of the following proposed workarounds in that issue and related issue worked for us adding new argumentexception into the main method of program.cs before creating a webhost changing the os culture to united states or setting currentuiculture to en-us.will there be a service release to fix this issue any idea when that release will be available is there a pre-release build available that i could use to see if the issue is resolved in that build even though not released yet?)thanks,sam"
258164447,14022,https://api.github.com/repos/dotnet/coreclr/issues/14022,AndyAyersMS,6,0,0,0,0,0,dictionary
257950518,14007,https://api.github.com/repos/dotnet/coreclr/issues/14007,pavrosa,2,0,0,0,0,0,since the installed of a windows update on we have problems creating certain structs in our release builds see relevant issue reported on stackoverflow
257825705,13985,https://api.github.com/repos/dotnet/coreclr/issues/13985,kouvel,1,0,0,0,0,0,apply prs that fix the following monitor spinning issues depends on evaluate applying as well if its found to be useful on a case-by-case basis
257557184,13965,https://api.github.com/repos/dotnet/coreclr/issues/13965,CarolEidt,1,0,0,0,0,0,fix
257502640,13953,https://api.github.com/repos/dotnet/coreclr/issues/13953,AndyAyersMS,1,0,0,0,0,0,an indir in the runtime lookup sequence wasnt marked as nonfaultingso dead context trees could not be entirely cleaned up.also added invariant since this particular lookup sequence will alwaysreturn the same result
257164180,13923,https://api.github.com/repos/dotnet/coreclr/issues/13923,sdmaclea,1,0,0,0,0,0,fixes
257163974,13922,https://api.github.com/repos/dotnet/coreclr/issues/13922,janvorli,0,0,0,3,0,0,this change fixes a bug that causes crashes when secure delegate isinvoked on arm with legacy codegen register r was loaded withindirection slot address and not locked so the jit compiler reused it before the call that was supposed to have that value in r.the fix was to lock the register after it was loaded with the indirection slotand unlock it after the call.there was also an incorrect marking of that address as ea_ptrsizewhile it should be ea_byref so ive fixed that too
257161867,13921,https://api.github.com/repos/dotnet/coreclr/issues/13921,kouvel,1,0,0,0,0,0,closes unfairsemaphore with a new implementation in clrlifosemaphore unfairsemaphore had a some benefits it tracked the number of spinners and avoids waking up waiters as long as the signal count can be satisfied by spinners since spinners get priority over waiters thats the main unfair part of it that allows hot threads to remain hot and cold threads to remain cold however waiters are still released in fifo order spinning helps with throughput when incoming work is bursty all of the above benefits were retained in clrlifosemaphore and some were improved similarly to unfairsemaphore the number of spinners are tracked and preferenced to avoid waking up waiters for waiting on windows a i/o completion port is used since it releases waiters in lifo order for unix added a prioritized wait function to the pal to register waiters in reverse order for lifo release behavior this allows cold waiters to time out more easily since they will be used less frequently similarly to semaphoreslim the number of waiters that were signaled to wake but have not yet woken is tracked to help avoid waking up an excessive number of waiters added some yieldprocessornormalized calls to the spin loop this avoids thrashing on sleep by adding a delay to the spin loop to allow it to be more effective when there are no threads to switch to or the only other threads to switch to are other similar spinners removed the processor count multiplier on the max spin count and retuned the default max spin count the processor count multiplier was causing excessive cpu usage on machines with many processors.perf resultsfor the test case in cpu time spent in unfairsemaphore::wait was halved cpu time spent in unfairsemaphore::wait relative to time spent in workerthreadstart reduced from about to updated spin perf code here npc n proc count threads mpcwi m proc count work items burstworkthroughput queues that many work items in a burst then releases the thread pool threads to process all of them and once all are processed repeats sustainedworkthroughput has work items queue another of itself with some initial number of work items such that the work item count never reaches zero spin left score right score score threadpoolburstworkthroughput pc pcwi threadpoolburstworkthroughput pc pcwi threadpoolburstworkthroughput pc pcwi threadpoolburstworkthroughput pc pcwi threadpoolburstworkthroughput pc pcwi threadpoolburstworkthroughput pc pcwi threadpoolburstworkthroughput pc pcwi threadpoolsustainedworkthroughput pc total numbers on linux were similar with a slightly different spread and no regressions.i also tried the plaintext benchmark from on windows couldnt get it to build on linux at the time no noticeable change to throughput or latency and the cpu time spent in unfairsemaphore::wait decreased a little from to in clrlifosemaphore::wait
256753319,13900,https://api.github.com/repos/dotnet/coreclr/issues/13900,tvass83,1,0,0,0,0,0,it only happens in live debugging not when working with dump files the command can be anything from sos.dll the same command succeeds the second time and from that point on there are no errors loadby sos clr threads c exception in c:\windows\microsoft.net\framework\v..\sos.threads debugger extension pc fab va r/w parameter
256083905,13845,https://api.github.com/repos/dotnet/coreclr/issues/13845,ViktorHofer,1,0,0,0,0,0,relates to jonhanna
256019321,13835,https://api.github.com/repos/dotnet/coreclr/issues/13835,sdmaclea,1,0,0,0,0,0,fix nyi(gencodeformulhi and enable related loweringsfixes
255769597,13824,https://api.github.com/repos/dotnet/coreclr/issues/13824,adiaaida,1,0,0,1,0,0,this change converts our perf testing to use pipeline jobs pipelinejobs allow us to do the following test on the same commit for each of the test legs parallelize the build and test steps separate the build and test steps from one another this gives us theability to use the same build assets for all of the test legs of thesame configuration it also allows us to build on virtual machines andtest on perf machines so we only use the perf resources for testing have different test scenarios for prs and rolling this isntstrictly a benefit of pipeline jobs but certainly is made easier bythem allows us to have one trigger for pr jobs which will get us all theperf testing scenarios.this change also cleans up the groovy scripting for perf testing
255769031,13823,https://api.github.com/repos/dotnet/coreclr/issues/13823,erozenfeld,1,0,0,0,0,0,we currently allocate a struct temp for the result of newobj or any function returning struct in many cases that struct is immediately assigned to a local we should perform reverse copy prop to get rid of the temp.the relevant comment in the code is here
255765504,13822,https://api.github.com/repos/dotnet/coreclr/issues/13822,erozenfeld,3,0,0,0,0,0,when importing newobj that allocates a struct the jit inserts explicit zero-initialization in the ir for structs with gc fields the jit also inserts zero initialization in the prolog when initflags is true all fields of structs with gc fields are initialized in the prolog we should avoid this redundant zero-initialization.category:cqtheme:basic-cqskill-level:expertcost:medium
255753714,13821,https://api.github.com/repos/dotnet/coreclr/issues/13821,pgavlin,1,0,0,0,0,0,both of these issues stem from attempting to unassign a copied intervalfrom the copied-to register and then reassigning the interval to thesame this corrupts some of the bookkeeping necessary to track whetheror not the interval in the register needs to be spilled and the ra endsup attempting to spill the interval being allocated even though it isnot assigned a register
255710804,13815,https://api.github.com/repos/dotnet/coreclr/issues/13815,AndyAyersMS,0,0,0,5,0,0,implementation for new-style jit intrinsics for methods with il implementations that have known behaviors the jit can replace these with alternate implementations if it so chooses.i have been using enum.hasflag as a test case and so have marked it here as intrinsic the jit currently recognizes the call as a new-style intrinsic but does not yet optimize.related issue plan on doing some cleanup once there is agreement on naming and other aspects of the implementation.desktop implementation of the jit interface not shown will be stubbed out to always return null values for the new jit interface call
255692139,13814,https://api.github.com/repos/dotnet/coreclr/issues/13814,JosephTremoulet,1,0,0,0,0,0,currently the jits strategy for epilog generation is to generate one epilog per ret in the msil except that it checks for a few constructs needing epilog instrumentation and generates only one epilog if they apply x gc info has a limit of epilogs which is questionably enforced for all targetsthe analysis and transformation for both cases runs early in the phase list and merges the gt_return nodes when returns are merged.theres an opportunity here to take a more principled approach weighing the codesize reduction of merged epilogs against the dynamic path length reduction of duplicated epilogs.one potential approach keep gt_return s separated through optimization phases to allow a chance for constant propagation and cse to eliminate redundancies in the return expressions and allow removing code like we have in loop cloning and loop unrolling that currently shares the burden of respecting the max epilog limit decide later ideally when we have an idea both how much codesize each epilog will require and how frequently we expect each return site to execute how many epilogs to generate and which return sites should share presumably this could be done at or before the time that the actual lir for the epilogs is inserted improve the sharing by looking at the sequences leading up to the returns and the returned values and tail-merge as appropriate this improves codesize when the same value or variable is returned from multiple return sites and can remove some branches from the dynamic code paths when the merging is able to swallow up entire blocks which isnt uncommon for constructs like if return false category:cqtheme:basic-cqskill-level:expertcost:large
255372362,13792,https://api.github.com/repos/dotnet/coreclr/issues/13792,JosephTremoulet,1,0,0,1,0,0,the jit enforces a limit on the number of epilogs emitted in any givenmethod change the logic so that when this merging kicks in returns ofconstant values are given merged return blocks distinct from each otherand from the general return block as long as we can do so without goingover the limit this particularly helps avoid redundancy while stillkeeping method size down in methods with a large number of constantreturns but only a few distinct constants which is true of manypredicate methods with bool return type.this is the compiler portion of and dotnet/corefx
255348745,13788,https://api.github.com/repos/dotnet/coreclr/issues/13788,sdmaclea,1,0,0,0,0,0,block*)(destend block*)(srcend is generating sub x x sub x x ldp x x x stp x x x could be ldp x x x stp x x x category:cqtheme:block-optsskill-level:intermediatecost:medium
254753502,13756,https://api.github.com/repos/dotnet/coreclr/issues/13756,AndyAyersMS,1,0,0,0,0,1,provided call sig has default callling convention added test case.continuation of
254704126,13748,https://api.github.com/repos/dotnet/coreclr/issues/13748,AndyAyersMS,6,0,0,3,0,0,in the vm add mscorlib binder support for enum.hasflag recognize thismethod as a may-expand intrinsic.in the jit generalize the behavior of gttryremoveboxupstreameffects toadd a trial removal mode and to optionally suppress narrowing of thecopy source.then implement the optimization by checking for the intrinsic and ensuringthat both operands are boxes with compatible types that can be removed.the optimization changes the call to a simple and/compare tree on theunderlying enum values.invoke the optimzation during importation which will catch most cases andagain during morph to get the post-inline cases).currently not thinking of bumping the jit guid since this is a may expandintrinsic and no existing intrinsic id has changed.added test case suprisingly there were almost no uses of hasflag in thecurrent coreclr test suite.closes
254208709,13715,https://api.github.com/repos/dotnet/coreclr/issues/13715,CarolEidt,0,0,0,1,0,0,eliminate the second pass in lowering and instead call treenodeinfoinit on each node just prior to buildrefpositionsfornode
254124038,13703,https://api.github.com/repos/dotnet/coreclr/issues/13703,AndyAyersMS,2,0,0,0,0,0,"the importer reuses temps for different box operations that do not overlap.this keeps the number of temps to a minimum and reduces prolog zeroing if thetemps end up untracked but reuse prevents the importer from accurately typingthe temp.so now when optimizing allocate a new temp for each box operation and typethe temp with the type of the box.this along with a small update in gtgetclasshandle to obtain the box type,enables some devirtualization of interface calls on boxes and will facilitatefuture changes to optimize away boxes entirely eg"
254048288,13688,https://api.github.com/repos/dotnet/coreclr/issues/13688,tannergooding,2,0,0,0,0,0,create a new netcoreapp project and set the program.cs file to: csharpusing system;using system.threading;namespace consoleapp class program stathread static void main(string args console.writeline(thread.currentthread.getapartmentstate console.readline examine that the output from the application is: mta not respecting stathread means that users who depend on it even if it really only matters on windows have to manually spawn a thread to run their code.in some cases certain libraries actually check and enforce that the calling thread is sta and will throw an exception if it is not
254021718,13687,https://api.github.com/repos/dotnet/coreclr/issues/13687,pgodeq,1,0,0,0,0,0,adding windows equivalent of jit_stelem_ref fixes
253828513,13664,https://api.github.com/repos/dotnet/coreclr/issues/13664,BruceForstall,2,0,0,0,0,0,still needs changes in code invoked by arm_post_build.py toset the complus_altjit variables correctly for ryujit
253816189,13661,https://api.github.com/repos/dotnet/coreclr/issues/13661,mikem8361,1,0,0,0,0,0,fix dir.props buildversionfile override.issue
253125408,13612,https://api.github.com/repos/dotnet/coreclr/issues/13612,ElanHasson,1,0,0,0,0,0,im aware unloading of the assemblyloadcontext is not yet implemented is the same true for assemblies
253035165,13599,https://api.github.com/repos/dotnet/coreclr/issues/13599,sdmaclea,1,0,0,0,0,0,keep hot/cold data on separate cache linesfix errors in exponential backoffmake m_writerwaiting volatile and only use memorybarriers on writesimplify code
253012833,13597,https://api.github.com/repos/dotnet/coreclr/issues/13597,CarolEidt,0,0,0,2,0,0,in preparation for computing the treenodeinfo on the fly move all the treenodeinfoinit and related methods to the linearscan class
252813199,13585,https://api.github.com/repos/dotnet/coreclr/issues/13585,hqueue,1,0,0,0,0,0,enable ci for ryujit in arm release leg in addition to default legacy backend.as by now all pri test is passed for arm release i think its time to add ci for ryujit in arm release ./cc dotnet/arm-contrib
252761531,13576,https://api.github.com/repos/dotnet/coreclr/issues/13576,fiigii,3,0,0,4,0,0,this pr is the complete design of api proposal add intel hardware intrinsic functions and namespace and the mscorlib counterpart of add intel hardware intrinsic apis to corefx building with the current code base const parameter modifiers and intrinsic is temporarily removed
252753739,13574,https://api.github.com/repos/dotnet/coreclr/issues/13574,russellhadley,1,0,0,0,0,0,allows a higher limit for expanding switch tables into if/else linearsearches initial code is to get an idea of the diffs/perf
252429697,13551,https://api.github.com/repos/dotnet/coreclr/issues/13551,adiaaida,1,0,0,0,0,0,we see an over all regression in x windows throughput with this change with throughput regressions of median values of individual assemblies of up to in larger assemblies system.linq.expressions for example a change that reverted a prior version of this change ab which reverted dcc saw an overall win of almost across our throughput benchmarks suggesting that this change has a serious throughput impact this impact needs to be investigated.throughput regression results of the change that reverted a prior version of this change
252399499,13549,https://api.github.com/repos/dotnet/coreclr/issues/13549,JosephTremoulet,2,0,0,0,0,0,tracking issue for a classic codesize optimization thats not currently implemented in ryujit the optimization would find predecessors of a common successor along non-critical edges that all end in equivalent sequences leading up to the join and move the goto s and join earlier such that statically only one copy of the equivalent sequence remains wed want to treat return s as joining at the continuation so that we could eliminate redundant epilogs when a function has statically multiple return s of the same expression.category:cqtheme:optimizationskill-level:expertcost:medium
252332613,13544,https://api.github.com/repos/dotnet/coreclr/issues/13544,stephentoub,1,0,0,0,0,0,the implementation of number parsing/formatting in corert is a managed port of the native implementation in coreclr we want to unify on the managed implementation though doing so also involves addressing several perf gaps doing this will then enable much more easily implementing span-based number formatting in coreclr
252257910,13542,https://api.github.com/repos/dotnet/coreclr/issues/13542,joellacas,34,0,0,0,0,0,i got a weird error on iis since i migrate my asp.net core to asp.net core i publish with msbuild interface.i dont use applicationinsights.aspnetcore in my project....here is the error message. error an assembly specified in the application dependencies manifest rhweb.deps.json was not found package microsoft.applicationinsights.aspnetcore version path lib/netstandard./microsoft.applicationinsights.aspnetcore.dll this assembly was expected to be in the local runtime store as the application was published using the following target manifest files aspnetcore-store-..-linux-x.xml;aspnetcore-store-..-osx-x.xml;aspnetcore-store-..-win-x.xml;aspnetcore-store-..-win-x.xm
252080809,13527,https://api.github.com/repos/dotnet/coreclr/issues/13527,helloguo,1,0,0,0,0,0,work in progress pr tries to tune the spin wait on amd and x platforms because the latency of pause instruction in prior generation microarchitecture is about cycles whereas on skylake microarchitecture it has been extended to as many as cycles assume yieldprocessor took cycles when the original code was written and tuned get_cycle_count is defined as rdtsc .use the similar method which is suggested by the example shown at
251863229,13513,https://api.github.com/repos/dotnet/coreclr/issues/13513,parjong,2,0,0,0,0,0,multicastdelegate.equals considers secure/wrapper delegates when invocationlist is delegate but the corresponding gethashcode does not take into account secure/wrapper delegates.this inconsistency results in this commit revises the implementation of gethashcode to fix
251447105,13490,https://api.github.com/repos/dotnet/coreclr/issues/13490,am11,1,0,0,0,0,0,steps to repro a.cs c#using system;class a static void main(string args var subject new object var wref new weakreference(subject subject null gc.collect gc.waitforpendingfinalizers console.writeline(should be false wref.isalive console.writeline(should be false wref.isalive console.writeline(should be false wref.isalive console.writeline(should be false wref.isalive console.writeline(should be false wref.isalive a.csproj c#
251446320,13489,https://api.github.com/repos/dotnet/coreclr/issues/13489,tmds,3,0,0,0,0,0,"triggered by the discussion at im having a look at the cgroup code in coreclr.the first problem i encounter is the code isnt properly parsing the mountinfo when the mountpoint contains a dash pr next problem i have is the limits arent found.the code is looking for a mountpoint in the proc/self/mountinfo file and then combines that with a path it finds under proc/self/cgroup .i ran a container on rhel.+docker and one on minishift local instance of openshift which is using kubernetes as an orchectrator and the limits are not found at that location.instead they are present directly under the mount path.for example: mountpoint kubepods/besteffort/podaffb--e-be-efbeaa/decffffdbdebfcfdedbabeebee sys/fs/cgroup/cpu ro,nosuid,nodev,noexec,relatime cgroup cgroup rw,cpu cgroup :cpu:/kubepods/besteffort/podaffb--e-be-efbeaa/decffffdbdebfcfdedbabeebee ls sys/fs/cgroup/cpu cgroup.clone_children cgroup.procs cpu.cfs_period_us cpu.cfs_quota_us cpu.rt_period_us cpu.rt_runtime_us cpu.shares cpu.stat notify_on_release tasks cc janvorli benaadams markvincze rahku gboucher"
251282441,13457,https://api.github.com/repos/dotnet/coreclr/issues/13457,JosephTremoulet,2,0,0,0,0,0,currently we only eliminate redundant back-to-back loads through these pointer types but if we annotate the byref-exposed stores here here here and here we could identify when a subsequent load exactly matches the previous store this would e.g allow tracking values through assignments to out params.category:cqtheme:basic-cqskill-level:expertcost:small
250719567,13400,https://api.github.com/repos/dotnet/coreclr/issues/13400,sergign60,0,0,1,3,0,0,with this fix and with the fix for objectwriter that is prepared by mskvortsov the simplest test namespace hello internal class program private static int main(string args return runs succesfully on the device
250490586,13389,https://api.github.com/repos/dotnet/coreclr/issues/13389,stephentoub,0,0,0,2,0,0,adds parse and tryparse methods to boolean byte double int int int sbyte single uint uint uint and decimal.contributes to jkotas krzysztofcwalina tarekgh
250452038,13388,https://api.github.com/repos/dotnet/coreclr/issues/13388,helloguo,4,0,0,0,0,0,spin-wait can have a significant cost on power and performance if not done properly the pause instruction on skylake changed from previous generations such as haswell and broadwell from reference intel and ia architectures optimization reference manual section the latency of pause instruction in prior generation microarchitecture is about cycles whereas on skylake microarchitecture it has been extended to as many as cycles as the pause latency has been increased significantly workloads that are sensitive to pause latency will suffer some performance loss we are seeing issues with spinning on skylake server with techempower plaintext with excessive amount of time being spent in spin code its beneficial to tune the spin count or spin cycles and we have a proposal below for fix:for example the original spin code form j_join::join is shown below int spin_count g_num_processors for int j j spin_count j if color join_struct.lock_color break yieldprocessor indicate to the processor that we are spinning assume yieldprocessor took cycles when the above code was first written and tuned we could use spin cycles instead of spin count like this int spin_count g_num_processors assume yieldprocessor took cycles when the above code was first written and tuned ptrdiff_t endtime get_cycle_count spin_count while get_cycle_count endtime if color join_struct.lock_color break yieldprocessor indicate to the processor that we are spinning
250132853,13369,https://api.github.com/repos/dotnet/coreclr/issues/13369,richlander,0,0,0,16,0,0,net core runtime arm builds now availableupdate arm is now supported with net core net core team is now producing arm builds for net core runtime for both linux and windows these builds are great for using on raspberry pi the builds are not yet supported by microsoft and have preview status please give us feedback.docker arm images are also available at microsoft/dotnet see microsoft/dotnet docker hub readme adopts segmented os/arch style for a related announcement.there are two good sources of net core arm samples that you can use to get started net core on raspberry pi net core docker raspberry pi samples details dotnet/coreclr label:arch-arm team is producing runtime and not sdk builds for net core as a result you need to build your applications on another operating system and then copy to a raspberry pi or similar device to run the samples provided above show you how to do that.you can get builds from the following links official builds are not yet provided net core arm build net core servicing builds net core daily builds that arm is sometimes referred to as armhf which refers to hardware floating point capability can remote debug linux arm applications from a windows macos or linux machine.the sdk has not been made available for arm to yet as it doesnt fit within a reasonable performance envelope space and time for arm we will resolve this although it isnt a top priority currently unless feedback suggests otherwise our belief is that building on a desktop or build machine will be both more efficient and a reasonable work around to doing development on the pi for the time being we also wanted to prioritize the runtime being available since its necessary for anything to work.a more near-term need is unit testing on arm there is no replacement for running tests on device we intend to publish short-term workarounds for this and work on a longer-term solution that is easy to use.also published at dotnet/announcements
250099033,13367,https://api.github.com/repos/dotnet/coreclr/issues/13367,swgillespie,1,0,0,0,0,0,the dprintf logging mechanism in the gc uses some non-standard formatting sequences that may not work as expected with a non-windows crt we should settle on standard formatting sequences so that we can use this mechanism on non-windows platforms.the standalone gc build currently builds with wno-format in order to silence the warnings raised about these non-standard formatting sequences.cc maoni
249823093,13355,https://api.github.com/repos/dotnet/coreclr/issues/13355,jkotas,1,0,0,0,0,0,struct s public int a public int b public int c public int d;};static void foo(s s bar(ref s._b);} before: sub rsp cmp dword ptr rcx ecx unnecessaryadd rcx call my:bar(byref)nopadd rsp ret after: sub rsp add rcx call my:bar(byref)nopadd rsp ret
249718171,13341,https://api.github.com/repos/dotnet/coreclr/issues/13341,fiigii,1,0,0,0,0,0,according to vtune characterization parseheaders is one of the hot functions in techempower-plaintext scenario parseheaders invokes inlined dangerousgetpinnablereference twice which generates roundtrip mov sequences from inlined unsafe.asref : asmin call system.intptr:topointer():long:thisin mov rdi raxin b mov rax rdiin e mov rdi raxina jmp short g_m_ig......in be call system.intptr:topointer():long:thisin c mov rdi raxin c mov rax rdiin c mov rdi raxin cc mov eax dword ptr v rbp-h in d movsxd rax eax these redundant moves are from unsafe.asref(void source cil managed aggressiveinlining custom instance void system.runtime.versioning.nonversionableattribute::.ctor locals int maxstack ldarg roundtrip via a local to avoid type mismatch on return that the jit inliner chokes on stloc ldloc ret end of method unsafe::asref @jkotas s example shows that this roundtrip has been correctly eliminated by the compiler but it appears in the generated code of span.dangerousgetpinnablereference .i will look into providing a solution
249651008,13336,https://api.github.com/repos/dotnet/coreclr/issues/13336,mattwarren,3,0,0,0,0,0,start collating a list of blog posts the provide a deep-dive into the coreclr source code as per an off-line discussion with richlander
249425349,13315,https://api.github.com/repos/dotnet/coreclr/issues/13315,smile21prc,1,0,0,0,0,0,enable redhat in coreclr master.this is identical as the approved pr to enable redhat in coreclrrelease
249375590,13314,https://api.github.com/repos/dotnet/coreclr/issues/13314,JosephTremoulet,4,0,0,1,0,1,"rearrange basic blocks during loop identification so that loop bodiesare kept contiguous when possible blocks in the lexical range of theloop which do not participate in the flow cycle which typicallycorrespond to code associated with early exits using break or return are moved out below the loop when possible without breaking ehregion nesting the target insertion point when possible is chosen tobe the first spot below the loop that will not break up fall-through.layout can significantly affect the performance of loops particularlysmall search loops by avoiding the taken branch on the hot path,improving the locality of the code fetched while iterating the loop andpotentially aiding loop stream detection.resolves"
249208502,13305,https://api.github.com/repos/dotnet/coreclr/issues/13305,AndyAyersMS,1,0,0,0,0,0,in minopts/debug/rare-block modes try and minimize code size andjit time by always chosing the helper call for complex runtime lookups
249197990,13301,https://api.github.com/repos/dotnet/coreclr/issues/13301,smile21prc,1,0,0,0,0,0,enable rhel official builds and tests in coreclr release/...this is the coreclr effort to resolve the reference the corefx part of this change was merged into corefx release as
249113422,13293,https://api.github.com/repos/dotnet/coreclr/issues/13293,Tragetaschen,1,0,0,0,0,0,today i have finally found the reason why my dbus implementation works with mono but doesnt with net core: system.typeloadexception cannot marshal field control of type msghdr unknown error at system.stubhelpers.valueclassmarshaler.converttonative(intptr dst intptr src intptr pmt cleanupworklist pcleanupworklist at dbus.connection.recvmsg(intptr sockfd msghdr buf int flags at dbus.connection.receive() heres a quick copy of the code from here static extern int recvmsg(intptr sockfd in ref msghdr buf int flags);private unsafe struct iovec public byte iov_base public int iov_len;}private unsafe struct msghdr public intptr name public int namelen public iovec iov public int iovlen public int control public int controllen public int flags;} when calling recvmsg mono is fine with marshalling the control member of msghdr for net core and preview i had to change int to int and add another fixed statement to my code.the unknown error makes me wonder if theres something missing in net core
248870825,13277,https://api.github.com/repos/dotnet/coreclr/issues/13277,plioi,2,0,0,0,0,0,im porting a test framework to net core so i need to avoid relying on appdomains for netcoreapp test assemblies ive attempted to use a custom assemblyloadcontext to accomplish the same thing but its not clear how to have a custom assemblyloadcontext that can successfully load dependencies like nuget packages now that such assemblies dont literally appear in a projects build output folder.background-------historically like nunit and xunit ive used an appdomain to address assembly loading the running executable is a console application living in some nuget-controlled folder while the test assembly and its dependencies live in the test assemblys own build output folder the primary appdomain for the console application finds the runners own dependencies right beside the exe of course and a secondary appdomain is created with the applicationbase path set to the test assemblys folder ie bin/debug/myproject.tests this essentially tricks the test assembly into thinking its the running application as far as assembly loading goes.first attempt at a custom assemblyloadcontext-------for a netcoreapp test assembly we dont have appdomains it appears this is one of the things assemblyloadcontext is intended to solve specifically calls out assemblyloadcontext as the recommended alternative to appdomains for resolving assemblies dynamically gkhannas helpful documentation at says these provide the ability to load assemblies explicitly in a context isolated from that of the application jkotass examples in the comments at got me far enough for basic scenarios to work: csharp class testassemblyloadcontext assemblyloadcontext readonly string testassemblydirectory public testassemblyloadcontext(string testassemblydirectory this.testassemblydirectory testassemblydirectory protected override assembly load(assemblyname assemblyname return loadfromfolderordefault(assemblyname assembly loadfromfolderordefault(assemblyname assemblyname try var path path.combine(testassemblydirectory assemblyname.name if file.exists(path dll return loadfromassemblypath(path dll if file.exists(path exe return loadfromassemblypath(path exe todo probably missing something here what if its a transitive nuget dependency not literally in the test projects build output folder return null catch exception ex console.writeline(ex return null not too surprisingly this would only help to load assemblies that literally appear beside the test assembly transitive nuget dependencies would only be implied by the runtimeconfig.json deps.json and runtimeconfig.dev.json files in that folder.i had been hoping that the inherited behavior from assemblyloadcontext would provide some assistance for traversing such dependencies and finding their location on disk so that my todo above could find them.xunits solution--------------earlier the xunit team ran into a similar challenge as discussed here of making a custom assemblyloadcontext their solution instead involves parts kicking off their console runner with dotnet exec so that they can specify the test assemblys own json files as the depsfile and runtimeconfig as seen here that appears to solve loading of the test assembly its physically-present dependencies in the same folder and likely their transitive dependencies too since that alone would likely break their console runner from loading its own dependencies they attach a handler to assemblyloadcontext.default.resolving to load assemblies that live beside the console runner itself for guidance-------------------ive attempted both approaches unsuccessfully so this is a request for guidance.with my custom assemblyloadcontext above i achieve the desired isolation youd want in a test framework itd be awful if my own reference to newtonsoft.json for instance interfered with that of a test project but i fail to load transitive dependencies.when i instead try to use dotnet exec and assemblyloadcontext.default.resolving my app crashes without even entering main due to a failure to load its own dependency sitting right beside mains assembly im not sure why thats happening for me but not for xunit even if i could get around that i think this leaves the door wide open for mistakes at runtime when the test frameworks own dependencies are a different version than those of the test assembly.whats the right way to achieve appdomain-like isolation for a test assembly and its dependencies vstest must have had to encounter and resolve the same challenge for dotnet test but i havent been able to find it in their implementation
248132919,13241,https://api.github.com/repos/dotnet/coreclr/issues/13241,jkotas,1,0,0,0,0,0,follow up on
247887195,13220,https://api.github.com/repos/dotnet/coreclr/issues/13220,netroby,2,0,0,0,0,0,restoring packages for home/huzhifeng/workspace/netroby/hwapp/hwapp.csproj failed to download package runtime.linux-x.microsoft.netcore.app...-preview from the download of timed out because no data was received for ms exception of type system.timeoutexception was thrown failed to download package runtime.linux-x.microsoft.netcore.app...-preview from the download of timed out because no data was received for ms exception of type system.timeoutexception was thrown. i came from china i try to develop and run dotnet app code.but i have trouble to get restore work.would you please add cdn accelerate for china
247880254,13219,https://api.github.com/repos/dotnet/coreclr/issues/13219,bbowyersmyth,1,0,0,0,0,0,improves the performance of string.indexofany special casing common and character searches char search beats a minimal hard coded loop after rd string character.small string chars faster than existinglarge string chars faster than existing char search beats a minimal hard coded loop after th string character.small string chars faster than existinglarge string chars faster than existing initializeprobabilisticmap very common to search for ascii symbols the high map always writes the same value to the same location only doing that once gives a improvement isolated char array).issues davkean benaadams
247867193,13215,https://api.github.com/repos/dotnet/coreclr/issues/13215,CarolEidt,0,0,0,2,0,0,fix
247820314,13209,https://api.github.com/repos/dotnet/coreclr/issues/13209,stephentoub,1,0,0,0,0,0,this code comes from just copied it here to have a simple repro the span version is identical to the array version other than the signature and the first two lines that set the offset and count on my machine the span version runs slower. c#using system;using system.diagnostics;class program static void main const int iters var sw new stopwatch var r new random var data new byte r.nextbytes(data uint crc while true crc sw.restart for int i i iters i crc managedcrcspan(crc new span(data sw.stop console.writeline(sw.elapsed.totalmilliseconds crc sw.restart for int i i iters i crc managedcrcarray(crc data data.length sw.stop console.writeline(sw.elapsed.totalmilliseconds console.writeline private static uint managedcrcarray(uint crc byte buffer int offset int length debug.assert(bitconverter.islittleendian managedcrc expects little endian uint term term term crc xffffffffu int runninglength length int endbytes length runninglength for int i i runninglength i crc unchecked((uint)(buffer offset buffer offset buffer offset buffer offset offset term s_crctable_ crc xff s_crctable_ (crc xff term crc crc term s_crctable_ term xff s_crctable_ (term xff term unchecked((uint)(buffer offset buffer offset buffer offset buffer offset offset term s_crctable_ term xff s_crctable_ (term xff term term crc term s_crctable_ term xff s_crctable_ (term xff for int i i endbytes i crc s_crctable_ (crc buffer offset xff crc crc xffffffffu return crc private static uint managedcrcspan(uint crc span
247574325,13187,https://api.github.com/repos/dotnet/coreclr/issues/13187,AndyAyersMS,1,0,0,0,0,0,"might not be a perf win but it shows up in exception paths so could help reduce overall code size and jit time.for instance inspired by similar code in system.valuetuple : c#struct b public b(double d x d y double x double y public bool compareto(object other if other is b throw new exception(bad type expected this.gettype().tostring var otherb b other return x otherb.x y otherb.y the codegen for compareto is: asm assembly listing for method b:compareto(ref):bool:this emitting blended_code for x cpu with avx optimized code rsp based frame partially interruptible final local variable assignments v this v,t byref rdi this v arg v,t ref rsi class-hnd v loc v struct zero-ref v tmp v,t ref rdx class-hnd v tmp v,t ref rsi v tmp v,t ref rdi class-hnd exact v tmp v,t double mm v.x(offs=x p-indep v tmp v,t double mm v.y(offs=x p-indep v tmp v,t ref rbx v tmp v,t ref rdx v tmp v,t ref rdx v tmp v,t byref rax v outargs v lclblk rsp+x v rat v,t ref rax lcl frame size g_m_ig push rdi push rsi push rbx ec sub rsp cf vzeroupper bf mov rdi rcx bf mov rsi rdxg_m_ig bd mov rdx rsi d test rdx rdx je short g_m_ig bafff mov rcx xfffa a cmp qword ptr rdx rcx je short g_m_ig d xor rdx rdxg_m_ig d test rdx rdx je short g_m_igg_m_ig baafff mov rdx xfffa cmp qword ptr rsi rdx je short g_m_ig bd mov rdx rsi bafff mov rcx xfffa ecf call corinfo_help_unboxg_m_ig d lea rax bword ptr rsi ceb vmovsd xmm qword ptr rax ceb vmovsd xmm qword ptr rax seems odd to load this.y here ceb vmovsd xmm qword ptr rdi ceed vucomisd xmm xmm a jpe short g_m_ig e jne short g_m_ig ceb vmovsd xmm qword ptr rdi would expect it to be loaded here ceec vucomisd xmm xmm fbc setpo al a jpe short g_m_ig fc sete alg_m_ig fbc movzx rax alg_m_ig c add rsp b pop rbx e pop rsi f pop rdi c retg_m_ig c xor eax eaxg_m_ig c add rsp b pop rbx e pop rsi f pop rdi c retg_m_ig bafff mov rcx xfffa edef call corinfo_help_newsfast allocate new b on heap bf mov rsi rax copy contents to new b de lea rcx bword ptr rsi ceaf vmovdqu xmm qword ptr rdi ceaf vmovdqu qword ptr rcx xmm bedeff mov rcx xffdee edef call corinfo_help_newsfast bf mov rdi rax b mov ecx baefff mov rdx xfffe ecf call corinfo_help_strcns bd mov rbx rax bce mov rcx rsi call gettype on new b on heap ignore contents eabaacf call system.object:gettype():ref:this bc mov rcx rax b mov rax qword ptr rax b mov rax qword ptr rax ff call gword ptr rax system.object:tostring():ref:this bd mov rdx rax bcb mov rcx rbx ecae call system.string:concat(ref,ref):ref bd mov rdx rax bcf mov rcx rdi eedae call system.exception:.ctor(ref):this bcf mov rcx rdi ebf call corinfo_help_throw cc int total bytes of code prolog size for method b:compareto(ref):bool:this also a bit puzzling why we load both x and y from this before doing any compare seems like we should defer loading y i suppose thats just how promotion works all the fields get loaded even if some of the downstream uses are conditional"
247557439,13183,https://api.github.com/repos/dotnet/coreclr/issues/13183,CarolEidt,4,0,0,0,0,0,nodes that produce multiple registers require special handling there should be a unified mechanism for manipulating the register and spill info on these nodes the nodes are gentreemultiregop target_arm gentreeputargsplit target_arm gentreecall feature_multireg_ret )see the declarations of the following methods on these nodes clearotherregs clearotherregflags getregnumbyidx getregspillflagbyidx setregspillflagbyidx getregtype() category:implementationtheme:irskill-level:expertcost:medium
246934252,13139,https://api.github.com/repos/dotnet/coreclr/issues/13139,paya-cz,1,0,0,0,0,0,first of all let me begin by saying that i do not have knowledge of low level implementation details of gc so not sure how doable these ideas are going to be.the trystartnogcregion function requires me to provide an exact number of bytes and that number should be at most the size of ephemeral segment however this is a little hard to do for example when i use workstation gc bit the documentation says i should be able to pass as much as to the trystartnogcregion however when running in debug i could pass only at most the interval inbetween caused the app to crash as per apparently the crash bug has been fixed in net but other people also werent able to pass the advertised mb to the function either since i am asked to pass a number of bytes to the function it would be really nice to at least document what are exactly the upper/lower bounds of the number input parameter currently it seems the numbers mb mb in docs are rough estimates and so i had to actually run the trystartnogcregion in a loop and pass decrementing values until one of the values passes the actual upper bounds of or never worked for me.it would be nice to have an api that tells me how many committed bytes are available/free/left in the no-gc region i guess one property for soh one property for loh so my code can react accordingly and exit the region in time prematurely if need-be so the gc doesnt kick in at the wrong moment currently the only workaround is using gc.gettotalmemory but thats not an exact method and not even sure how reliable it is also the gc.gettotalmemory doesnt distinguish between soh and loh.speaking of soh/loh an api that tells me the total memory usage of soh and loh for the whole app not just the no-gc region would be great too so the app could run diagnostics on itself and dynamically adjust the trystartnogcregion inputs.since the size of no-gc region is tightly bound to the size of ephemeral segment could you add settings to increase the ephemeral segment in app.config currently the only way to increase the segment size is to switch to x and to server gc.to give you an idea as to what i am trying to achieve i am building an app that needs to process data in the least amount of time possible the data comes over the network i need to read it process and send an answer as soon as possible without any interruption the nogc region gave me a hope that i could just allocate and dedicate the entire available ram to my app and it would just use it until it gets full at which point a gc would happen.but my app would closely monitor how much space is left in the no-gc region and when it gets close to being full the app could stop the time-sensitive process in appropriate moment invoke gc manually and then resume the operation in this application its ok if i pause the time-sensitive operation to do some maintenance such as calling gc at specified points but outside of these points gc should remain disabled this would let me perform the time-sensitive operation for as long as ram allows and then pause at the right moment clean up and resume a way to remove interruptions for as long as possible but giving me a chance to clean up when its appropriate.i know c#/.net is not the best language for building real-time systems but honestly no-gc regions bring it pretty close and in my case it could be good enough
246877669,13128,https://api.github.com/repos/dotnet/coreclr/issues/13128,JosephTremoulet,3,0,0,0,0,0,most of these get translated to shifts at morph but adding a failsafehere next to the transform for lea ensures we wont have these inthe emitted code when they re-)appear in later phases
246874713,13127,https://api.github.com/repos/dotnet/coreclr/issues/13127,nategraf,1,0,0,0,0,0,this pr adds a test into the runtest.proj file along with associated checks for when it should run to verify that pgo was used to compile coreclr.dll and clrjit.dll under the correct build conditions the build conditions determined to require pgo compilation are it is a release build it is not for linux i.e for windows it is not for arm architecture pgo was not explicitly turned off with the nopgooptimize flagissue
246492203,13106,https://api.github.com/repos/dotnet/coreclr/issues/13106,mazong1123,1,0,0,0,0,1,extract this issue from speaking double.tostring(r tries to convert the double to string in digits precision convert the string back to double and compare to the original double if they are the same we return the converted string whose precision is otherwise convert the double to string in digits precision.this introduced a bug and also listed as a known issue on msdn see notes to callers reproduce this issue simplely try following code: csharpusing system;namespace lab class program static void main(string args double d string s d.tostring(r double d double.parse(s console.writeline(d d the output is false which we expect true the reason is d.tostring(r wrongly chose the result in precision of which is if we choose result in precision of which is we can convert it back to double accurately.the proposal is just convert the double to string in digits precision directly we can give it a try but it may be a breaking change with compat issue as jkotas said here
246479280,13105,https://api.github.com/repos/dotnet/coreclr/issues/13105,stephentoub,0,0,0,9,0,1,the first time a task-based async method yields today there are four allocations the task returned from the method the state machine object boxed to the heap an action delegate thatll be passed to awaiters a movenextrunner that stores state machine and the executioncontext and has the method that the action actually referencesfor a simple async method e.g. c#static async task doworkasync await task.yield();} when it yields the first time we allocate four objects equaling bytes bit).this pr changes the scheme to use fewer allocations and less memory with the new version there are only two allocations a type derived from task an action delegate thatll be passed to awaitersthis doesnt obviate the need for the state machine but rather than boxing the object normally we simply store the state machine onto the task-derived type which itself implements iasyncstatemachine further the captured executioncontext is stored onto that same object rather than requiring a separate movenextrunner to be allocated and the delegate can point to that task-derived type with this new scheme and that same example from earlier rather than costing allocations and bytes it costs allocations and bytes so fewer allocations and less allocated memory. it also helps further in another common case previously the task and state machine object would only be allocated once but the action and movenextrunner would be allocated and then could only be reused for subsequent awaits if the current executioncontext was the default if however the current executioncontext was not the default every await would end up allocating another action and movenextrunner for allocations and bytes on each await with the new design those are eliminated such that even if a non-default executioncontext is in play and even if it changes in between awaits the original allocations are still used. theres also a small debugging benefit to this change the resulting task object now also contains the state machine data which means if you have a reference to the task you can easily in the debugger see the state associated with the async method previously you would need to use a tool like sos to find the async state machine object that referenced the relevant task.one hopefully minor downside to the change is that the task object returned from an async method is now larger than it used to be with all of the state machines state on it generally this wont matter as you await a task and then drop it so the extra memory pressure doesnt exist for longer than it used to however if you happen to hold on to that task for a prolonged period of time youll now be keeping alive a larger object than you previously were.there is also a very corner case change in behavior which shouldnt break any real code but does actually break one corefx test theres an asyncvaluetaskmethodbuilder test i wrote as part of trying to get to code coverage that explicitly passes the wrong state machine object to the builders setstatemachine method and this change causes one of its asserts to fail in an expected manner).cc kouvel benaadams davidfowl ericeil madstorgersen
246221215,13097,https://api.github.com/repos/dotnet/coreclr/issues/13097,stephentoub,3,0,0,0,0,0,repro: c#using system;using system.diagnostics;using system.linq;using system.numerics;using system.runtime.compilerservices;class program static void main const int iters var sw new stopwatch byte array new byte span
245942441,13079,https://api.github.com/repos/dotnet/coreclr/issues/13079,CarolEidt,10,0,0,4,0,0,this is an initial translation of the slides presented at the pldi ryujit tutorial into markdown.all of the diagrams are missing and the ir dumps need to be updated toreflect ir changes since the tutorial was given
245902074,13075,https://api.github.com/repos/dotnet/coreclr/issues/13075,stephentoub,1,0,0,0,0,0,cc jkotas krzysztofcwalina contributes to
245259744,13016,https://api.github.com/repos/dotnet/coreclr/issues/13016,AndyAyersMS,2,0,0,0,0,0,"boxing a value type produces a non-null result if the result of thebox is only used to feed a compare against null the jit tries tooptimize the box away entirely since the result of the comparison isknown such idiomatic expressions arise fairly often in genericsinstantiated over value types.in the current implementation the box expands into two parts anupstream statement to allocate heap space and then an expressiontree containing an encapsulated copy from the value being boxed tothe payload of the new heap object wrapping around that is areference to the new object which is the result of the box.when the optimization fires the upstream allocation is removed,and the current implementation also removes the entire box expressiontree howver this tree can include important side effects fromthe evaluation of the value being boxed that must be preserved.for instance the value might come from an array in which caseand the box expression tree would contain the array null checkand bounds check so removing the entire tree can alter behavior.this fix attempts to carefull preserve the important sideeffects by moving the copy into a second statement upstream from thebox the box itself is then just a trivial side-effect-free referenceto the box temp local.when the optimization fires the jit removes the upstream heap allocationas before as well as the now-trivial box tree it analyzes the sourceside of the upstream copy if it is side effect free the copy is removedentirely if not the jit modifies the copy into a minimal load of theboxed value and this load should reproduce the necessary side effects.fixes"
245170804,13007,https://api.github.com/repos/dotnet/coreclr/issues/13007,sdmaclea,3,0,0,0,0,0,when workstealingqueue is empty there is an o(n^)penalty for searching the empty queues avoid bystashing global emptiness
245155725,13006,https://api.github.com/repos/dotnet/coreclr/issues/13006,AndyAyersMS,3,0,0,0,0,0,"we often see numerous back to back calls to this helper that could be trivially turned into one call with a count for instance: asm system.tupleextensions:createlong(ref,ref,ref,ref,ref,ref,ref,ref):struct mov rdi rbx lea rsi bword ptr rbp-h call corinfo_help_assign_byref call corinfo_help_assign_byref call corinfo_help_assign_byref call corinfo_help_assign_byref call corinfo_help_assign_byref call corinfo_help_assign_byref call corinfo_help_assign_byref call corinfo_help_assign_byref each call does a series of range checks a write a card table update and src/dest pointer updates so there is a lot of overhead here that could be reduced via ranged version.category:cqtheme:helpersskill-level:expertcost:medium"
245104765,13004,https://api.github.com/repos/dotnet/coreclr/issues/13004,stephentoub,1,0,0,0,0,0,we want to be able to use public api that returns valuetask
244849263,12983,https://api.github.com/repos/dotnet/coreclr/issues/12983,mikedn,2,0,0,0,0,0,its strange that we have both typ_char and typ_ushort theyre both unsigned short integers its even more strange that typ_char is used pretty much everywhere while typ_ushort rarely makes an appearance and as far as i can tell it is never used as a node type worse theres code that doesnt bother to check for typ_ushort it only checks for typ_char lowering::getcastdescription for example.is there any good reason to keep typ_char perhaps it was an attempt to be consistent with typ_bool at least typ_bool does have a special meaning its an unsigned byte thats either or but typ_char
244441126,12956,https://api.github.com/repos/dotnet/coreclr/issues/12956,JosephTremoulet,1,0,0,0,0,1,this change adds two documents jitoptimizerplanningguide.md discusses how we can/do/should go about identifying prioritizing and validating optimization improvement opportunities as well as several ideas for how we might improve the process jitoptimizertodoassessment.md lists several potential optimization improvements that always come up in planning discussions with brief notes about each to capture current thinking
244203328,12940,https://api.github.com/repos/dotnet/coreclr/issues/12940,AndyAyersMS,4,0,0,0,0,0,based on comments/code it looks like the jit does not accurately model the kill set of some helpers eg corinfo_help_assign_byref kills very few registers on x but the jit models it as a general call plus some extra kills.the non-windows implementations use prepare_external_var to copy various runtime statics into registers the macro expand into a rip-relative memory operand so it would be better to just fold these into the compare instructions directly eg instead of asm void jit_checkedwritebarrier(object dst object src)leaf_entry jit_checkedwritebarrier text prepare_external_var g_lowest_address rax cmp rdi rax one could have asm cmp rdi external_var g_lowest_address and aside from a more compact and faster-executing helper this would also free up rax entirely in several helpers which the jit assuming adopted an accurate model could then use as a preserved register.accurate modelling and fewer kills might lead to proportionally larger wins on linux because of the larger number of default callee-killed registers.category:cqtheme:helpersskill-level:expertcost:medium
243944942,12894,https://api.github.com/repos/dotnet/coreclr/issues/12894,mazong1123,1,0,0,0,0,0,instead of leveraging snprintf re-implement the ecvt function according to the paper this commit wont fix any existing bug this is a raw implementation of the paper the performance on linux only gain we could tune the performance further. update :now the new implementation is at least x faster than the old one.fix
243775724,12881,https://api.github.com/repos/dotnet/coreclr/issues/12881,pgavlin,1,0,0,0,0,0,just what it says on the tin
243675760,12877,https://api.github.com/repos/dotnet/coreclr/issues/12877,roji,4,0,0,0,0,0,it seems that using the is keyword in a generic function causes value types to be boxed consider the following program: c#class program const long iterations static void foo(t bar if bar null no allocation if typeof(t typeof(string no allocation if bar is string allocation throw new exception(never happens static void main(string args for var i i iterations i foo(i this is especially odd as comparison to null doesnt box this can be worked around by avoiding is and comparing types and can also provide a form of template specialization as in
243523597,12862,https://api.github.com/repos/dotnet/coreclr/issues/12862,nchikanov,0,0,0,1,0,0,change isnullorwhitespace to isnullorempty to be more consistent with legacy desktop net code path.getfullpath no longer trims trailing whitespace windows will still eat trailing spaces)test changes for corefx are done will link in pr request shortly
243495243,12859,https://api.github.com/repos/dotnet/coreclr/issues/12859,4creators,4,0,0,0,0,0,caroleidt i would love to see documentation pages with walkthrough on adding new feature to ryujit and supporting technologies as it was presented on pldi workshop or perhaps in expanded form reading the code and current documentation as a way to understand ryujit and start to play with code has a steep learning curve penalty
243339692,12851,https://api.github.com/repos/dotnet/coreclr/issues/12851,micli,1,0,0,0,0,0,environment dotnet info.net command line tools preview-)product information version preview commit sha hash aruntime environment os name ubuntu os version os platform linux rid ubuntu..-x base path usr/share/dotnet/sdk/..-preview-/microsoft net core shared framework host version preview build ceadacecdfbddee description :i can load libsosplugin.so successfully and i can view help information by help but not soshelp below are repo steps: parallels@ubuntu whereis dotnetdotnet usr/bin/dotnet usr/share/dotnet usr/share/man/man/dotnet..gzparallels@ubuntu cd usr/share/dotnet/shared/microsoft.netcore.app/..-preview--/parallels@ubuntu:/usr/share/dotnet/shared/microsoft.netcore.app/..-preview lldb-.(lldb plugin load libsosplugin.so(lldb soshelp(lldb soshelp pesegmentation fault core dumped)parallels@ubuntu:/usr/share/dotnet/shared/microsoft.netcore.app/..-preview when i input soshelp it echoed nothing when i input soshelp with any net core extension command like dumpheap or pe it was crashed the same issues exists on debian with lldb either but it works fine on centos with lldb
243116497,12819,https://api.github.com/repos/dotnet/coreclr/issues/12819,stephentoub,5,0,0,0,0,0,cancellationtoken.register currently allocates an object per call this pr makes it allocation-free amortized).the current implementation was optimized for scalability using a lock-free algorithm to minimize contention when lots of threads are registering with a token concurrently each registration allocates an object which is then stored into a lock-free sparse array data structure but the level of scalability enabled is unnecessary for the vast majority of cancellationtoken usage adds non-trivial complexity to the implementation and adds costs to the most common usage scenarios e.g a single cancellationtoken that registered with and the unregistered with repeatedly.the new implementation strikes a imo better balance between performance and scalability retaining most of the latter while doing much better for the former in the most interesting use cases cancellationtokensource now maintains an array of partition objects each of which is lazily-initialized contains a lock that protects that partition and contains a linked list of registration objects the striped locking helps maintain most of the scalability and also enables node reuse due to not suffering from aba problems.(all numbers that follow are bit.)the size of cancellationtokensource itself doesnt change bytes so allocating a cancellationtokensource and then never registering with its token remains the same in both speed and space.the size overhead associated with the first registration on a cancellationtokensource improves with the old implementation the first registration would result in bytes allocated whereas with the new implementation that shrinks to each additional registration at the same time in the cancellationtoken is now larger than in the old implementation bytes instead of bytes it varies in the old implementation due to the details of the lock-free algorithm and when new segments are created but these new node allocations are reusable so if you register registrations with the same cancellationtoken and dont unregister any of them youll incur bytes of allocation instead of but if you instead register and unregister them times youll only incur bytes of allocation instead of with objects reused for the former case but not the latter case.speed is also significantly improved a single thread registering and unregistering repeatedly from a token is now x the old implementation in throughput similarly with eight threads on eight logical cores all registering/unregistering concurrently.finally the size of cancellationtokenregistration also shrinks by a few bytes this struct is often contained in other classes that have registered with the token and so will end up shrinking the size of those allocations as well.cc kouvel alexperovich benaadams
243054389,12812,https://api.github.com/repos/dotnet/coreclr/issues/12812,pgavlin,1,0,0,0,0,0,stephentoub recently brought up a couple of scenarios in which the jit selects suboptimal write barriers in particular the use of unnecessary checked write barriers was taking up nearly of the cycles spent in a simple microbenchmark involving cancellationtoken s opaque byrefsthe jit currently attempts to decide what sort of write barrier is necessary by pattern-matching on the target address while this is sufficient for many cases it is less than optimal when the target address is an opaque byref e.g when it is a byref-typed lclvar we can do a better here by using value numbers when available see e.g the changes at this can improve the performance of these stores by quite a bit as it allows the compiler to use unchecked write barriers in more cases for example the changes in the aforementioned branch allow the following code to use an unchecked write barrier rather than a checked write barrier: struct s public c c;}sealed class c static int main var s new s s new s c new c return struct copiesas it stands the jit always uses corinfo_help_assign_byref this issue is a bit trickier to solve as this helper has additional semantics beyond the write barrier in particular the destination and source addresses are passed in edi / rdi and esi / rsi respectively and are incremented before the helper returns this behavior mostly matches that of the movs instruction though we could use the existing unchecked barrier doing so would require us to adjust our current codegen strategy for struct copies which just uses movs / rep movs / assign_byref and therefore only requires a maximum of three registers replacing this implementation with something that could generate calls to the existing unchecked barrier would require either additional registers as this helper takes its destination and source arguments in the usual registers for the target abi or additional instructions instead of using movsp we could manually increment the src and dest addresses and use arbitrary registers the right solution is probably to implement a new helper--perhaps something like corinfo_help_movs_ref --that provides unchecked barrier semantics but with the calling convention and post-increment behavior of corinfo_help_assign_byref this would improve code like the following: using system.runtime.compilerservices;struct s public c c public int i sealed class c methodimpl(methodimploptions.noinlining static void store(s array int slot s s array slot s static int main store(new s new s return thoughts?category:cqtheme:barriersskill-level:expertcost:medium
242755508,12797,https://api.github.com/repos/dotnet/coreclr/issues/12797,gboucher90,1,0,0,1,0,0,virtualization containers systems such as docker mesos kubernetes often relies on cgroup cpu to limit resources.currently environment.processorcount in such systems return the physical number of processors the problem is that this variable is used to properly scale the thread pool.in our case the cpu limit in mesos was set to while the machine had processors then the application running a kestrel http server performed very badly and was often irresponsive.memory limit was already correctly implemented thus it makes sense to do the same for cpu
242695169,12794,https://api.github.com/repos/dotnet/coreclr/issues/12794,gboucher90,1,0,0,0,0,0,add support for cpu limiting via cgroup.virtualization containers systems such as docker mesos kubernetes often relies on cgroup cpu to limit resources
241837049,12720,https://api.github.com/repos/dotnet/coreclr/issues/12720,noahfalk,3,0,0,0,0,0,when the jit fails to compile il sometimes this is caused by bad il that was provided by a profiler in unsafejitfunction when we know the jit has failed we could check whether or not a profiler is attached we can update the error message to indicate that the il which failed to compile was provided by a particular profiler dll the error message shouldnt blame the profiler because without il verification we dont have sufficient evidence to know it did something wrong the goal is simply to alert someone diagnosing the issue to the presence of that profiler so they can evaluate that possibility.an extension to this work that should probably merit its own workitem(s would be to run an il verification algorithm in the error path to discover exactly what if anything is wrong with the il
241834196,12719,https://api.github.com/repos/dotnet/coreclr/issues/12719,noahfalk,5,0,0,0,0,0,when jitting fails wed like to know whether the jit was operating on the original il or profiler modified il we should identify one or more commands to change/modify dumpmd is probably one to expose this information in the runtime this info can be found in module->m_debuggerspecificdata.m_ptemporaryilblobtablebasedomain->m_rejitmgr->m_table which is in progress of being refactored to codeversionmanager)we should also expose some basic information about whether or not a profiler is attached and what configuration flags it has set up this info can be found in:g_profcontrolblock
241780901,12714,https://api.github.com/repos/dotnet/coreclr/issues/12714,mjsabby,3,0,0,0,0,1,fixes
241342025,12680,https://api.github.com/repos/dotnet/coreclr/issues/12680,CarolEidt,0,0,0,2,0,0,in preparation for moving containment analysis to the st phase of lowering refactor most of it into separate methods for some cases e.g block stores it is more efficient to keep the logic integrated as it will move to a similarly integrated place in lowering.also remove some dead/unused code for arm
241318785,12676,https://api.github.com/repos/dotnet/coreclr/issues/12676,mikedn,3,0,0,1,0,0,this improves code generation for u)int u)long casts without overflow when the cast operand is a gt_ind node currently this is a two step process first load the value from memory and widen it to typ_int if its a small int value and then widen to typ_long this can be avoided by containing the cast operand.fixes
241302164,12674,https://api.github.com/repos/dotnet/coreclr/issues/12674,CarolEidt,1,0,0,0,0,0,this has been a todo item in the source code for some time doing the widening earlier results in more cases where we use an xor to clear a register intead of storing zero which is smaller this also helps with the refactoring of containment analysis in preparation for moving it to lowering .there are bytes of improvement over all of tests frameworks for x with no regressions on x the net improvement is bytes with methods regressing due to issues with preferencing the target of the xor
240719787,12642,https://api.github.com/repos/dotnet/coreclr/issues/12642,sandreenko,1,0,0,0,0,0,delete blockset_iter_init bitvec_iter_init varset_iter_init.it allows to have better intellisense
240701249,12639,https://api.github.com/repos/dotnet/coreclr/issues/12639,mikedn,1,0,0,0,0,0,it seems to me that rangecheck tries too hard and sometimes fails too easily and we also seem to have cases where range checks reach this phase and they are eliminated but they could have been eliminated earlier at a lower cost.im taking a look and ill use this issue to collect my observations.category:designtheme:optimizationskill-level:expertcost:large
240447352,12630,https://api.github.com/repos/dotnet/coreclr/issues/12630,gboucher90,3,0,0,0,0,0,"hello,it seems cgroup cpu share limit is not taken into account.im running a net core app into mesos on centos wether i allocate to cpus environment.processorcount always returns the actual number of processor then the threadpool doesnt really scale properly in particular i encountered deadlocks.this issue was also present in java and was fixed last year only related issue i could find is which fixes this problem when cpuset is used.it seems memory limit is correctly implemented via cgroup"
240285912,12612,https://api.github.com/repos/dotnet/coreclr/issues/12612,noahfalk,0,0,0,0,0,1,there are two aspects of this work we have pre-existing diagnostic apis/tools that need to keep working properly in spite of tiered jitting for example sos etw events complus logging stress logging icordebug and icorprofiler apis icordebug and icorprofiler are sizable and are already called out in separate work items but the remainder are lumped here for now we either need to confirm they are working as expected or fix any issues that tiered jitting caused if not we have new diagnostic scenarios specifically to diagnose issues relating to tiered jitting in this case we need to understand the state of the code versions in the runtime sos already has some rejit related functionality that could be enhanced new or adjusted etw events may be necessary new complus logging/stress logging messages would be useful questions that would be desirable for diagnostics to answer is tiered jitting enabled given code at a certain address what jit settings were used to compile it for a particular methoddesc what code versions exist if those versions have been jitted where is the code in a perf trace how much time did the runtime spend jitting each version of the code in a perf trace which cpu samples are attributable to which versions of the code?this is a bucket of likely many small items please sub-divide as needed and make new work items
240267480,12609,https://api.github.com/repos/dotnet/coreclr/issues/12609,noahfalk,2,0,0,0,0,0,we hope that tiered jitting is a useful performance improvement for nearly all projects and it will keep improving over time but there is likely to be a small set of projects that want to disable it for various reasons we need to determine and implement appropriate configuration switches to accomplish this there is some initial discussion of the topic in also likely to be useful is prior art such as configuration for ryujit when it was first introduced or gc configuration.this item does not include other more sophisticated types of configuration such as configuring the jit to replace the default tiering policy with a custom policy discussion for that is probably best left in for general brainstorming or opening a new work item to track a specific goal in that space had several suggestions for useful extensions of the work
239916127,12587,https://api.github.com/repos/dotnet/coreclr/issues/12587,yizhang82,1,0,0,0,0,0,when you are iterating on a fix/feature to make a test pass its nice to avoid build all the tests which takes forever but you still want your runtime changes to go into the runtime layout directory bin\tests\windows_nt.x.debug\tests\core_root this makes it so that we would build runtime layout even when you specify skiptests
239656327,12563,https://api.github.com/repos/dotnet/coreclr/issues/12563,swgillespie,1,0,0,0,0,0,barrier when starting up with server gc x only).the problem is triggered by this bit of code: c++void gc_heap::adjust_ephemeral_limits ephemeral_low generation_allocation_start generation_of max_generation ephemeral_high heap_segment_reserved ephemeral_heap_segment dprintf new ephemeral low ix new ephemeral high ix size_t)ephemeral_low size_t)ephemeral_high))#ifndef multiple_heaps this updates the write barrier helpers with the new info stomp_write_barrier_ephemeral(ephemeral_low ephemeral_high);#endif multiple_heaps} the change that triggered this problem added the ifndef multiple_heaps this is because at the time it was thought that ephemeral_low was not being used by any server gc write barriers since there is no single ephemeral generation it does not make sense to check them all amd does not makes use of g_ephemeral_low when using server gc at all but x unfortunately does since stomp_write_barrier_ephemeral will not be called when running with server gc the gc will complete its initialization without ever calling stompwritebarrierephemeral which is what signals the runtime to bash g_ephemeral_low and possibly also g_ephemeral_high if necessary into the write barrier.previously the runtime would be bashing as g_ephemeral_low so that all non-null pointers would have their card table bits set in the write barrier however since it was never initialized the write barrier still has the sentinel value xffff as g_ephemeral_low and will only set card table bits for pointers over that value windows rarely assigns virtual addresses as low as xffff to managed heap segments so this does not manifest when running on vanilla windows however if the kernel does place managed heap segments below that virtual address their card bits will never be set and the heap will be corrupted on the next gc.this pr remedies the startup problem by explicitly calling stompwritebarrierephemeral from gctoeeinterface::stompwritebarrier as part of the writebarrieropwritebarrierop::initialize code path which is called once from gcheap::initialize fixes
239563995,12552,https://api.github.com/repos/dotnet/coreclr/issues/12552,mikedn,3,0,0,0,0,0,contributes to
239492808,12548,https://api.github.com/repos/dotnet/coreclr/issues/12548,danwalmsley,1,0,0,0,0,0,at the moment im using a workaround to patch the file.however if i want to use a linux build server i cant do this step can this be supported natively by the dotnet sdk
239302013,12532,https://api.github.com/repos/dotnet/coreclr/issues/12532,jashook,1,0,0,0,0,0,cc sdmaclea i am expecting this to fix the arm windows jobs
239034495,12503,https://api.github.com/repos/dotnet/coreclr/issues/12503,borrrden,2,0,0,0,0,0,this issue affects uwp so im not sure that this is the correct place to file this or not but: reference to stack overflow question nearly a week of research im ready to say that the clr is causing issues on arm devices but im not quite sure why to summarize i have a c function that returns a struct with two word-sized types so a total of bytes on arm and takes two parameters both data pointers i have a p/invoke call for this function from c in which all the types are modeled after their c counterparts the procedure call standard for the arm architecture states this about return conventions a composite type larger than bytes or whose size cannot be determined statically by both caller and callee is stored in memory at an address passed as an extra argument when the function was called rule a the memory to be used for the result may be modified at any point during the function call i take that to mean that it will be the first argument to be passed into r however the clr passes the first parameter into r instead of a pointer to where the result should be stored and the second parameter in r causing invalid memory accesses net native does not produce the same issue suggesting it is limited to jitif i lie and say structlayout(layout.sequential size on the return value the problem goes away if i add a dummy int_t onto the end of the struct on both the managed and unmanaged side then the problem goes away this suggests to me that the problem only affects return values of bytes in size perhaps the clr is mistakenly applying the rules for fundamental bit types instead that would be a double-word sized fundamental data type e.g long long double and bit containerized vectors is returned in r and r.i extracted just the bad parts into a project that should reproduce the issue the behavior here is undefined so it might return but the value will be garbage pay attention to the change in value between the managed side and the native side of flencoder_finish to make this as easy as possible i precompiled the native arm dll but if you need the source it is here the pdb file should have symbol info in it running without net native causes the issue running with net native does not.this issue has been reproduced on my raspberry pi on windows iot but was originally reported from a user deploying on windows phone. spike.zip
238892147,12477,https://api.github.com/repos/dotnet/coreclr/issues/12477,mikedn,3,0,0,0,0,0,it would be useful if the jit recognized tests like if c c can be reduced to a single branch compare subtract if c c t c r c n can be reduced to branches compare bit test bt instruction)the second variant is sometimes implemented using a switch/jump table in which case is much more simpler to recognize): c#switch c case case t:case r:case n return true;default return false;} the reduction in number of conditional branches to or can make other optimizations more effective if-conversion in particular.similar issue in the roslyn repository first variant can be implemented by managed compilers but getting good code for the second is problematic if the target arch bitness is not known also the bt instruction is not available in il so it has to be simulated with shift/and/compare which the jit has to recognize.category:cqtheme:basic-cqskill-level:intermediatecost:medium
238697569,12460,https://api.github.com/repos/dotnet/coreclr/issues/12460,pgavlin,1,0,0,0,0,0,this walk performs both pre and post-order visits the pre-order visitis responsible for rewriting intrinsics as user calls where necessary;the post-order visit is resonsible for converting hir nodes into lirnodes.ive presented these changes as two commits for clarity the first commit updates the intrinsic rewriter to use the lir utilities and the second merges the two ir walks.the reason we need the pre-pass is that fgmorphargs expects to be able to create and manipulate hir including assignment nodes if we wanted to avoid the pre-/post-pass split we could instead dump all arguments to intrinsics into lclvars then pass those lclvars as arguments to the call this might speed things up further but risks impacting ra.this change causes no diffs on s.p.corelib i am currently attempting a superpmi run
238641465,12455,https://api.github.com/repos/dotnet/coreclr/issues/12455,erozenfeld,2,0,0,0,0,0,in the test case below the call from baseclass.baseclass to enumerable.empty.baseclass is not inlined either because the inliner doesnt think its profitable if we add aggressiveinlining attribute to baseclass.baseclass then first the call to baseclass.baseclass is inlined into main and then the call to enumerable.empty
238389152,12445,https://api.github.com/repos/dotnet/coreclr/issues/12445,longo-net,2,0,0,0,0,0,we have an application developed with net core preview that use entity framework with a sqlite db.the app works fine on pc with windows and linux with x cpu but if we publish it to ubuntu..-arm runtime and copy the output on raspberry pi when we try to run the app we have this error:unhandled exception system.typeinitializationexception the type initializer for microsoft.data.sqlite.sqliteconnection threw an exception system.reflection.targetinvocationexception exception has been thrown by the target of an invocation system.dllnotfoundexception unable to load dll e_sqlite the specified module could not be found.(exception from hresult xe)at sqlitepcl.sqliteprovider_e_sqlite.nativemethods.sqlite_libversion_number()at sqlitepcl.sqliteprovider_e_sqlite.sqlitepcl.isqliteprovider.sqlite_libversion_number()at sqlitepcl.raw.setprovider(isqliteprovider imp)at sqlitepcl.batteries_v.init()in the folder root there are two subfolders called x and x with inside e_sqlite.dll.could it be that the arm version of e_sqlite.dll is missing
238283658,12439,https://api.github.com/repos/dotnet/coreclr/issues/12439,pgavlin,1,0,0,0,0,0,this allows us to skip decompisition if long-typed values are not used by a method
238017186,12426,https://api.github.com/repos/dotnet/coreclr/issues/12426,Maoni0,10,0,0,0,0,0,we understand loh has been one of the pain points and id like to propose some ways to change the loh allocation behavior for the near future i would love to hear feedback if you have scenarios that could benefit from these or if you think these are hard/nonsensical to use and have other ideas id love to hear about those too note that the usage scenarios are really important here we are not looking to provide as much flexibility as possible it only adds to maintenance burden that may hinder our future development for the near future please assume that loh is still not automatically compacted except for this one scenario where we will make it automatic if you have very little survived on loh compared to gen and lohs fragmentation ratio is high eg say its fragmented and/or loh is full of objects that contain no references as the relocation is really the expensive part).the purpose of these is to specify when you dont want objects to go on loh because you know they are temporary so should not live till the next full gc which is when they are currently collected).these are not for everyone they can be dangerous and require care to use for now no need to pay attention to the names of the apis those if we decide to implement will be decided later config large object size threshold you can specify a value bytes and those will go on loh config if specified it would allocate large objects that contain no references in gen instead of on loh if you tend to allocate temporary large objects that are simple byte string you could use this api gc.allocateonsoh/gc.allocatearrayonsoh(len just allocate an object on soh regardless of the size api gc.setallocateallonsoh on current thread allocate all objects on soh after this is called till gc.unsetallocateallonsoh is calledthis is so that if you are using a library where you arent the one whos allocating but you know the large objects they allocate are very temporary.*gc.unsetallocateallonsoh on current thread revert back to normal behavior where objects larger than the threshold will go on loh.arguably you dont need api because you can just do set/unset around the individual object allocation and since allocating a large object is already expensive it would amortize the cost of setting/unsetting a flag on the thread but it makes the usage a bit nicer
236742967,12354,https://api.github.com/repos/dotnet/coreclr/issues/12354,danmosemsft,1,0,0,0,0,0,alois-xx commented on sun jun creators update delivers new apis to set the thread name should be used by the managed thread name set property as well so one can find the thread name in etw traces on windows as well currently there was no way to set the thread name for unmanaged threads with a decent api until creators update danmosemsft commented on sun jun brianrob as i understand it thread.name is just a contract between clr and the debugger and the value is stored on thread the idea is it could also setthreaddescription
236688993,12353,https://api.github.com/repos/dotnet/coreclr/issues/12353,stephentoub,4,0,0,0,0,0,iswhitespacelatin is not being inlined by changing a range check done with two comparison operations to instead be done with a subtraction and a single comparison per a suggestion from mikedn the code is shortened to not only be less expensive but also then get inlined into char.iswhitespace and then further into string.isnullorwhitespace the net result is a measurable throughput improvement for isnullorwhitespace a microbenchmark for string.isnullorwhitespace(a improves on my machine by a microbenchmark for string.isnullorwhitespace r\n\ta improves on my machine by
236632728,12346,https://api.github.com/repos/dotnet/coreclr/issues/12346,pgavlin,0,0,0,1,0,0,this change replaces the open-coded lclvar table with a class lclvartable this class provides bounds-checked indexing c++-compatible iteration etc.as this change is rather large ive divided it into three logical parts the first commit moves some lclvar-related code into a new header lclvars.h the second commit adds the lclvartable each successive commit updates a logical slice of the jit starting with common/utility code and then moving from the frontend to the code generator
236574644,12336,https://api.github.com/repos/dotnet/coreclr/issues/12336,wtgodbe,3,0,0,0,0,0,x enable running the test suite for arm on a dev box x enable running arm tests in helix
236363104,12320,https://api.github.com/repos/dotnet/coreclr/issues/12320,BruceForstall,1,0,0,1,0,0,the data stored in gentreecall under ifdef feature_multireg_ret (defined for x ryujit amd/linux arm arm was poorlypacked improving this reduces x gentreecall node size from to bytes.since gentreecall is the largest node it also reduces the size of alllarge nodes
236301634,12307,https://api.github.com/repos/dotnet/coreclr/issues/12307,stephentoub,1,0,0,0,0,0,for some reason this is resulting in measurably better throughput in particular for non-whitespace chars so much so that its visible in microbenchmarks against string.isnullorwhitespace.if nothing else its cleaner.related to
236263242,12303,https://api.github.com/repos/dotnet/coreclr/issues/12303,svick,0,0,0,0,0,1,currently the requirements for delegates are from ecma ii delegates delegates shall be declared sealed and the only members a delegate shall have are the methods as specified here.what if this requirement was weakened so that delegates were allowed to be unsealed and also allowed to contain other members especially fields i think it would allow the c compiler and other compilers to reduce the number of allocations required for lambdas that close over local variables by fusing the delegate and the closure into a single object it also might allow f to start using delegate types instead of fsharpfunc but im not sure about that.)for example consider the following c code: c#delegate int funcint();void m int i funcint f i f();} currently the generated code looks roughly like this: c#sealed class funcint multicastdelegate public extern funcint(object obj intptr method public virtual extern int invoke();}sealed class closure public int i internal int main_f this.i;}void main closure closure new closure closure.i funcint f new funcint(closure methodptr(closure.main_f f.invoke();} notice that there are two allocations for a single lambda the closure and the delegate.if the requirements for delegates were weakened the generated code could instead be: c#class funcint multicastdelegate no longer sealed public extern funcint(object obj intptr method public virtual extern int invoke();}sealed class closure funcint delegate class containing fields and custom methods public closure base(this methodptr(main_f public int i private int main_f this.i;}void main closure closure new closure closure.i funcint f closure f.invoke();} this way the two allocations are fused which should make the code more efficient.some other notes in cases when a single closure is used for multiple lambdas this would still avoid one delegate allocation but not the others i think this also shouldnt interfere with the multicasting nature of delegates since the runtime-provided fields would still be there since i believe that unsealing a class is not a breaking change unsealing framework-provided delegate types like the func and action types in some future version of the framework should be fine existing code would then become more efficient just by using a newer compiler and targeting a newer framework.what do you think
236254881,12301,https://api.github.com/repos/dotnet/coreclr/issues/12301,livarcocc,4,0,0,0,0,0,from ninofloris on june ive tried to follow the loosely translated equivalent of the linux steps but trying do plugin load libsos.dylib gives an lldb error of error plug-in is missing the required initialization lldb::plugininitialize(lldb::sbdebugger) how to proceed?_copied from original issue dotnet/cli
236233121,12297,https://api.github.com/repos/dotnet/coreclr/issues/12297,stephentoub,3,0,0,0,0,0,datetime.getdatepart is showing up in some workloads as a hot spot its used to get the year/month/day of a datetime while this pr doesnt improve the perf of an individual access there are a variety of places within corelib where all three of year/month/day are accessed together which results in three separate calls to getdatepart and ends up redoing most of the same computations each time this pr adds an alternate version of getdatepart that allows all three to be computed and returned rather than just returning one of them and then uses that helper in various places throughout corelib where all three are needed this ends up improving the throughput of various operations e.g tostring(o tostring(r addmonths addyears etc by depending on the operation i also noticed that gregoriancalendar had its own copy of this code and in an internal virtual method but nothing overrides this so i simply deleted the duplicate code and changed gregoriancalendar to just use the exposed properties year/month/day on datetime.cc tarekgh(@petermarcu fyi as this modifies the fastformatrfc and fastformatroundtrip functions you previously added
235744571,12264,https://api.github.com/repos/dotnet/coreclr/issues/12264,djluck,4,0,0,0,0,0,ive identified a situation where ryujit generates inefficient code that involve closures defined within generic methods for example given this code: public class lambdatest benchmark public string closurewithgeneric return closure_getstr(config);} the results of running the above code are:method job jit mean error stddev closurewithgeneric x-clr-legacyjit legacyjit ns ns ns closurewithgeneric x-clr-ryujit ryujit ns ns ns ryujit is about x slower than the legacy jit ive confirmed that this issue exists in dotnet core the issue seems to be caused by heavy calls to comdelegate::delegateconstruct which does not occur when using the legacy jit:! image in non-generic methods and lambdas in generic methods do not seem to be affected it is only the combination of the two
235731294,12263,https://api.github.com/repos/dotnet/coreclr/issues/12263,BruceForstall,1,0,0,1,0,0,"the lsra refposition type was not packing well in particular,bitfields dont pack unless they have the same base type.move all the data member declarations to the top and make them adjacent,so it is easier to see them all together also change all bitfieldsto unsigned char base type.this reduces the size from to bytes for x and to bytesfor x release on windows"
235648962,12250,https://api.github.com/repos/dotnet/coreclr/issues/12250,pgavlin,2,0,0,2,0,0,rather than reloading spilled constants lsra rematerialize them at thepoint of use this avoids the need to insert spill and reload code.this change also tweaks the allocators heuristics slightly constant intervals are only allocated a register at the point of def if there is an appropriate register available otherwise they are spilled and rematerialized at the point of use ref positions that are freely rematerializable are assigned the lowest possible weight
235049414,12216,https://api.github.com/repos/dotnet/coreclr/issues/12216,ellismg,1,0,0,0,0,0,these warnings have been bugging me for a while so i took a few moments to fix them
234932335,12204,https://api.github.com/repos/dotnet/coreclr/issues/12204,AndreyAkinshin,1,0,0,0,0,0,i would like to get the net core version at runtime is there a proper api?the original problem
234847421,12196,https://api.github.com/repos/dotnet/coreclr/issues/12196,alexandrnikitin,1,0,0,0,0,0,this is a poc to to make int.parse faster for cases.the fast path only handles the numberstyles.integer style sign leading and trailing whitespaces)this is a draft version i will polish it if theres interest to have it in clr it reuses two functions matchchars and iswhite i believe its possible to make it faster some magic with the loop and conditions get rid of unsafe code and matchchars function it also possible to improve all cases where numberstyles.integer used pushed initial benchmarks to a separate repo i didnt manage to do them in the coreclr repos benchmark results method mean error stddev onedigit ns ns ns maxvalue ns ns ns sign ns ns ns whitespaces ns ns ns fasteronedigit ns ns ns fastermaxvalue ns ns ns fastersign ns ns ns fasterwhitespaces ns ns ns not sure whats wrong with the whitespaces case related issues who participated in previous discussions jkotas varocarbas hughbe danmosemsft jakobbotsch mikedn
234795550,12193,https://api.github.com/repos/dotnet/coreclr/issues/12193,noahfalk,4,0,0,0,0,0,do not merge this is heads up only this is a continuation of the tiered compilation work trying to establish net code versioning on generally more sound footing in particular resolving issues between rejit and tiered compilation.please see code-versioning-pr-notes.md for info
234758134,12192,https://api.github.com/repos/dotnet/coreclr/issues/12192,janvorli,2,0,0,0,0,0,currently when coreclr is built on a machine with libnuma dev package installed it gets explicit dependency on libnuma so it wont run on a linux without this library installed i would like to eliminate this hard dependency and make it soft by loading the libnuma via dlopen if it is present but working fine without any numa support if the library is not installed
234660062,12177,https://api.github.com/repos/dotnet/coreclr/issues/12177,sandreenko,1,0,0,0,0,0,"delete the workaroung for g c that was fixed in gcc manyyears ago.the workaround makes code dirty and sometimes we have typos like: };end_declare_typed_enum(insflags,unsigned) or end_declare_typed_enum(chunkextraattribs byte); with double"
234339991,12146,https://api.github.com/repos/dotnet/coreclr/issues/12146,briansull,1,0,0,0,0,0,we should either fix or hide this warningto repro:crossgen system.private.corelib.dll
234286167,12138,https://api.github.com/repos/dotnet/coreclr/issues/12138,pgavlin,2,0,0,1,0,0,just what it says on the tin
234248509,12135,https://api.github.com/repos/dotnet/coreclr/issues/12135,tannergooding,5,0,0,0,0,0,there are certain code patterns that are explicitly recognized by the jit which will get optimized into more optimal instructions.as an example ryujit now recognizes a few common patterns which get optimized into the rotate hardware instructions rather than separate shiftleft shiftright instructions there are always caveats to each pattern which may cause the runtime to not inline it if the code is slightly different for example to rotate a signed integer you need to cast to unsigned before performing the shift operations this is required so that the shift operations cause zero-extension rather than sign-extension for negative numbers.it would be immensely useful if the set of patterns recognized by the jit were documented and accessible this would not only be beneficial to those who are writing performance minded code but it would also be beneficial to contributors so we can easily see what other patterns are worth recognizing.category:documentationtheme:optimizationskill-level:expertcost:large
234052469,12122,https://api.github.com/repos/dotnet/coreclr/issues/12122,BruceForstall,1,0,0,0,0,0,this is not required in ryujit at the codegen phase comma andvalue-producing nops are no longer in place
234039731,12120,https://api.github.com/repos/dotnet/coreclr/issues/12120,tannergooding,5,0,0,0,0,0,rationaletoday the runtime supports the fastcall calling convention which not only allows interop with any native code that uses that calling convention but also allows it to take advantage of the additional registers that are available on the underlying architecture.however it means that operating with certain data types is still sub-optimal.microsoft windows provides the vectorcall calling convention just for this purpose it extends the existing fastcall calling convention to additionally allow simd vector types and homogeneous vector aggregate values to be passed via register rather than on the stack.the system v amd abi already defines vector sized types m m and supports passing them in register proposalthe runtime should add support for the vectorcall calling convention not only to improve performance but to also provide better interop with native code that uses it.the vectorcall calling convention should be exposed on system.runtime.interopservices.callingconvention as vectorcall
233687892,12090,https://api.github.com/repos/dotnet/coreclr/issues/12090,tannergooding,1,0,0,0,0,0,rationale performing a multiplication followed by an add is a frequent operation in code d a b c and modern processors provide instructions to help perform this operation in a fast/efficient manner. proposal the runtime should be updated to recognize the d a b c pattern and emit fma instructions in those scenarios.this pattern should be handled for both scalar and vector operations float double vector
233399914,12074,https://api.github.com/repos/dotnet/coreclr/issues/12074,stephentoub,1,0,0,0,0,0,repro: c#using system;using system.diagnostics;public class test public static void main console.writeline console.writeline debugger.launch console.writeline console.writeline with net framework i can compile this run it from the console and the debugger.launch pops the attach dialog asking which vs i want to use and which debugging engine to employ im then in the debugger broken into the app on the launch line and i can successfully f to step to the writeline for and with net core built with the latest source the same thing happens up until the debugger breaking in vs opens but i have to manually hit the pause button to break into the app then i find myself on the launch line but neither f nor f work successfully instead they start running the app again but no forward progress is made and breaking in again reveals being on the same line with this stack ntdll.dll!ntwaitformultipleobjects unknown kernelbase.dll!waitformultipleobjectsex unknown managed to native transition tmpapp.dll!test.main line c native to managed transition corerun.exe!ffcffa unknown corerun.exe!ffcfdc unknown corerun.exe!ffcfc unknown kernel.dll!basethreadinitthunk unknown ntdll.dll!rtluserthreadstart unknown thats the case with both vs and vs and with selecting the managed coreclr debug engine.am i missing some component thats supposed to make this work
233002639,12039,https://api.github.com/repos/dotnet/coreclr/issues/12039,omajid,0,0,0,1,0,0,add a build flag to make werror optional and let the build continue even in the presence of warnings.this option is very useful for anyone compiling with a different version of the compiler a different version of the compiler may produce a different set of warnings and a piece of code that compileswithout warnings may emit warnings with a different version of the compiler.resolves
232582862,12007,https://api.github.com/repos/dotnet/coreclr/issues/12007,vectorix,6,0,0,0,0,0,with the announcement of skylake-x avx is going mainstream.the clr should emit avx vector instructions that system.numerics.vector
231850783,11952,https://api.github.com/repos/dotnet/coreclr/issues/11952,mikedn,3,0,0,0,0,0,why are operator symbols used in jit dumps it seems to me that they hurt readability because theyre easy to miss due to tree lines which are also displayed using such symbols and whats the point of using oper names that are different from the one used in the source code?in short the following looks better to me stmt void il x...x cast int char long cns_int long add long lcl_var long v loc a-xg asg short x-+-n ind short cns_int long lsh long cast long int lcl_var int v loc add int lcl_var int v arg add long lcl_var long v arg than stmtexpr void il x...x cast int char long const long long lclvar long v loc a-xg short x-+-n indir short const long long cast long int lclvar int v loc int lclvar int v arg long lclvar long v arg
231782206,11948,https://api.github.com/repos/dotnet/coreclr/issues/11948,vermorel,6,0,0,0,0,0,the clr would greatly benefit from adding support the half-precision floating-point numbers.the half-precision floating-point numbers are already extensively used in machine learning and image processing applications even if it the clr is only meant for interacting with a native machine learning framework the lack of a system.half number means that those needs to be emulated which is very inefficient especially considering that both arm and x have built-in support for half-precision floating point numbers.emulation can be done ala c half for example but my own experiments hinted about x slower compared to native performance then i wasnt even using dedicated simd which are likely to add another x performance factor bringing to x between emulated and native on high-end processors
231477641,11920,https://api.github.com/repos/dotnet/coreclr/issues/11920,briansull,0,0,0,1,0,0,this check is not needed on coreclr and blocks some valuable usage cases.fixes
231466200,11919,https://api.github.com/repos/dotnet/coreclr/issues/11919,pgavlin,1,0,0,0,0,0,just what it says on the tin
231379493,11912,https://api.github.com/repos/dotnet/coreclr/issues/11912,mikedn,1,0,0,0,0,0,init-tools.cmd attempts to create a file in a directory that doesnt exist file creation fails and next time the script is run initialization will be performed again that wastes a lot of time
231203204,11901,https://api.github.com/repos/dotnet/coreclr/issues/11901,CarolEidt,0,0,0,1,0,0,eliminate the use of gtf_reg_val in ryujit and reuse the bit to mark nodes as contained.abstract gtf_reg_val for legacy backend.important note about gtf_reg_val this is used in legacy_backend in most cases to record during code generation whether code has been generated to produce the value in a register it is checked in various places to determine the type of code to generate.in the ryujit backend it was only set on lclvar nodes and then only served as a redundant indicator that the var is in a register changing the places where it is checked to assert that it is zero produced no diffs this also pointed out numerous areas of dead code note also that the ryujit backend always knows based on containment and register allocation decisions whether it is generating operations from the stack or registers.also the updating of gc register sets is taken care of by genconsumereg and genproducereg
230928089,11869,https://api.github.com/repos/dotnet/coreclr/issues/11869,Toxantron,2,0,0,0,0,1,"this is just an idea and i hope it is not a duplicate but as far as i understand the simd optimizations in system.numerics only run on the cpu and are limited to predefined operations like add multiply and some other common vector and matrix operations proposes decoupling the cpu optimized apis from the predefined methods but still only considers the cpu as a target.i thought of something like the example below no the code does not make any sense it could probably be rewritten to make use of system.numerics and a lot of steps could be merged to improve big o behavior i only chose it as a random example that probably does not exist in the system.numerics api. cs runongpu private static uint awesomefoo(uint a uint bs uint cs var buffer new uint bs.length cs.length parallel.for bs.length i buffer i a bs i parallel.for cs.length j buffer i,j bs i cs cs.length j a var reduced new uint bs.length parallel.for bs.length i var value buffer i for var j j cs.length j var index i j bs.length value buffer index j j return reduced;} i am no expert in gpu computing nor the internals of the jit but as far as i understand it we could offer specialized versions of the coreclr that make use of either nvidia amd or adreno gpus when the jit finds such a method it would check some requirements like datatypes used apis etc and decide wether it can be translated into gpu code or not using cuda as an example it would than reserve gpu memory cudamalloc for the arguments local variables and return values use cudamemcpy to copy the data and then translate the anonymous methods of parallel.for into cuda kernels translate the code and after execution is complete copy back the result and release the reserved memory cudafree as on optimization the coreclr could reserve a dynamic amount of gpu memory similar to the way the gc does it with the normal ram but at least for cuda i think there already is some sort of pooling.reasons to do this it would be an awesome feature it would enable a range of applications from automation and banking to ai and gaming to develop entirly in c and still benefit from latest gen hardware using this internally could improve performance of current apis by moving the code into gpu optimized private methods without any breaking changes.reasons not to do this this is probably insanely complicated users need to pick the right coreclr for the gpu or detect and self-compile to get the full benefits.category:proposaltheme:big-betsskill-level:expertcost:extra-large"
230589796,11816,https://api.github.com/repos/dotnet/coreclr/issues/11816,RossNordby,3,0,0,0,0,0,ive run into some unnecessary initializations on struct locals with definitely assigned fields plus some more when inlining is thrown into the mix this is showing up in profiles of some inner loops on my main test case the initializations end up zeroing almost megabytes every frame its not a huge slowdown about but it would be nice to avoid.a few test cases struct local within a function with noinlining called in a loop. cs struct structtype public vector
228760879,11606,https://api.github.com/repos/dotnet/coreclr/issues/11606,JosephTremoulet,10,0,0,3,0,0,im creating tracking issues for some optimizations that ryujit doesnt perform so well have a place to reference/note when we see the lack of them affecting particular benchmarks)theres code in the jit today that goes by the name loop unrolling but its only doing full unrolls and only for simd loops general loop unrolling to balance alu ops vs branching is not performed by the jit at all today.category:cqtheme:loop-optskill-level:expertcost:extra-large
228749791,11605,https://api.github.com/repos/dotnet/coreclr/issues/11605,chanan,1,0,0,0,0,0,sorry if this is the wrong repo.in vs update i start a brand new project add docker support hit run and get the following error: --------------------------------------------------------------------------------you may only use the microsoft net core debugger vsdbg with visual studiocode visual studio or visual studio for mac software to help you develop andtest your applications.--------------------------------------------------------------------------------realpath invalid argumentthe specified framework microsoft.netcore.app version was not found check application dependencies and target a framework version installed at usr/share/dotnet/shared/microsoft.netcore.app the following versions are installed alternatively install the framework version the program has exited with code x
228493483,11594,https://api.github.com/repos/dotnet/coreclr/issues/11594,mikedn,2,0,0,0,0,0,the c compiler translates code like x y to x y because the behavior of il shift operations is unspecified if the shift count is greater than or equal to the bit width of the shifted value however x/x shift instructions do mask the shift count so is redundant.its also possible that developers also mask the shift count not knowing that the c language specification guarantees masking in that case we end up with and x instructions
228460136,11589,https://api.github.com/repos/dotnet/coreclr/issues/11589,mikedn,1,0,0,0,0,0,for unknown reasons gentreeaddrmode::gtoffset is unsigned rather than int on bit hosts this doesnt really matter but on bit hosts we end up zero extending instead of sign extending it gettreeindir::offset does that by casting from unsigned to size_t .it doesnt appear possible for this to cause correctness issues because the address mode displacement is bit anyway but its confusing and hurts cq because the emitter cant recognize small negative displacements that can be encoded in a single byte.its worth noting that codegen::gencreateaddrmode uses ssize_t internally to represent the offset but then returns it as unsigned the emitter works with either int or ssize_t displacements e.g emitins_r_arx co have int disp arguments emitnewinstramd has ssize_t dsp argument)contributes to
228353320,11551,https://api.github.com/repos/dotnet/coreclr/issues/11551,brianrob,1,0,0,0,0,0,especially in eventsource we go through a good amount of work to make provider ids strings so that they are human readable we should do this in eventpipe as well
228310440,11545,https://api.github.com/repos/dotnet/coreclr/issues/11545,sdmaclea,0,0,0,0,0,1,briansull russkeldorph im not an expert but i believe dmb st is not useful for either the acquire or the release semantics of volatile i believe the armv acq/rel variants of load/store instructions are exactly what we want for arm from the armv architecture reference manual read or a write rw is barrier-ordered-before a read or a write rw from the same observer if and only if rw appears in program order before rw and any of the following cases apply rw appears in program order before a dmb full that appears in program order before rw rw is a write w generated by a store-release instruction and rw is a read r generated by a load-acquire instruction rw is a read r and either r appears in program order before a dmb ld that appears in program order before rw r is generated by a load-acquire instruction rw is a write w and either rw is a write w appearing in program order before a dmb st that appears in program order before w w is generated by a store-release instruction rw appears in program order before a write w generated by a store-release instruction and w is coherence-after w. if you read this carefully you will notice that these sequences are functionally identical for our purposes load-acquire load load dmb ld load load-acquire store load dmb ld store load store-release load dmb full store store store-release store dmb full store there is one exception but i am asserting it is not important for our purposes ordered store-release load-acquire unordered dmb full store load dmb ld therefore load-acquire load dmb ld store-release dmb full store however the load-acquire and store-release are less flexible only the most basic addressing form is supported i.e ldar xt xn or stlr xt xn must use aligned accesses no support for loading into floating point registers no sign extended forms so i am proposing replace dmb sy} with dmb ld when appropriate this would be done by adding a parameter to instgen_memorybarrier which defaulted to full use ldar*/stlr forms only when they are drop in replacements for the ldr*/str not contained address in a register not loading into floating point registers not sign extending aligned ldarb stlrb byte size forms not gtf_ind_unaligned if we believe it guarantees aligned access.) plan i had been working on using load-acquire store release forms more extensively this proposal represents my abandonment of that brute force attempt.i will implement and then if it works.category:correctnesstheme:barriersskill-level:intermediatecost:medium
227855565,11521,https://api.github.com/repos/dotnet/coreclr/issues/11521,JosephTremoulet,2,0,0,0,0,0,generalize and rename the assertion/limit code for tracking arraylengths which have until now been recognized by the vnfunc beinggt_arr_length to track all values that appear in the function aslength arguments to bounds chcks nodes add a hashtable to identify thatset of value numbers m_checkedboundvns to the vnstore object andpopulate it during value-numbering wherever names were adjusted thegeneralization of array length is called checked bound.this allows the array bound check removal machinery to operate on spanbound checks as well
227793873,11501,https://api.github.com/repos/dotnet/coreclr/issues/11501,sdmaclea,1,0,0,0,0,0,for platforms with loose memory ordering semantics the il volatile prefix requires injection of explicit barriers.no tests currently exercise cpblk and initblk with volatile prefix.category:correctnesstheme:testingskill-level:intermediatecost:medium
227705309,11494,https://api.github.com/repos/dotnet/coreclr/issues/11494,berets76,1,0,0,0,0,0,hi after nuget packages update i got this warning vs error list detected package downgrade microsoft.netcore.app from to myaspnetcoreproject microsoft.visualstudio.web.codegeneration.design microsoft.netcore.app myaspnetcoreproject microsoft.netcore.app actual situation! image trying to change target platform to netcoreapp but in the project properties dialog the combo contains only and i installed dotnet-dev-win-x....exe
227453324,11471,https://api.github.com/repos/dotnet/coreclr/issues/11471,russellhadley,3,0,0,0,0,0,new pass is intended to exploit machine dependent instructions and allow for low level optimization based on specific instruction semantics.goals run before register allocation to remove issues with false dependencies and allow reduction in register pressure exploit specific features of the target isa including but not limited to immediate encoding size/shift semantics particular condition flag implementation target dependent address mode formation allow more sophisticated instruction selection bt{s|r|c formation aggressive optimization around condition flag/branch sequences avoid machine glass jaws like lcp reorder/rework instructions to reduce register pressure.particular open questions which dataflow formulation should be used adjacent in window expression temp def/use unaliased ssa or some cheaper extended basic block approximation run just before ra or at higher tier run after how to encapsulate a transform how to enforce a high level of debug dump/tracing functionality for managing the transforms.this is a big and perhaps controversial feature but is intended to allow for more proactive engagement on code selection opts for collaborators with interests in particular targets.category:designtheme:optimizationskill-level:expertcost:extra-large
227199267,11460,https://api.github.com/repos/dotnet/coreclr/issues/11460,russellhadley,1,0,0,0,0,0,at code gen time after ra analyze the register values as the code is generated to remove redundancies.r mov rr mov rr add r rx where r or r is either opportunistically show to be anticipated or known to be dead r add r rx in addition simple spill elission can be done via tracking unaliased slots on the stack spills) rsp spill mov r...r mov rsp spill rsp spill mov r...r mov rthis pass should be run when there is throughput budget after the ra to clean up any remaining local opportunities before the code is emitted category:designtheme:optimizationskill-level:expertcost:large
227197339,11458,https://api.github.com/repos/dotnet/coreclr/issues/11458,russellhadley,1,0,0,0,0,0,today we arent as aggressive about building address modes for the target architecture dont forward substitute through local vars inconsistent use of all the features target isasome examples are here show in hot methods in kestrel.at a high level this is a big design challenge a solution will have the following criteria addresses will be shaped by the features of the hardware they will be different trees on different platforms on arm variants the knowledge of the legal immediate ranges and shift semantics can have a big impact of code size/speed address modes will be formed before ra to reduce register pressure address modes will have trade off knobs for varying throughput envelopes tiers)category:designtheme:basic-cqskill-level:expertcost:extra-large
227158750,11453,https://api.github.com/repos/dotnet/coreclr/issues/11453,bricelam,1,0,0,0,0,0,there seems to be an arbitrary limitation on core clr that prevents you from calling appdomain.setdata more than once for the same name.this limitation doesnt exist on net framework.we use appdomain.setdata in our tests to check our usage of appdomain.getdata we typically clean up after the test by passing null but this throws.we discovered this by attempting to run our net framework test code on net core app
226926238,11442,https://api.github.com/repos/dotnet/coreclr/issues/11442,KarenHuang2016,1,0,0,0,0,0,when we try to clean coreclr source repository it failed due to error filename too long we must delete the file manually could you please help to take a look at this thanks weve cloned coreclr to d:\coreclr\src and built it successfully before cd d:\coreclr\src git reset hardhead is now at baeded reenable mapviewoffile pal test git clean xdfremoving tools/removing bin/removing binclash.logremoving init-tools.logremoving packages/runtime.debian.-x.microsoft.private.corefx.netcoreapp/..-preview--/sources/bin/obj/anyos.anycpu.release/microsoft.csharp removing tests/src/jit/config/benchmark/project.lock.jsonremoving tests/src/testwrappersconfig/project.lock.jsonremoving tests/src/performance/project.lock.json warning could not stat path packages/runtime.ubuntu..-x.microsoft.private.corefx.netcoreapp/..-preview--/sources/bin/obj/anyos.anycpu.release/system.runtime.interopservices.windowsruntime/netcoreapp/system.runtime.interopservices.windowsruntime.notsupported.cs filename too long
226911924,11440,https://api.github.com/repos/dotnet/coreclr/issues/11440,SergeyTeplyakov,1,0,0,0,0,0,os win but most likely os agnostic)..net net coreclrrelease builds only.issue jit and gc are working together to track lifetime for local variables in release mode if the local or argument is no longer used inside the method an object can become reachable for garbage collection assuming that this was the last reference this optimization is only available in release mode.consider following case: csharp methodimpl(methodimploptions.noinlining) static void checkreachability(object d var weakref new weakreference(d console.writeline(calling gc.collect gc.collect string message weakref.isalive alive dead console.writeline(object is message);} methodimpl(methodimploptions.noinlining) static void foobar methodimpl(methodimploptions.noinlining) static void withwhilebutworking(object d bool condition foobar while condition foobar checkreachability(d);}static void main(string args withwhilebutworking(new object false);} consider withwhilebutworking method the method does some stuff this stuff is actually matters and then calls checkreachability(d this is the only place where d argument is used.in this case jit constructs a pointer table or gcinfo table that gives the gc an ability to track instance lifetime in this particular case the table gives the gc enough information to decide that the instance passed to checkreachability method is no longer reachable inside method withwhilebutworking and can be collected and indeed calling this method in release mode gives an expected output: calling gc.collect...object is dead (remember this should be release build and you should run this without vs attached).now lets change a method a little bit: csharp methodimpl(methodimploptions.noinlining) public static void withwhilenotworking(object d bool condition foobar while condition checkreachability(d);} method is exactly the same but while loop is empty and the output is: calling gc.collect...object is alive again this is reproducable only on release builds with no debugger attached and only on bit executables!so my assumption was something is wrong with jit and this pointer table ive tried to validate my assumption with windbg but it seems that the output for bit processes for command gcinfo is a bit weird and doesnt show enough information to make this decision is it a known issue so ive built a coreclr manually created net core app and ran the app with jit trace enabled.here what ive got normal case after end code gen before unwindemit()g_m_ig func offs=h size=bh gcrefregs byrefregs byref nogc prolog iginb push rdiinc push rsiind sub rsp ine mov rdi rcxinf mov esi edxg_m_ig offs=bh size=dh gcrefregs rdi byrefregs byref iszin b call reachability.program:foobar()in movzx rsi silin test esi esiin je short g_m_igg_m_ig offs=h size=h gcrefregs rdi byrefregs byref iszin call reachability.program:foobar()in d test esi esiin f jne short g_m_igg_m_ig offs=h size=h gcrefregs rdi byrefregs byrefin mov rcx rdiin call reachability.program:checkreachability(ref)ina nop g_m_ig offs=ah size=h epilog nogc emitaddin a add rsp in e pop rsiin f pop rdiin ret register slot id for reg rdi set state of slot at instr offset xb to live.set state of slot at instr offset x to dead.set state of slot at instr offset x to live.set state of slot at instr offset xd to dead error case g_m_ig func offs=h size=bh gcrefregs byrefregs byref nogc prolog igin push rdiin push rsiina sub rsp inb mov rdi rcxinc mov esi edxg_m_ig offs=bh size=h gcrefregs rdi byrefregs byrefin b call reachability.program:foobar()in movzx rcx silg_m_ig offs=h size=dh gcrefregs rdi byrefregs byref iszin test ecx ecxin jne short g_m_igin mov rcx rdiin b call reachability.program:checkreachability(ref)in nop g_m_ig offs=h size=h epilog nogc emitaddind add rsp ine pop rsiinf pop rdiin ret set outgoing stack arg area size to register slot id for reg rdi register slot id for reg rcx set state of slot at instr offset x to live.set state of slot at instr offset xb to live.set state of slot at instr offset x to dead.set state of slot at instr offset x to dead what the difference?the main difference is in variable lifetime emitted by the jitter in the second case when the object stays alive all variable are stayed alive till instruction x i.e after the call to checkreachability .category:correctnesstheme:gc-infoskill-level:intermediatecost:medium
226834533,11436,https://api.github.com/repos/dotnet/coreclr/issues/11436,jkotas,1,0,0,0,0,0,fixes and deletes cleanuptodolist.cs
226650783,11423,https://api.github.com/repos/dotnet/coreclr/issues/11423,jashook,1,0,0,0,0,0,build tests with arm runs and upload/run them to the arm testmachines
226422076,11407,https://api.github.com/repos/dotnet/coreclr/issues/11407,CarolEidt,2,0,0,0,0,1,when a struct is small enough to fit into a register and is only accessed in its entirety e.g to initialize or pass as an argument it should be fully enregistered below is a simple test case that was provided with a bug filed against the desktop version it should generate simply xor eax ret on x and x but instead generates many unnecessary copies it is addressed by full enregistration of structs that fit into a register see work item in foo public byte b b b b static foo getfoo return new foo category:cqtheme:structsskill-level:expertcost:large
226352843,11391,https://api.github.com/repos/dotnet/coreclr/issues/11391,danwalmsley,5,0,0,0,0,0,"if i build from command line it works.but from latest vs preview i get:...project targets netstandard,version=v it cannot be referenced by a project that targets netcoreapp,version=v..is the a workaround for now"
226336349,11390,https://api.github.com/repos/dotnet/coreclr/issues/11390,AndyAyersMS,3,0,0,0,0,0,if a fixed pointer is used to construct a span we can see extra register shuffles as a value is cast in and out of gc b mov rax bword ptr rsp+h bf mov rsi rax bc mov rax rsi bf mov rsi rax see notes and source code in dotnet/corefxlab
226144639,11377,https://api.github.com/repos/dotnet/coreclr/issues/11377,BruceForstall,2,0,0,0,0,0,these new functions can sometimes be shared as they are identical orvirtually so.in addition the driver function gencodefortreenode has beenmade common
226052521,11365,https://api.github.com/repos/dotnet/coreclr/issues/11365,dmh2000,1,0,0,0,0,0,using system summary on some windows systems this program prints the wrong value it is configured as an x build in visual studio on all systems tested it prints the correct value if it is configured as an x build in visual studio or if it is run using the visual studio debugger built using visual studio with update on windows pro the incorrect print only occurs on some windows systems others work correctly we have not found a correlation on which machines work and which dont installing net did not help on the offending machines the error also occurs depending on how many values are in the array see comments namespace crc class crc bit crc table public static uint ccittcrc_table in bit build delete the last word xb and the output is correct leave it in and the output is incorrect e x x x xb class program static void main(string args if the build property specifies x or prefer bit and runing from command line on some systems this prints correct value on other systems this prints incorrect value e if the build property is x or executing x version in visual studio debugger it works correctly on all systems console.writeline(crc.ccittcrc_table .tostring(x crc.il.txt
225845724,11349,https://api.github.com/repos/dotnet/coreclr/issues/11349,CarolEidt,1,0,0,0,0,0,consider preferring smaller encoding sizes for high ref count and larger encoding sizes for small ref count.(this issue was migrated from the desktop bug tracking system.)category:cqtheme:register-allocatorskill-level:expertcost:medium
225808014,11338,https://api.github.com/repos/dotnet/coreclr/issues/11338,benaadams,3,0,0,0,0,0,so i want to use x including x server gc but id like to turn up its recycle aggressiveness a little.for example if i run the same server app as x it will hover around gb whereas as x it will hover around mb private working set actual active managed memory in both will be similar and an order of magnitude lower than x having gb ambient use isnt greatly a problem as am running on a server with plenty of ram however it makes it hard to determine correct multi-service loading/homing balance.i.e when working out where to re-home services across a cluster the two major general coarse-grained metrics youll use are the general behaviours around cpu use and ram use but with ram use being much higher is can make estimating this harder and increasing service density more tricky.im aware allowing more ambient ram use means less frequent gcs so it wouldnt apply to all services also im aware you can limit using job objects im looking for something more of an api or configuration setting like threadpool min threads but for memory where below that threshold its happy to do as it does now and above it moves into a more aggressive reclamation mode kind of like job object but without the hard stop and without the extra setup.dont have a formal proposal on what the right approach would be as im not sure hoping others might.../cc maoni
225755870,11333,https://api.github.com/repos/dotnet/coreclr/issues/11333,gkhanna79,1,0,0,0,0,0,jkotas ptal
225683863,11330,https://api.github.com/repos/dotnet/coreclr/issues/11330,fubar-coder,1,0,0,0,0,0,maybe its the ideal time to add non-nullable reference types when the clr already needs to be changed for this would allow dotnet/csharplang to avoid the creation of if referenceequals(x null throw code which would penalize the usage of non-nullable references
225222597,11305,https://api.github.com/repos/dotnet/coreclr/issues/11305,briansull,1,0,0,0,0,0,here is the relevent portion of my builds log file e:\fxkit\coreclr\bin\logs\coreclr_windows_nt__x__checked.log custombuild coreclr microsoft r c/c optimizing compiler version for x copyright c microsoft corporation all rights reserved daccess.cpp microsoft r clr external data access data table generator version copyright c microsoft corp all rights reserved buildmsg system.runtime.interopservices.comexception x retrieving the com class factory for component with clsid bfcea-f-bb-f-bafcd failed due to the following error class not registered exception from hresult x regdb_e_classnotreg at dia.util.diafile..ctor(string pdbfile string dllfile at pdbsymbolprovider..ctor(string symbolfilename string dllfilename at shell.domain(string args at shell.main(string args c:\program files x)\microsoft visual studio\\enterprise\common\ide\vc\vctargets\microsoft.cppcommon.targets error msb cmd.exe exited with code e:\fxkit\coreclr\bin\obj\windows_nt.x.checked\src\dlls\mscoree\coreclr\inject_debug_resources.vcxproj done building project e:\fxkit\coreclr\bin\obj\windows_nt.x.checked\src\dlls\mscoree\coreclr\inject_debug_resources.vcxproj default targets failed
225163769,11298,https://api.github.com/repos/dotnet/coreclr/issues/11298,danmosemsft,2,0,0,0,0,0,kathleendollard commented on tue apr current message is bad image format this doesnt encourage the developer to check for mismatched targets additional text can resolve this problem.---@karelz commented on tue apr think it belongs into coreclr repo
225163026,11297,https://api.github.com/repos/dotnet/coreclr/issues/11297,DrewScoggins,1,0,0,0,0,0,adding instructions for running the performance tests locally
225140715,11293,https://api.github.com/repos/dotnet/coreclr/issues/11293,russellhadley,6,0,0,0,0,0,perform full pass of unreachable code removal after global assert/const prop category:cqtheme:optimizationskill-level:intermediatecost:medium
224947436,11279,https://api.github.com/repos/dotnet/coreclr/issues/11279,danwalmsley,17,0,0,0,0,0,i noticed this and got the exception this be implemented in netcore current windows builds this works fine
224909178,11266,https://api.github.com/repos/dotnet/coreclr/issues/11266,jkotas,0,0,0,0,0,2,fix and
224632505,11248,https://api.github.com/repos/dotnet/coreclr/issues/11248,gkhanna79,1,0,0,0,0,0,hqueue jyoungyun hseok-oh i wanted to share some additional data with you all since we forked for release/...we are working towards getting all bugs identified to be fixed for net core preview and rtm release by for coreclr corefx and core-setup repos please plan to get your fixes in the respective master branches by eod pst.after master branch contents will be pushed into respective release/..branches and master version will become any fixes required for release post we will be taking fixes in release branches but they would be subject to higher bar for any such fixes that you deem need to be made i would suggest the following make the pr against release branch and cc leecow and me have the pr description detail the importance of getting the change in.likewise if you have any fixes that need to go into preview which is what release branch is versioned as right now please follow the same process the timeline for those is eow.please share this with your team as well and do let me know if you have any questions.cc leecow weshaggard richlander petermarcu shawnro
224588318,11233,https://api.github.com/repos/dotnet/coreclr/issues/11233,sandreenko,2,0,0,0,0,0,"do not allocate new buffer each time when we call clear for bitset.it removes quadratic memory consumption for predecessors in lsra n n size were allocated where n is the number of blocks).use the same preallocated buffer for lsra preds.there are no spmi asm diffs.fix it allocated gb of memory now it takes mb,ptal dotnet/jit-contrib as i understand i have to merge it into the release branch too"
224298561,11218,https://api.github.com/repos/dotnet/coreclr/issues/11218,AndyAyersMS,1,0,0,0,0,0,"if caller passes a directly substitutable expression whosetype is compatible with but not the same as the callee argument type,and that argument is the callees return value the jit mayreject inlining the method because of a return type mismatch.fix is to retype the expressions we use in the callees bodyas the callees type.closes"
224266103,11209,https://api.github.com/repos/dotnet/coreclr/issues/11209,erozenfeld,1,0,0,0,0,0,"the narrowing can be applied to gt_sub gt_not gt_neg and gt_lsh in addition togt_add gt_mul gt_and gt_or and gt_xor that were already supported.jit-diff reports:no diffs in benchmarks.frameworks: summary:(note lower is better)total bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes system.private.corelib.dasm of base system.text.encoding.codepages.dasm of base system.runtime.extensions.dasm of base system.runtime.numerics.dasm of base system.io.compression.dasm of base total files with size differences improved regressed).top method improvements by size bytes system.runtime.extensions.dasm bufferedstream:seek(long,int):long:this system.runtime.numerics.dasm bigintegercalculator:square(int,int,int,int system.text.encoding.codepages.dasm decoderfallbackbufferhelper:internalfallback(ref,int):int:this system.private.corelib.dasm resourcereader:getresourcedata(ref,byref,byref):this system.private.corelib.dasm filestream:seek(long,int):long:this total methods with size differences improved regressed). tests: summary:(note lower is better)total bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes jit\methodical\int\arrays\_il_dbglcs_long\_il_dbglcs_long.dasm of base jit\methodical\int\arrays\_il_dbglcs_ulong\_il_dbglcs_ulong.dasm of base jit\methodical\int\arrays\_il_rellcs_long\_il_rellcs_long.dasm of base jit\methodical\int\arrays\_il_rellcs_ulong\_il_rellcs_ulong.dasm of base jit\methodical\unsafecsharp\_dbgunsafe-\_dbgunsafe-.dasm of base total files with size differences improved regressed).top method improvements by size bytes jit\methodical\int\arrays\_il_dbglcs_long\_il_dbglcs_long.dasm lcs:findlcs(ref,ref,ref,ref jit\methodical\int\arrays\_il_dbglcs_ulong\_il_dbglcs_ulong.dasm lcs:findlcs(ref,ref,ref,ref jit\methodical\int\arrays\_il_rellcs_long\_il_rellcs_long.dasm lcs:findlcs(ref,ref,ref,ref jit\methodical\int\arrays\_il_rellcs_ulong\_il_rellcs_ulong.dasm lcs:findlcs(ref,ref,ref,ref jit\regression\clr-x-jit\v-m.-pdc\b\b\b.dasm ilgen_:main():int total methods with size differences improved regressed). im not planning to merge this until after the stabilization./cc dotnet/jit-contrib"
223913941,11180,https://api.github.com/repos/dotnet/coreclr/issues/11180,DrewScoggins,1,0,0,0,0,0,this adds a run that will fire on the set of azure vms and will only runfor one interation this along with the changes to fail a performancerun if a test fails will allow us to start gating checkins on theperformance tests still running
223866440,11176,https://api.github.com/repos/dotnet/coreclr/issues/11176,BruceForstall,0,0,0,1,0,0,parjong ptal
223835603,11173,https://api.github.com/repos/dotnet/coreclr/issues/11173,mmayr-at,1,0,0,0,0,0,with the profiling api one can rewrite il code with the icorprofilerinfo::setilfunctionbody method at runtime i am using this to dynamically generate il code to instrument methods of certain types including types in mscorlib im looking now for a way to verify the dynamically generated il code.i know that peverify can be used to validate metadata and il type safety i could save all assemblies with modifed il code to disk and run them through peverify there are several problems with this approach peverify does not work with mscorlib c:\windows\microsoft.net\framework\v..>peverify mscorlib.dllmicrosoft r net framework pe verifier version copyright c microsoft corporation all rights reserved.il verification cannot be performed on system library mscorlib.dllall classes and methods in mscorlib.dll verified there are framework assemblies with metadata errors c:\windows\microsoft.net\framework\v..>peverify system.data.dllmicrosoft r net framework pe verifier version copyright c microsoft corporation all rights reserved. md unverifiable pe header/native stub. md error value class has neither fields nor size parameter token:x md error value class has neither fields nor size parameter token:x error(s verifying system.data.dll so il type safety checks cannot be performed c:\windows\microsoft.net\framework\v..>peverify system.data.dll ilmicrosoft r net framework pe verifier version copyright c microsoft corporation all rights reserved.unverifiable assembly c:\windows\microsoft.net\framework\v..\system.data.dll failed policy check error(s verifying system.data.dll is there any other way to do il code verification i found the switch verifyallonload does it provide some similar functionality than peverify at runtime if yes is there any similar switch for full clr
223020687,11100,https://api.github.com/repos/dotnet/coreclr/issues/11100,benaadams,2,0,0,0,0,0,trying again follow up to the threadpool threads on the default context.less churn when moving between default contexts executioncontext.rundefaultcontext with lighter context switching.also allows the opportunity to benefit from finally cloning by the jit in rundefaultcontext .resolves
222940631,11097,https://api.github.com/repos/dotnet/coreclr/issues/11097,seanshpark,1,0,0,0,0,0,"this will enable to choose globalization invariant mode from corerun.for ports that dont have dotnet program x/linux for example we can only run with corerun.as corefx invariant.tests requires to run in globalization invariant mode this can be possible with this change.to turn it on use environment variable as coreclr_global_invariant= for example, coreclr_global_invariant corerun xunit.console.netcore.exe invariant.tests.dll"
222905370,11091,https://api.github.com/repos/dotnet/coreclr/issues/11091,BruceForstall,1,0,0,0,0,0,where they belong)delete unused containsstatement
222639961,11065,https://api.github.com/repos/dotnet/coreclr/issues/11065,yizhang82,1,0,0,0,0,0,turns out we accidentally made some test source code executable and git end up thinking they are executable files chmod x fixed it also changing line ending and encoding to utf only for one string marshaling test code that has unicode in it to play nicer with git
222496869,11047,https://api.github.com/repos/dotnet/coreclr/issues/11047,stephentoub,1,0,0,0,0,0,contributes to kouvel alexperovich benaadams
221954498,10993,https://api.github.com/repos/dotnet/coreclr/issues/10993,mikedn,2,0,0,0,0,0,store a reference to the relevant entry at the start of the loop to avoid indexing entries multiple times.this avoids some redundant range checks in remove and allows the elimination of a duplicate index in enumerator.movenext .saves kb of code.fixes
221898180,10980,https://api.github.com/repos/dotnet/coreclr/issues/10980,AndyAyersMS,1,0,0,0,0,0,impruntimelookup generates a conditional-deref tree stmtexpr void il then lclvar long v tmp colon long else indir long const long long lclvar long v tmp qmark long const int q if int const int int cast int long lclvar long v tmp a long d------n lclvar long v tmp for x this turns into the following native code: asm fc test rd jne short g_m_ig eb jmp short g_m_igg_m_ig dbffffffff mov r qword ptr r+ffffffffh g_m_ig: we ought to be able to produce something more compact like asm fc test rd je short g_m_ig dbffffffff mov r qword ptr r+ffffffffh g_m_ig: and maybe find smaller encodings for the immediate values
221700686,10956,https://api.github.com/repos/dotnet/coreclr/issues/10956,AndyAyersMS,2,0,0,0,0,1,morph was sometimes passing the existing morphaddresscontext downto fgmorphfield even when the field access was for a field value.if that context contained indefinite offsets morph would theninsert an explicit null check on the object pointer for the fieldaccess.typically the field offset is small enough that this explicit checkis not needed the implicit check done when fetching the fields valueis sufficient protection.the fix is to have fgmorphsmpop clear out the context for child gt_field nodes unless the field parent is a gt_addr noteif there is an op node the parent cannot be gt_addr so thesefield children always get an empty context.no tests added since this kicks in reasonably frequently in corelib andelsewhere in frameworks.closes
221688864,10954,https://api.github.com/repos/dotnet/coreclr/issues/10954,ahsonkhan,2,0,0,0,0,0,add benchmark tests here that exercise the following span extension methods indexof indexofany sequenceequal startswith asspan copytocc josephtremoulet
221634069,10942,https://api.github.com/repos/dotnet/coreclr/issues/10942,AndyAyersMS,1,0,0,0,0,0,p s explicit null check is unnecessary a similar check appears in the codegen for the proposed span indexer intrinsic expansion in cases where the spans pointer field cannot be promoted and the check causes some performance regressions when using the intrinsic expansion instead of using the il.the explicit null check is inserted by morph in fgmorphfield because interpretation of gt_field is parent node dependent morph needs to look for child field nodes and pass down the right context there is some manipulation of address context in fgmorphsmpop but it doesnt get this case right and so the indefinite offset from v is taken to apply to the dereference of f.p too. c#unsafe struct f public f(int x p x public int p;}static unsafe int p(ref f f return f.p);}static unsafe int p(ref f f int v return f.p v asm pmov rax qword ptr rcx mov eax dword ptr rax ret pcmp dword ptr rcx ecxmov rax qword ptr rcx shl edx movsxd rdx edxmov eax dword ptr rax+*rdx ret
221606915,10940,https://api.github.com/repos/dotnet/coreclr/issues/10940,rvuistin,2,0,0,0,0,0,the following code fails on osx..-x runtime in release mode but succeeds in debug mode it succeeds on win-x in release and debug mode i didnt check any other runtimes. public static foo deserialize(stream stream using var r new binaryreader stream return new foo r.readstring r.readdecimal the method readdecimal is called before readstring surprisingly this happens only with runtime methods if we use custom methods instead for example extensions methods which trace the order of execution the code works find attached the zip file which contains the netcoreapp project that reproduce the issue i have used the following commands to publish the project: dotnet restore r osx..-x parametersevaluationordertest.csprojdotnet publish r osx..-x c release parametersevaluationordertest.csproj
221473477,10936,https://api.github.com/repos/dotnet/coreclr/issues/10936,BruceForstall,1,0,0,0,0,0,lsra puts a set of temporary registers needed by a node in thegtrsvdregs register mask currently evey codegen function thatneeds to use a temporary register manually manipulates this mask.introduce a few functions to make this simpler and more regular getsingletempreg gets a temp asserts there is exactly one temp reg extracttempreg gets the lowest temp removes it from gtrsvdregs so subsequent calls dont see it availabletempregs returns a count of available temp registers.all take an optional register mask so you can extract a register fromjust the set specified by the mask typically rbm_allint or rbm_allfloat
221290012,10918,https://api.github.com/repos/dotnet/coreclr/issues/10918,stager13,1,0,0,0,0,0,steps to reproduce:compile the following program: c#using system;using system.threading;namespace sleeptest class program static void main(string args const int sleeptimeins for int i i i console.writeline($sleeping for sleeptimeins seconds i thread.sleep(sleeptimeins console.writeline(ok run it and set system time to some time back for example minutes)thread.sleep hangs instead of waking up each seconds i couldnt reproduce this problem on windows this code runs fine there so it is platform-dependent i also observed similar problem with autoresetevent.waitone(timeout call under linux os version ubuntu x also reproducible on ubuntu mate on arm raspberry pi)).net core version also reproducible on preview
221121741,10910,https://api.github.com/repos/dotnet/coreclr/issues/10910,AndyAyersMS,8,0,0,2,0,1,implement these two methods as optional-expand jit intrinsics.uses gt_arr_bounds_check for the bounds check so in some casesdownstream code is able to eliminate redundant checks fully generalsupport on par with arrays in most cases is still work in progress.update one bit of code in the optimizer that assumed it knew thetree types that appeared in a gt_arr_bounds_check .add benchmark tests for span and readonlyspan indexerstests ability of jit to reason about indexer properties with respectto loop bounds and related indexer uses some cases inspired by spanindexer usage in kestrel.closes also addresses lack of indexer inlining noted in span indexersshould now always be inlined even when invoked from shared methods
220831894,10883,https://api.github.com/repos/dotnet/coreclr/issues/10883,jkotas,6,0,0,0,0,0,from have glanced over the native code generated for dictionary.remove the cse for entry i kicks in some cases but not others if you cache ref entry entry ref entries i at the start of the loop and replace all occurrences of entries i with it the native code generated for this method should be approximately smaller
220805153,10878,https://api.github.com/repos/dotnet/coreclr/issues/10878,rartemev,1,0,0,0,0,0,changes for issue handle assembly references through alias in the correct way.ildasm output for sample from issue description microsoft r net framework il disassembler version metadata version v...assembly extern system.runtime ver assembly testassembly ver module test.dll mvid faea-ebd--a-d}.imagebase x.file alignment x.stackreserve x.subsystem x windows_cui.corflags x ilonly image base xf global methods method privatescope static void main$pst cil managed entrypoint code size x maxstack il newobj instance void system.runtime system.object::.ctor il pop il ret end of global method main disassembly complete
220788666,10871,https://api.github.com/repos/dotnet/coreclr/issues/10871,pgavlin,0,0,0,1,0,0,just what it says on the tin
220760412,10860,https://api.github.com/repos/dotnet/coreclr/issues/10860,gkhanna79,1,0,0,0,0,0,weshaggard ptalcc leecow russkeldorph dagood wtgodbe
220211959,10795,https://api.github.com/repos/dotnet/coreclr/issues/10795,dotnet-bot,0,0,0,0,0,1,this pr contains mirrored changes from dotnet/corert please rebase this pr when merging
220016285,10772,https://api.github.com/repos/dotnet/coreclr/issues/10772,ruben-ayrapetyan,1,0,0,0,0,0,before the changes applies only to the unix-like platforms if file alignment sections of il-only assemblies is less than size of virtual page then the pages are not directly mapped to memory but instead are copied to anonymous memory.with the changes applies only to the unix-like platforms il-only assemblies without writeable sections are directly mapped to memory in flat mode i.e without separate maps per section).this means that physical memory for the assemblies is allocated only once with the changes even if the assemblies are loaded into multiple processes so memory consumption reduces.related issue br/>testing ci default successful additionally ubuntu x checked build and test jit corefx successful coreclr test suite successful on windows with these changes enabled for testing although they are supposed to be unix only memory consumption please see belowmemory consumption of puzzle.tizen application see part before after difference private per-application kb kb kb lessshared one copy for all applications kb kb kb morerss kb kb kb lessper-application part is kb less which is of coreclrs per-application memory consumption part
219750937,10752,https://api.github.com/repos/dotnet/coreclr/issues/10752,BruceForstall,1,0,0,0,0,0,hide a few things from clang-format
219744317,10747,https://api.github.com/repos/dotnet/coreclr/issues/10747,tarekgh,1,0,0,0,0,0,fixes encoding.default today is returning utf but with bom emission enabled this is causing many problem when this encoding used for example in console we ensure turning of bom emission in system io we always use the default with no bom we got the feedback from powershell team too.also most of the tools especially on linux doesnt handle bom and treat it as part of the text is kind of breaking change for netcore but i am expecting this will be very limiting breaking as i am seeing most of the time people trying to do turn off the bom
219626745,10732,https://api.github.com/repos/dotnet/coreclr/issues/10732,AndyAyersMS,2,0,0,0,0,0,we now have several complementary systems in the importer for tracking types the evaluation stack local variable class tracking and the tree node extraction tracking gtgetclasshandle ).these are interdependent and vary in their capabilities the evaluation stack cant track exactness or non-nullness two properties that are useful and can be ususally be deduced when the stack entry is created local variable tracking cant track non-nullness and this may be tricky to do since it is flow dependent but some cases are potentially knowable eg single-def temps introduced by the compiler for newobj or for callee arguments also there is some overlap with the explicitly tracked classes and the verifier type info used at some places in the compiler tree node extraction can only handle subsets of cases and because of the enormous variability of expansion eg the many ways a ldsfld can expand to trees cant be made fully general unless information is more directly represented on the tree nodes.the stack is only available during importation while the local var and tree node information is potentially available later on during inlining and optimization passes the tree node evaluation as it is done now should remain correct however if type information is cached on tree nodes then we need to be careful to consider what should happen when tree nodes are bashed or otherwise destructively updated we may also experience loss of types as new nodes are created the local variable information is somewhat fragile though it is unlikely that optimizations would introduce new definitions or change the types of existing definitions however there is nothing to prevent this or to check that it hasnt happened.it would be good to unify the capabilities of these systems and work on better defining the maintenance/invalidation process.doing this would allow the compilers type based optimizations to be done safely at various points in the compilation pipeline and would make them less dependent on il patterns or runtime expansions.category:implementationtheme:importerskill-level:expertcost:large
219605388,10731,https://api.github.com/repos/dotnet/coreclr/issues/10731,AndyAyersMS,6,0,0,1,0,3,the jit should now be able to optimize many of the common type specialization checks during importation since the jit can also do some rudimentary branch opts during importation early type specialization check optimization would allow the jit to skip importing chunks of il guarded by type checks that are known to fail.for example consider any non-intrinsic vector method eg vector:op_multiply since t is constrained to non-ref types this methods instantiation parameter is always a known class at jit time so roughly of the il in this method is unreachable by any particular instantiation and doesnt need to be imported.this should provide a throughput boost it might also make it easier for the jit to consider inlining such methods because the jit can more accurately assess the true size of the method.category:throughputtheme:importerskill-level:expertcost:medium
219341419,10701,https://api.github.com/repos/dotnet/coreclr/issues/10701,ruben-ayrapetyan,1,0,0,0,0,0,hello.current compileoptions.cmake defines disable_contracts for unix platforms: if clr_cmake_platform_unix add_definitions(-ddisable_contracts seems like the define means that coreclr contract checks are disabled on linux by default and so all precondition / postcondition -like checks are also disabled on the platform by default.please clarify are there any supported ways to perform the comprehensive testing of changes in coreclr on linux?@dmitri-botcharnikov gbalykov
219323694,10698,https://api.github.com/repos/dotnet/coreclr/issues/10698,pgavlin,0,0,0,1,0,0,in hir this flag indicates that the second operand to a binary node will execute beforethe nodes first operand lir however no longer determines ordering via use edges sothis flag only affects the order in which operands to a node are considered the soleconstraint on this use ordering is that for a given node the same ordering must be usedin liveness lsra and the code generator this is due to the correspondence betweenuse ordering and spill/reload/last-use ordering as a result the reverse ops flag isunnecessary and rather unhelpful in lir causing little more than a bit of extra complexitythroughout the backend.this change removes gtf_reverse_ops from lir by clearing this flag during rationalizeand verifying that it remains clear in lir::checklir we could reuse this bit for anadditional backend-specific purpose in the future with a bit more work in the checker
219280959,10695,https://api.github.com/repos/dotnet/coreclr/issues/10695,JosephTremoulet,1,0,0,0,0,0,a few small changes to make it easier to compare selections in theinstaller ui against the list in the doc re-order the list to match the order presented in the installer ui place the individual items under groupings matching the installer change casing to match installer ui
219173941,10690,https://api.github.com/repos/dotnet/coreclr/issues/10690,tmds,1,0,0,0,0,0,when running in docker on linux environment.processor returns the number of available logical processors in the host system it doesnt take into account the limitations that were set on the container.dockerfile: from microsoft/dotnet:sdkadd src srcworkdir srcenv lttng_ust_register_timeout run dotnet restore dotnet buildentrypoint dotnet run src/program.cs: using system;namespace consoleapplication public class program public static void main(string args system.console.writeline($processorcount environment.processorcount src/app.csproj: exenetcoreapp. executing docker build t proccount docker run proccountprocessorcount docker run cpuset-cpus proccountprocessorcount the latter call should return mono was fixed for this issue see bug report of processors is determined via sched_getaffinity issue for android/arm:the mono_cpu_count function contains other special cases for platform_android host_arm and host_arm on android its preferable not to use sc_nprocessors_onln because the number of online processors varies for power saving on arm the number of cpus returned by sched_getaffinity varies as well comments in the code suggests that the arm&android cases can be handled together by reporting sc_nprocessors_conf.comment from akoeplinger i think the pragmatic solution is the following use sched_getaffinity fallback to sc_nprocessors_onln in case of error on x this ensures were inline with what openjdk and coreclr do use sc_nprocessors_conf exclusively on arm i think we could eventually even get rid of the platform_android special case
219095634,10681,https://api.github.com/repos/dotnet/coreclr/issues/10681,BruceForstall,0,0,0,2,0,0,now on linux the x build will build an arm-targetingaltjit the x build will build an arm-targeting jit.the altjit is named libprotononjit.so/dylib it can beused for debugging or for generating asm diffs using jit-diff
219079219,10674,https://api.github.com/repos/dotnet/coreclr/issues/10674,adityamandaleeka,1,0,0,0,0,0,fix doesnt handle the case where an environment variable is found but has length if this happens it effectively just does stringbuildercache.acquire followed by stringbuildercache.getstringandrelease .@jeremykuhne jkotas
219043102,10669,https://api.github.com/repos/dotnet/coreclr/issues/10669,benaadams,1,0,0,0,0,0,"prior tostring asm assembly listing for method guid:tostring(ref,ref):ref:this lcl frame size g_m_ig push r push r push rdi push rsi push rbp push rbx ec sub rsp bf mov rsi rcx dc lea rdi rsp+h b mov ecx c xor rax rax fab rep stosd total bytes of code prolog size for method guid:tostring(ref,ref):ref:this post tostring asm assembly listing for method guid:tostring(ref,ref):ref:this lcl frame size g_m_ig push r push r push rdi push rsi push rbp push rbx ec sub rsp bf mov rsi rcx dc lea rdi rsp+h b mov ecx c xor rax rax fab rep stosd total bytes of code prolog size for method guid:tostring(ref,ref):ref:this same preamble but bytes shorter however main change is in called functionswhich drop the pushes and pops per call and shortening the non-inlined call chains from guid:tostring guid:hexstochars bytes guid:hexstochars stack bytes x guid:hexstochar bytes guid:hexstochars stack bytes x guid:hexstochar bytes) which is essentially a function call per char to guid:tostring guid:hexstochars bytes guid:hexstocharshexoutput bytes) guid.tostring per secondcurrent pr so x gain"
219007850,10662,https://api.github.com/repos/dotnet/coreclr/issues/10662,helloguo,2,0,0,0,0,0,this pr adds jit intrinsic support for vector conversion/narrow/widen on amd sse sse and avx it is built on and the intrinsics will be tested by following apis are accelerated by jit intrinsics provided in this pr: public static partial class vector public static void widen(vector
218741956,10647,https://api.github.com/repos/dotnet/coreclr/issues/10647,jkotas,1,0,0,0,0,0,repro: using system;using system.diagnostics;class program static void main(string args try debug.assert(false catch console.writeline(hello world dotnet restoredotnet runactual result hello world!expected result program is terminate with assert message
218713697,10644,https://api.github.com/repos/dotnet/coreclr/issues/10644,wizzard0,0,0,0,3,0,0,proposal create a no-op gc selectable at application start via app manifest command line option putting local gc library next to the executable etc).rationale is about the same as for the epsilon gc performance testing to be able to separate gc-induced performance variations functional testing e.g to quickly detect allocation rate spikes in applications that are supposed to run with low allocation rate example gc for developing/integrating other gc engines squeezing the last bit of performance where the app is either short-lived e.g request handler or already has low to none allocation rate by removing memory barrier overheads and so on
218694760,10643,https://api.github.com/repos/dotnet/coreclr/issues/10643,mklement0,2,0,0,0,0,0,this is a follow-up from here encoding.default in the full framework on windows reports the legacy ansi code page encoding core doesnt support these legacy pages by default so its encoding.default must return an encoding that makes sense in a cross-platform world currently encoding.utf is returned which is a utf encoding with bom the reason for returning encoding.utf as encoding.default is a historic one it seems as the source-code comment mentions silverlight utf with bom is problematic on all unix platforms whose utilities do not expect a bom and instead treat it as data leading to unexpected results having encoding.default return a utf encoding with bom is pointless and confusing because it neither represents any platforms nor the frameworks own true default and may cause disruption in practice note that both net frameworks and net cores true default is bom-less utf because thats whats used in the absence of specifying an encoding with the methods of the system.io class
218625603,10630,https://api.github.com/repos/dotnet/coreclr/issues/10630,russellhadley,1,0,0,0,0,0,allow local vars that cross eh to reside in registers for the normal flow or with in the exceptional flow vars should only have to be on the stack during the register kill across the eh edge.category:cqtheme:big-betsskill-level:expertcost:extra-large
218622807,10628,https://api.github.com/repos/dotnet/coreclr/issues/10628,mattwarren,7,0,13,0,0,2,theres been multiple studies pdf that show a link between of bugs and of lines of code in software.so as early april present to all the coreclr devs who are working hard on the next release ive just reduced your bug count probably)!!the pr removes lines across files ill let you do the maths to calculate how many bugs that equates to
218443615,10605,https://api.github.com/repos/dotnet/coreclr/issues/10605,olegsavelos,10,0,0,0,0,0,is there any effort in place to bring support for the arm platform?i think the pi zero is perfect platform for lots of different iot projects and it would be quite a shame if there is no support for it
218395966,10600,https://api.github.com/repos/dotnet/coreclr/issues/10600,karelz,2,0,0,0,0,0,lets take technical stable info from goldshtns blog post and add it to coreclr docs.keep link to the blog post as credits of course.where?either enhance linux performance tracing docs or create a sibling doc i think this is winner).@brianrob vancem any preference where could you please help review advise which parts to grab into coreclr
218363698,10597,https://api.github.com/repos/dotnet/coreclr/issues/10597,mletterle,2,0,0,0,0,0,after installing dotnetcore via the instructions at there is no way to install the il tools the default dotnet nuget command has no install command after using apt-get install nuget to get the stand-alone nuget-cli i am able to nuget install microsoft.netcore.ilasm which doesnt appear to pull down any binaries.using nuget install runtime.ubuntu..-x.microsoft.netcore.ilasm gives me a binary which is not marked executable by default but it can not find libcoreclr.so basically whats the recommended way to actually install and use the il tools on a dotnet core install?ideally thered be dotnet ildasm and dotnet ilasm
218152965,10582,https://api.github.com/repos/dotnet/coreclr/issues/10582,AndreyAkinshin,0,0,3,0,0,0,equals to not
217970463,10564,https://api.github.com/repos/dotnet/coreclr/issues/10564,JosephTremoulet,1,0,0,0,0,0,the code in fgmorphcopyblock that removes self-assigns checks if the lhsand rhs refer to the same lclvar update it to also check if the lhs andrhs refer to the same field(s of that lclvar since otherwise copiesfrom one field to another of a struct can get lost.fixes
217951566,10561,https://api.github.com/repos/dotnet/coreclr/issues/10561,rahku,1,0,0,0,0,0,either assembly.getname should not set codabase property or loadfromassemblyname should ignore codebase property in assemblyname
217938531,10560,https://api.github.com/repos/dotnet/coreclr/issues/10560,JosephTremoulet,1,0,0,0,0,0,with aot scenarios now including ngen and crossgen and ready-to-run desktop and coreclr and corert and with work in flight on ibc and tiered jitting its a good time to take another look at the flags used to control which optimizations the jit performs and try to get a set in place that will give us the right interface going forward to evolve our codegen/policies in the different scenarios.category:designtheme:optimizationskill-level:expertcost:medium
217776929,10547,https://api.github.com/repos/dotnet/coreclr/issues/10547,ragmani,1,0,0,0,0,0,elif defined(_target_x target_arm for int i i i prd->ctxptrsone.esi i pctx->esi i an overflow occurs in struct knonvolatile_context_pointers because the loop statement starts from esi variable.this is struct knonvolatile_context_pointers typedef struct knonvolatile_context_pointers the ordering of these fields should be aligned with that of corresponding fields in context see fillregdisplay in inc/regdisp.h for details pdword edi pdword esi pdword ebx pdword edx pdword ecx pdword eax pdword ebp knonvolatile_context_pointers pknonvolatile_context_pointers; this is stuct context typedef struct context ulong edi ulong esi ulong ebx ulong edx ulong ecx ulong eax ulong ebp ulong eip context pcontext lpcontext
217754498,10545,https://api.github.com/repos/dotnet/coreclr/issues/10545,hqueue,1,0,0,0,0,0,i made a helloworld.dll example as follows default extension of helloword application is dll uname alinux bab generic ubuntu smp tue dec utc x gnu/linux dotnet info.net command line tools product information version commit sha hash dbcdruntime environment os name debian os version os platform linux rid debian.-x base path usr/share/dotnet/sdk dotnet new consolecontent generation time msthe template console application created successfully dotnet restore dotnet build ls bin/debug/netcoreapp./helloworld.deps.json helloworld.pdb helloworld.runtimeconfig.jsonhelloworld.dll helloworld.runtimeconfig.dev.json make native image from helloworld.dll using crossgen crossgen readytorun platform_assemblies_paths pwd helloworld.dll microsoft r coreclr native image generator version copyright c microsoft corporation all rights reserved.native image home/hqueue/tmp/coreoverlay/helloworld.ni.exe generated successfully expected resultexpected out filename is helloworld.ni.dll since input filename is helloworld.dll actual resultactual out filename is helloworld.ni.exe it was quite confusing that input filename and output filename have different extension.is this intended behavior of crossgen or should helloworld have exe as extension at the first place when generated from dotnet cli
217701442,10532,https://api.github.com/repos/dotnet/coreclr/issues/10532,rartemev,0,0,0,5,0,0,fixed building tests on linux issue to build tests use the following command bash build-test.sh_to build and run tests after bash build-test.sh runtests_to rebuild tests bash build-test.sh rebuild
217657992,10529,https://api.github.com/repos/dotnet/coreclr/issues/10529,swgillespie,9,0,0,0,0,0,the book of the runtime is a great resource on the gc but it glosses over the details of many aspects of the gc that are important to understanding how the system works on a deep level today its very difficult to understand the gc just by looking at the book of the runtime alone it takes a lot of time reading gc.cpp and debugging to get a feel for the different aspects of the gc and how they interact.it would be great if we had centralized detailed documentation for gc internals in addition to the book of the runtime in the hopes of lowering the barrier of entry into the gc.some issues where gc internals have been discussed would be great candidates for documentation question understanding demotion question whats function set_new_pin_info used for question whats the relationship of gcheap gc_heap heap_segment alloc_context and generation question how many gcheap and gc_heap instances per net process whats the meaning of local gc also topics that arent covered by the botr off the top of my head would also be great candidates for documentation pins in general how the ee reports things as pinned to the gc how the gen allocator deals with pins on the ephemeral segment the demotion mechanism pinned plugs and popo allocating in condemned generations free lists the botr mentions that the sweep phase populates free lists but doesnt talk much about how they are used when allocating in higher generations how to use the gc log to view gc debug output joins in server gc why they are necessary hazards associated with unbalanced heaps measures taken to ensure that each heap has a proportional amount of work to do e.g mark stealing alloc_heap vs home_heap)cc karelz maoni adityamandaleeka sergiy-k
217445240,10519,https://api.github.com/repos/dotnet/coreclr/issues/10519,parjong,1,0,0,0,0,0,this commit revises jit_trialalloc::emitsetappdomain to align stack frame before setobjectappdomain call discovered while gc stress test
217379762,10507,https://api.github.com/repos/dotnet/coreclr/issues/10507,eerhardt,0,0,0,1,0,0,since unix uses iana tzdata files there can be hundreds of adjustment rules for each time zone to make the search for a given rule faster use a binary search since the rules are guaranteed to be in chronological order see validatetimezoneinfo.fix tarekgh stephentoub mellinoe cc erozenfeldi ran the following program on my machines note completely different physical machines): c#using system;using system.diagnostics;namespace tzperftest class program static void main(string args datetime dt for int i i i stopwatch watch new stopwatch watch.start for int j j j dt datetime.now dt datetime.now dt datetime.now dt datetime.now dt datetime.now dt datetime.now dt datetime.now dt datetime.now dt datetime.now console.write(watch.elapsedmilliseconds br platform with my change|without my change windows x br>
217369611,10504,https://api.github.com/repos/dotnet/coreclr/issues/10504,yizhang82,1,0,0,0,0,0,c language spec link spec link tbd)list of work items x fix up ildasm to support default interface methods non-abstract virtual methods on interfaces x fix up ildasm to allow non-virtual instance methods on interface x allow type loader to ignore not implemented interface methods on classes x allow non-virtual interface instance methods in type loader x support calling protected interface non-virtual instance method from derived class tbd x hook up vsd interface dispatch x throw in the case of diamond inheritance case x support shared generics and variance x support looking up method impls static constructors with initializers only no static constructor by itself needs more investigation support constrained interface call on value types x handle interface precodes properly x correct interface lookup algorithm and validation once design is finalized x proper typeloader/ildasm error checking/validation for interface methods once design is finalized private/protected/internal virtual vs non-virtual reflection to tell the difference between default interface method and a regular ngen support x rr support interaction with com interop
217253602,10497,https://api.github.com/repos/dotnet/coreclr/issues/10497,DieselMachine84,1,0,0,0,0,0,i used pvs-studio static analyzer to check this project i would like to suggest a variant of the way to fix the error detected with the help of v diagnostic
217248183,10496,https://api.github.com/repos/dotnet/coreclr/issues/10496,sergign60,3,0,0,0,0,0,the given pull request proposes a way for resolving issue jitted code dropping support its distinctive features and algorithm are all its code is under if defined(feature_jit_pitching and doesnt mess up with other code this feature is working only if the options internal_jitpitchenabled and internal_jitpitchmemthreshold jitted code can be pitched only for methods that are not dynamic fcall or virtual if the size of the generated native code exceeds the value of internal_jitpitchmethodsizethreshold this code is placed in the special heap code list each heap block in this list stores the code for only one method and has the sufficient size for the code of a method aligned to k the pointers to such methods are stored in the calledmethods hash map if the entrypoint of a method is backpatched this method is excluded from the calledmethods hash map and stored in notforpitchingmethods hashmap when the total size of the generated native code exceeds the value of internal_jitpitchmemthreshold option the execution of the program is stopped and stack frames for all the threads are inspected and pointers to methods being executed are stored in the executedmethods hash map the code for all the methods from the calledmethods that are not in the executedmethods is pitched all heap blocks for these methods are set in the initial state and can be reused for newly compiled methods pointers to the code for non-executed methods are set to null if the code for the given method is pitched once this method is stored in the notforpitchingmethods hashmap thus if this method is compiled the second time it is considered as called repeatedly therefore pitching for it is inexpedient and the newly compiled code stored in the usual heap the coreclr code with this feature is built by the option./build.sh cmakeargs dfeature_jit_pitching=true
217155614,10491,https://api.github.com/repos/dotnet/coreclr/issues/10491,sjsinju,1,0,0,0,0,0,on last comment of the nyi message of overflow checks is printed after running the codegenbringuptests.i tried to create the sample code for making same assertion. using system;namespace checked class program unsafe private void m_value public unsafe void foo(long value m_value void*)checked((int)value static void main(string args program p new program p.foo(xabcdl it made same results. assert failure(pid xb thread xb assertion failed nyi_arm overflow checks in system.intptr:.ctor(long):this il size file home/sjsujinkim/works/dotnet/coreclr/src/jit/lsraarm.cpp line image home/sjsujinkim/works/dotnet/windows_nt.x.release/tests/coreoverlay/corerunaborted that was the message about a temp register setup for overflow checks.it was referenced think it doesnt make any problem even though writing it the same as arm
217010988,10485,https://api.github.com/repos/dotnet/coreclr/issues/10485,WinCPP,1,0,0,0,0,0,ahsonkhan jkotas kindly review the updates to the api summary as per the review comment pr reflects the summary changes to align with those in corefx repo.ref dotnet/corefx
216952802,10478,https://api.github.com/repos/dotnet/coreclr/issues/10478,noahfalk,34,0,0,7,0,9,tiered compilation is a new feature we are experimenting with that aims to improve startup times initially we jit methods non-optimized then switch to an optimized version once the method has been called a number of times more details about the current feature operation are in the comments of tieredcompilation.cpp.this is only the first step in a longer process building the feature the primary goal for now is to avoid regressing any runtime behavior in the shipping configuration in which the complus variable is off while putting enough code in place that we can measure performance in the daily builds and make incremental progress visible to collaborators and reviewers the design of the tieredcompilationmanager is likely to change substantively and the call counter may also change
216930684,10471,https://api.github.com/repos/dotnet/coreclr/issues/10471,AndyAyersMS,1,0,0,0,0,0,track whether a local has a single definition and if so if it hasa reference type try and update its type from the declared type toa better type taken from the value being assigned to the local.obtain types for some of the short-lived ref type temps that shouldhave a single definition use both the tree and the eval stack as sourcesof type information the latter can be phased out if/when all tree nodescan return rich type information).refactor the code that sets or updates lvclasshnd into utilitiesto provide better auditing of type flow and make the set/update processa bit more rigorous.cleanup the code that passes argument values a bit by commoning redundantargument lookup expressions
216479688,10422,https://api.github.com/repos/dotnet/coreclr/issues/10422,BruceForstall,1,0,0,0,0,0,we have way more uses of simplerhashtable than jit it would be useful to understand more about these uses e.g how many hash table resizes happen do any users prime the expected hash table size based on some ir characteristic and could they do so to avoid resizes they all use jitsimplerhashbehavior is this the right set of behaviors for all the hash tables how much time/memory is taken in these hash table uses/creation/maintenance how well is the hash table working e.g what is the table density how long are the linked list chains etc.category:throughputtheme:jit-coding-styleskill-level:expertcost:small
216479125,10421,https://api.github.com/repos/dotnet/coreclr/issues/10421,BruceForstall,3,0,0,0,0,0,the jit has about noway_assert these are executed in non-debug aka release builds some might be frequently executed and thus costly instead of auditing all of them for relevance i.e in an optimization phase that can be backed out of or apparently importance we could change the noway_assert macro conditionally to collect a count of which ones are frequently executed using a hash table from preprocessor file and line to execution count dumped at the end of compilation then we could convert the worst ones to simple asserts.category:throughputtheme:throughputskill-level:expertcost:medium
216474048,10418,https://api.github.com/repos/dotnet/coreclr/issues/10418,lt72,2,0,0,0,0,0,x evaluate available solutions for generating crash dumps x design clearly list all cases where crash dump is currently generated x design provide basic design document md for addressing all cases above x design list and address challenges for corner cases such as stack overflow or severe memory corruption x design address possible differences between linux and macos cases in design x design devise policy and mechanism to trigger full and mini dump x generate minimal full core dump for all cases where abort is explicitly called x validate full core dump above can be loaded and contains all managed and native information x create support for full and mini dump equivalent using native platform format x implement policy and mechanism to trigger full and mini dump x address corner cases e.g stack overflow severe memory corruption
216337663,10410,https://api.github.com/repos/dotnet/coreclr/issues/10410,parjong,2,0,0,0,0,0,this commit changes global calling convention from stdcall into cdecl to fix
216227119,10401,https://api.github.com/repos/dotnet/coreclr/issues/10401,sandreenko,1,0,0,0,0,0,it allows to answer the question is block dominated by non normalentry in o it is asked per block and time complexity was o(n where n is the number of blocks in ir.the third commit fixes
216004637,10379,https://api.github.com/repos/dotnet/coreclr/issues/10379,raffaeler,1,0,0,0,0,0,where can i find the fuslogvw.exe for net core?is it shipped with netcore sdk runtime or whatelse?thanks
215828048,10350,https://api.github.com/repos/dotnet/coreclr/issues/10350,BruceForstall,1,0,0,0,0,0,this sets the ngenoptions.fsilent flag which prevents displayingthe final output message.this is useful for jit asm diff generation
215590995,10334,https://api.github.com/repos/dotnet/coreclr/issues/10334,noahfalk,1,0,0,0,0,0,today if you try to collect a mini or triage dump on windows none of the information relevant for debugging a stack trace through jitted code is collected this renders windows error reporting largely useless as well as causing problems for other diagnostic scenarios that would like to use minidumps.the root cause of the problem is net core doesnt have access to the same extensibility mechanism in minidumpwritedump that the desktop and net native clr implementations use the current extensibility mechanism provided by the os requires registering a dll in hkey_local_machine\software\microsoft\windows nt\currentversion\minidumpauxiliarydlls that registry location requires admin privileges and cant be set when net core installation is limited to xcopy only.proposed solution:we have coordinated with the windows os team to design an additional extensibility mechanism to minidumpwritedump in lieu of admin privileges and registry edits this one uses authenticode signature verification to ensure security and reads the pe resources in loaded modules for discovery specifically minidumpwritedump will scan each module in the dump process looking for any resources with name=dump_helper type=rt_rcdata lang=neutral the resource contains the utf encoded null terminated name of a minidump auxilliary provider dll that is located in the same directory as the binary with the resource in it after discovery and signature verification minidumpwritedump uses the minidump auxilliary provider no differently than if it had been loaded using the pre-existing registry technique
215423202,10307,https://api.github.com/repos/dotnet/coreclr/issues/10307,ayuckhulk,0,0,0,0,0,1,this pr adds lexical scopes info for local variables in gdbjit it also includes related code refactoring and memory leak fix.summary pass addresses of lexical scopes for local variables from symbolreader to gdbjit fix memory leak when passing structures from symbolreader to gdbjit generate lexical scope dwarf entries move global variables to local scope to avoid confusion about lifetimes of methods lines and symbol names@mikem janvorli ptalcc dmitri-botcharnikov chunseoklee seanshpark lucenticus kvochko
215233177,10286,https://api.github.com/repos/dotnet/coreclr/issues/10286,cydhaselton,1,0,0,0,0,0,adds rids and related conditionals/variables to the appropriate files as part of enabling android/arm for net core issue here appears to have been refactored since the original pr to which i was referred cc-ing janvorli and qmfrederik for review in case of missed items
215189019,10279,https://api.github.com/repos/dotnet/coreclr/issues/10279,AAimson,2,0,0,0,0,0,when trying to debug a mvc web project in vs mac i get the error message unable to attach to coreclr dotnet>microsoft net core shared framework host>version dotnet info>.net command line tools product information version commit sha hash dbcd>>runtime environment os name mac os x os version os platform darwin rid osx..-x base path opt/dotnet/sdk
215149163,10273,https://api.github.com/repos/dotnet/coreclr/issues/10273,BruceForstall,2,0,0,0,0,0,"currently we maintain two versions of the jit-ee interface in thesource tree the current version and net version this ismanaged by the cor_jit_ee_version define any new changes to the jit-eeinterface must be put under if cor_jit_ee_version as of now,there are quite a few of these if statements in the tree.we started doing this so we could build and ship a ctp communitytechnology preview version of the jit from the current source tree thatruns against earlier versions of the runtime that are widely availableto customers so those customers can try out the new jit and give usearly feedback this was done during the ryujit/x bring-up beforeshipping net to get as much feedback as possible before replacingjit after shipped we re-based the old version of the jit-eeinterface to the version and started adding the above if conditions with the thought that if we ever shipped another ctp itwould be expected to run on top of we have not shipped such athing and we currently have no plans to build another ctp in the sameway we did before early adopters can try out the live jit in the.net core open source project although that jit cant be used on thedesktop.)so to simplify the code and reduce the cost of adding to or changingthe jit-ee interface we are removing the cor_jit_ee_version define"
214870685,10241,https://api.github.com/repos/dotnet/coreclr/issues/10241,briansull,1,0,0,0,0,0,we now always call the new method hasprofileweight to perform the flag test
214816055,10233,https://api.github.com/repos/dotnet/coreclr/issues/10233,gokarnm,2,0,0,0,0,0,right now the assemblyloadcontext class exposes a default static property that returns the default load context apppathassemblyloadcontext consider adding an assemblyloadcontext.current static property that returns the current assemblyloadcontext from which the calling types assembly is resolved here are some data points to support this api alc is poorly documented and generally not very well understood usually third party library/framework developers dont need to deal with this class unless they are loading dynamic assemblies or loading assemblies outside of the tpa list its easy to incorrectly use assemblyloadcontext.default to load assemblies instead of using the current alc as assemblyloadcontext.default is discoverable and the developer may not know the implications of loading into default vs current alc a developer may not be even aware of current alc as a concept bugs related to loading in default alc instead of current alc may surface only when someone loads the affected library in a custom alc and subsequently sees assembly resolution errors this may not be a popular use case may not have been envisioned and tested by the library developer by providing a new assemblyloadcontext.current api with appropriate documentation it would be clearer to the library developer and possibly force to think about using default or current alc as per their use case and intended behavior.as an example here is an issue in mvc due to use of incorrect alc for loading
214595210,10226,https://api.github.com/repos/dotnet/coreclr/issues/10226,parjong,1,0,0,0,0,0,does not consider return buffer and results in rpinvoke_vectorret test failure discussed in this commit revises umthunkmarshinfo::runtimeinit and umthunkmarshinfo::setuparguments to account retbuf argument correctly.this commit fixes
214569662,10216,https://api.github.com/repos/dotnet/coreclr/issues/10216,JosephTremoulet,1,0,0,0,0,0,re-enable the tests that were disabled in ec re-work how tests are invoked from the command line to require less boilerplate now each test has a single benchmark entrypoint that entrypoint invokes its tests single inner-loop by wrapping it in a lambda that it passes to a new helper invoke method shared across all tests which handles the xunit vs command-line differences main finds the entrypoints by using reflection to search for the benchmark attributes so the explicit list of stringified test names is no longer needed and the command line will run the same set of tests that xunit-perf does the new spanapi tests now get invoked when this tests is run from the command line as well add noinlining to the spanapi tests kernels add some heap writes and conditional writes to prevent deadcode optimization from eliminating tests kernels assuming we dont do interprocedural constant propagation or deadcode or store sinking and final value calculation or pre split the index spanapi tests into one version that uses a loop-invariant index and thus should get hoisted out of the loop and another version that uses variant indices
214523150,10203,https://api.github.com/repos/dotnet/coreclr/issues/10203,WinCPP,1,0,0,0,0,0,new api to return the value associated with key being removed if the key is present.@karelz danmosemsft kindly review
214451725,10192,https://api.github.com/repos/dotnet/coreclr/issues/10192,AndyAyersMS,13,0,0,3,0,2,three commits first has vm changes second has jit changes third has tests
214251811,10183,https://api.github.com/repos/dotnet/coreclr/issues/10183,myungjoo,2,1,0,0,0,0,many if not most linux supporting software packages have official dist files for well-known linux distros.as coreclr is a native component and linux is one of supported main os why dont you have official dist files so that many linux distro users may maintain build install easily.id suggest to have spec for tizen/fedora/redhat/opensuse and deb for debian/ubuntu as the official dist files with these files included officially you will potentially be able to include dotnet/coreclr as a default or standard pacakge in such linux distros as well which id recommend to start with ppa ubuntu and home projects of build.opensuse.org supporting many distros simultaneously this will also be much helpful on cleaning up build schemes of coreclr for linux because you will have clear vision on what to do and what not to do in the due process you may have your release process for those distros automated and have less worries on dependencies and os version issues frankly speaking without official dist support for linux packages still look like prototypes
214149012,10172,https://api.github.com/repos/dotnet/coreclr/issues/10172,AndyAyersMS,2,0,0,0,0,0,refactor the logic in impdevirtualizecall so that the part that determinesthe type of a tree for ref types is now a new utility method that can be calledelsewhere.update the utility to examine calls more closely for inline candidates thatreturn shared types try and use the context to get to the unshared version of thetype for calls that are not inline candidates look at the type in the signatureavailable to the jit w/o context.call the utility when weve created a temp for an inlinees argument and theargument is not modified in the inlinee body if we already thought we knew thetype of the temp exactly ensure that this new information agrees.rework the logic in impdevirtualizecall in anticipation of interface calldevirtualization update the diagnostic stream to indicate the kind of calldevirtualized nd the primary reason why devirtualization happened.avoid fetching class and method names unless theyre going to be used likewisetry not to fetch attributes if we already have them on hand
214113046,10168,https://api.github.com/repos/dotnet/coreclr/issues/10168,eerhardt,1,0,0,1,0,0,when building managed code on non-windows we can produce portable pdbs so debugging is possible with this change i can debug system.private.corelib.dll on my osx using vs code./cc ramarag tarekgh gkhanna
213962702,10157,https://api.github.com/repos/dotnet/coreclr/issues/10157,jkotas,0,0,0,1,0,0,fixes
213865496,10149,https://api.github.com/repos/dotnet/coreclr/issues/10149,JosephTremoulet,1,0,0,0,0,0,morph has some logic to scalarize struct copies where the rhs is a scalarand the lhs is a single-field struct this change adds the symmetriclogic where the lhs is a scalar and the rhs is a single-field struct.this pattern shows up in span
213656945,10132,https://api.github.com/repos/dotnet/coreclr/issues/10132,BruceForstall,2,0,0,0,0,0,this simplifies reading the code
213625157,10130,https://api.github.com/repos/dotnet/coreclr/issues/10130,BruceForstall,1,0,0,0,0,0,it is useful to see when these are changing
213559629,10124,https://api.github.com/repos/dotnet/coreclr/issues/10124,jkotas,4,0,0,0,0,0,this is low-risk stop gap measure to improve encoding performance because of we may not have enough time to improve the test coverage and refactor to code to use corefxlab high-performance encoding routines for the change is to avoid passing the key loop control variables by ref to the invalid character fallback routines taking address of a variable prevents ruyjit from enregistering it.results utf decoding k of ascii characters is x faster similar for other affected codepaths
213516449,10120,https://api.github.com/repos/dotnet/coreclr/issues/10120,BruceForstall,1,0,0,1,0,0,"with this change we build two new jits a jit that runs onwindows amd and targets linux amd and a jit that runson windows x and targets linux x each is built as an altjit namedlinuxnonjit.dll this is useful for debugging or generating asm code or diffs.you can even easily create windows/non-windows asm diffs(either to compare the asm or compare the generated code size in bothcases you dont need to set up a linux environment especially thecurrently immature linux x environment to do many aspects of jitdevelopment.for this to work for amd the jit-ee interface methodgetsystemvamdpassstructinregisterdescriptor was changedto always be built in by defining feature_unix_amd_struct_passing_itf in all amd builds the itf suffix indicates that this isfunctionality specific to implementing the jit-ee interfacecontract there were many places in the vm that used thisinterchangeably with feature_unix_amd_struct_passing now, feature_unix_amd_struct_passing means code in the vm neededto implement the amd struct passing feature but not required to implement thejit-ee interface contract in particular methodtables computeand cache the eightbyte info of structs when loading a type.this is not done when only feature_unix_amd_struct_passing_itf is set to avoid altering methodtable behavior on non-unixamd builds instead if getsystemvamdpassstructinregisterdescriptor() is called on a non-unix build by the altjit the classifyeightbytes() function is called and nothing is cached hopefully though it washard for me to guarantee by observation calling classifyeightbytes() does not have any side effects on methodtables it doesnt really matter,since if called for altjit we dont care too much about running.the previously used platform_unix define is now insufficient.i introduced the define macros host_unix to indicate thejit being built will run on unix and target_unix to indicatethe jit is generating code targeting unix some things wereconverted to use the unix_amd_abi define which makes moresense"
213493618,10113,https://api.github.com/repos/dotnet/coreclr/issues/10113,briansull,0,0,0,2,0,0,support for ibc profiling for readytorun images allow tuning flag in crossgen.exe for readytorun images added support to create ibc profile data for readytorun images added support for method profile counts in readytorun images incremented readytorun header version to added new optional section readytorun_section_profiledata_info added new readytorun jit helper readytorun_helper_logmethodenter changed the codegen for readytorun basic block profiling in compiler::fginstrumentmethod to encode a handle to the current method under readytorun we have us to use a call to imptokentohandle with a corinfo_resolved_token implemented caching for m_isinstrumentedstatus using enum isinstrumentedstatus added new method module::initializeforprofiling moved the ibc profiling support out of module::initializenativeimage and into the new method module::initializeforprofiling added new method module::hasnativeorreadytorunimage
213444082,10099,https://api.github.com/repos/dotnet/coreclr/issues/10099,ahsonkhan,1,0,0,0,0,0,identified a few things that we should change in the benchmark code itself a the old tests were accidentally commented out and the new tests cant be run from the command line they can only be run through xunit-perf we should be able to run all the tests both from command line and xunit-perfb we should do something to make sure the computations in the inner loops arent dead ill look into options to do this in a way that wont unduly hamper bounds check removal optimizationsc in the tests as originally written the perftestfoo methods are generic so their calls to span methods are generic-to-generic so we pay extra overhead with t=string since both the perftestfoo code and the span code get shared to do dictionary lookups in the tests as theyre checked in to coreclr the perftestfoo methods are no longer generic maybe we want to find a way to use generics again to make sure that pattern gets tested
213443723,10098,https://api.github.com/repos/dotnet/coreclr/issues/10098,ahsonkhan,1,0,0,0,0,0,related to issue
213263575,10083,https://api.github.com/repos/dotnet/coreclr/issues/10083,hqueue,1,0,1,0,0,0,fix wrong comparision in previous commit.(this is a part of
212928485,10056,https://api.github.com/repos/dotnet/coreclr/issues/10056,tannergooding,1,0,0,0,0,0,the following commit broke support for building on vs ffcaffcdfbeddccc note the support for building on vs was validated before the commit but was actually merged just after the aforementioned was merged.the failure resembles the following d:\coreclr\tools\microsoft.csharp.core.targets error msb the overridetoolhost parameter is not supported by the csc task verify the parameter exists on the task and it is a settable public instance property d:\coreclr\src\mscorlib\ref\mscorlib.csproj i have confirmed that reverting the commit resolves the issue but i dont think we should revert it instead we should find out what in the new toolset has broken the vs support and update the toolset again
212921225,10054,https://api.github.com/repos/dotnet/coreclr/issues/10054,pgavlin,1,0,0,0,0,0,instead of executing a rather long set of conditionals on each callto gentreeuseedge::operator decide on the function that will beused to advance the iterators state in the constructor.this results in about a decrease in instructions retired when compilingsystem.private.corelib.dll on linux as measured using callgrind
212685810,10034,https://api.github.com/repos/dotnet/coreclr/issues/10034,seanshpark,1,0,0,0,0,0,this is initial patch to enable feature_fixed_out_args for x/linuxenable unix_x_abi_foa line in src/inc/corabi.h to test
212631299,10024,https://api.github.com/repos/dotnet/coreclr/issues/10024,ragmani,0,0,0,0,0,1,it was coded as rbx instead of ebx register in clobber list position
212612817,10019,https://api.github.com/repos/dotnet/coreclr/issues/10019,sivarv,2,0,0,0,0,0,the current implementation lies about the type of struct field as the type of its underlying scalar field because of which in some cases it could lead to an ir where either rhs or lhs of copyblk asg is a scalar type var these cases has following limitations lhs is a scalar local var this will be marked as donotenregister by fgmorphcopyblk rhs is a scalar local var assertionprop will not perform const prop on rhs such an asg since copyblk could be incorrectly considered as initblk by morph logic.these two limitations could be avoided by implementing recursive struct promotion.category:cqtheme:promotionskill-level:expertcost:large
212294771,9996,https://api.github.com/repos/dotnet/coreclr/issues/9996,BruceForstall,0,0,1,0,0,0,only reformatting no code changes.@dotnet/jit-contrib ptal
212219316,9984,https://api.github.com/repos/dotnet/coreclr/issues/9984,lgreenlee,2,0,0,0,0,0,after utilizing the httpclient for several micro-services i believe some improvements can be made to the httpclient under linux improvement remove the curl dependency/or httpclientslim?i believe there is a thread discussing this already but the the dependency on curl is problematic it causes and will continue to cause a few basic issues such as this one time the curl dependency will become more pronounced as interfaces change eventually there will be some sort of breaking change that will cause your users like me subtle and/or obvious problems such as software ceasing to work or unwanted but needed system updates to non net software the fix for this particular issue may be a static dependency there are other reasons though...a byproduct of the curl dependency is that the behavior of the httpclient is handicapped we cannot retrieve an underlying network stream from the httpclient and do with it as we wish access to the stream is hidden within curl rich signaling of error conditions and network state are not possible as a result.finally there is also some overhead associated with pinvoke and the interop we cannot say the current implementation is the most efficient way to make these requests.i would propose a higher performance lighter weight client with better underlying network access and memory usage our current implementation improvement synchronous methodsin some scenarios i would like to be sure that i know what my code is doing there are times such as trying to design a process that is well understood and verifiable where placing that code in a thread and running it to completion or forever is a desirable attribute fundamentally the use of the await keyword introduces code that the developer does not write after having spent the last months developing on linux with just the vs code debugger debugging complex threading issues is very difficult and time consuming finally the inclusion of the httpclient forces me to change the overall structure of my service if it is primarily synchronous in nature improvement better indication of proper usagecreation of the httpclient through new to make an individual requests is not recommended but it is easy to do and seemingly correct since there are no api features to prevent us from making the mistake time_wait socket growth is also not an expected behavior if i call dispose on the httpclient perhaps implementing a httpclientpool with the ability to retrieve named instances of an http client and hiding the constructor for the httpclient?the importance of the httpclient to the net core framework cannot be understated it one of a handful of mechanisms to communicate outside the clr is the only http based mechanism we have to complete rest operations it must work well now and into the future for developers and organizations to continue to adopt net core as a development and deployment platform
211906919,9961,https://api.github.com/repos/dotnet/coreclr/issues/9961,qmfrederik,4,0,0,0,0,0,this pr adds the ability to create a rootfs for cross-building for arm android as well as the cmake files required to get the build process going
211906079,9960,https://api.github.com/repos/dotnet/coreclr/issues/9960,davidfowl,1,0,0,0,0,0,when writing a framework that dispatches to user methods its quite common to reflect over all methods of a particular shape on an object and store a methodinfo for later use the scan and store is typically a one time cost done up front but the invocation of these methods happen lots of times one or many times per http request for example historically to make invocation fast you would generate a dynamicmethod using reflection emit or generate a compiled expression tree to invoke the method instead of using methodinfo.invoke asp.net does this all the time so much so that we now have a shared component to do this as some of the code can be a bit tricky).with the advent of newer runtimes like project n and corert it would be great if there was first class support for creating a thunk to method this is what i think it could look like: c#class program first class delegate type in the clr use to express the stub that calls into the underlying method public delegate object thunk(object target object arguments static void main(string args var methods typeof(controller).getmethods var map new dictionary
211894033,9958,https://api.github.com/repos/dotnet/coreclr/issues/9958,jkotas,1,0,0,0,0,0,check what was done for x/x in
211587373,9928,https://api.github.com/repos/dotnet/coreclr/issues/9928,parjong,1,0,0,0,0,0,this commit revises unwinder to consider stack align padding
211554679,9924,https://api.github.com/repos/dotnet/coreclr/issues/9924,RussKeldorph,1,0,0,0,0,0,remove file copy hack and use the new msbuild property to allowoverriding the runtime when running corefx tests.fixes
211492594,9917,https://api.github.com/repos/dotnet/coreclr/issues/9917,BruceForstall,2,0,0,0,0,0,on x build an x-host arm-target altjit.on amd build an amd-host arm-target altjit.each are named protononjit.dll using our existing namingconvention proto for prototype nonjit meaning the codewont be executed).use these via: set complus_altjit=*set complus_altjitname=protononjit.dll of course instead of you can use any function name.they are very useful for debugging the jit in a nicer environmentthan the full native environment especially if the full nativeenvironment isnt complete or if the tools such as debuggers editors)are better in the cross environment than the native environment
211481552,9914,https://api.github.com/repos/dotnet/coreclr/issues/9914,danmosemsft,1,0,0,0,0,0,generally were expecting the net core tests to throw up breaks of this sort but since these are explicit blocks and i saw them lets have this issue to make sure we dont miss it.if you know/see other cases where we explicitly block uwp please do create more issues. c:\git\coreclr\src\mscorlib\src\system\appdomain.cs if feature_appx if isappxmodel throw new notsupportedexception(environment.getresourcestring(notsupported_appx assembly.loadfrom endif if feature_appx if isappxmodel throw new notsupportedexception(environment.getresourcestring(notsupported_appx assembly.loadfile endif if feature_appx if isappxmodel throw new notsupportedexception(environment.getresourcestring(notsupported_appx assembly.reflectiononlyload endif if feature_appx if isappxmodel throw new notsupportedexception(environment.getresourcestring(notsupported_appx assembly.load(byte endif rahku
211445272,9909,https://api.github.com/repos/dotnet/coreclr/issues/9909,lucenticus,1,0,0,0,0,0,this pr fixes issue with incorrect calling convention for reverse p/invoke delegate.with this fix we enable gdbjit interface on x/linux coreclr_gdbjit=helloworld.exe lldb corerun helloworld.exe lldb target create coreruncurrent executable set to corerun i).(lldb settings set target.run-args helloworld.exe(lldb b mainbreakpoint no locations pending).warning unable to resolve breakpoint to any actual locations.(lldb rprocess launchingprocess launched corerun i location added to breakpoint process stopped thread tid xfea jit(x) helloworld_program::main(args=xfdc at helloworld.cs name corerun stop reason breakpoint frame xfea jit(x) helloworld_program::main(args=xfdc at helloworld.cs public static void main(string args program myprogram new program myprogram.show_message lldb related issue please take a look.\cc dmitri-botcharnikov seanshpark parjong ayuckhulk
211436640,9908,https://api.github.com/repos/dotnet/coreclr/issues/9908,AndyAyersMS,49,0,0,0,0,29,introduced some simple devirtualization some areas for future enhancements x devirtualize interface calls logic for this is more complex than for virtual calls see x devirtualize calls on struct types make sure the right method entry point in invoked virtual struct methods come in boxed and unboxed flavors see which removes the box after calling the unboxed entry point try and remove the upstream box and copy too likely requires first-class structs some progress in and if we cant call the unboxed entry point we may still know that the method called wont allow the the this pointer in the call to escape so we can perhaps stack-allocate the object in its boxed form and pass that here wed be counting on the fact that methods on mutable gc value types should already be using checked write barriers for updates likewise we can consider using boxed on stack for some boxed arguments to well known methods refactor the jit to retain type information for a larger variety of tree nodes likely requires carefully breaking the widespread assumption in the jit that class handles are captured only for struct types do some simplistic type propagation during importation for instance during fgfindbasicblocks the jit could count how many times each local appears in a starg or ldarga instruction if there is just one starg which should be a fairly common case then at the starg the jit can check the type of the value being assigned and use it if more precise than the locals declared type this in this case it is also safe to propagate the exactness flag some of this now done see consolidate tracking of types within the jit for structs and classes right now there is a general assumption that the class handle fields in various places trees lcl vars imply struct types do more ambitious type propagation during optimization once we have ssa we should be able to trigger late devirtualization during optimization too improve the ability of the jit to gather type information from various operations for instance type tests see enable inlining of late devirtualized calls at least for those calls devirtualized during inlining experiment with guarded devirtualization by inserting appropriate type checks some preliminary work for this is noted in experiment with speculative devirtualization by considering what is known about overrides at the time a method is jitted obtain more accurate return types from calls to shared generic methods whose return types are generic this is typical of many collection types eg list.get_item returns t in many cases the caller will know the type of t exactly but currently the jit ends up with the shared generic ref type placeholder type canon theres an example of this in the fromcollections regression test see for a partial fix likewise improve types in the inlinee when inlining shared generic methods inlining effectively unshares the method this may trigger devirtualization right now we may record shared types for inlinee args and locals when we could potentially record unshared types see update logic to handle indirection patterns seen during prejit see notes in improve test coverage by adding final/sealed to classes in existing test cases perhaps creating some kind of tooling to experimentally attempt this and decide when it is correct to do so improve checked build test coverage by enabling jit optimization of loader tests or else start running release build tests against a checked jit x sharpen types for temps used to pass inlinee args early issue pr x sharpen return type if all reachable returns have more specialized type than the methods declared return type and there is a return spill temp avoid or propagate improved types through various layers of spill temps see if there is any way to learn about actual types from readonly statics eg category:cqtheme:devirtualizationskill-level:expertcost:extra-large
211358366,9903,https://api.github.com/repos/dotnet/coreclr/issues/9903,hseok-oh,5,0,0,0,0,0,i hope to build x/linux in ci machine using docker build native code using x ubuntu docker container build managed code in x environment cannot use dotnetcli in x/linux test using x ubuntu docker containeri succeeded building x/linux coreclr using this steps not test yet if we use x docker images the rootfs for x is needless.to do this we need x ubuntu docker image including packages to build and test maybe same packages for ubuntu-arm build related issue coreclr x ci support coreclr build ci support coreclr test use official docker image for coreclr build testcorefx x ci support corefx build dotnet/corefx ci support corefx test use official docker image for corefx build test dotnet/corefx
210841251,9855,https://api.github.com/repos/dotnet/coreclr/issues/9855,lucenticus,1,0,0,0,0,0,this pr implements initial fix of arguments passing in umthunkstub.fix for issue this pr also fixes following interop tests:interop/bestfitmapping/bestfitmapping/bestfitmapping.shinterop/arraymarshalling/boolarray/marshalboolarraytest/marshalboolarraytest.shinterop/refint/refinttest/refinttest.shinterop/refchararray/refchararraytest/refchararraytest.shinterop/stringmarshalling/lptstr/lptstrtest/lptstrtest.sh@janvorli parjong seanshpark ptal\cc dmitri-botcharnikov
210359158,9810,https://api.github.com/repos/dotnet/coreclr/issues/9810,parjong,1,0,0,0,0,0,this commit revises callehfunclet and callehfilterfunclet to have byte aligned stack frame
210338930,9805,https://api.github.com/repos/dotnet/coreclr/issues/9805,BruceForstall,1,0,0,0,0,2,often i see coreclr_initialize failed status x or similar this is very unfriendly corerun should provide better root cause error messages so youre not required to fire up a debugger to track down every configuration mistake
210316061,9803,https://api.github.com/repos/dotnet/coreclr/issues/9803,mikedn,2,0,0,0,0,0,avoid duplicate argument validation fix failed optimization attempt uint)i a.length needs to be uint uint)a.length otherwise it gets promoted to long and thats bad for bit architectures use unsafe.readunaligned to avoid alignment handling complications
210215580,9787,https://api.github.com/repos/dotnet/coreclr/issues/9787,ahsonkhan,1,0,0,0,0,0,related pr for slow span this issue
210202602,9786,https://api.github.com/repos/dotnet/coreclr/issues/9786,vkvenkat,8,0,0,0,0,0,this pr optimizes buffer.memorycopy for lengths up to a threshold performance measurements were made on a skylake desktop intel(r core(tm)i-k cpu ghz with gb ram we used windows enterprise and ubuntu we used a micro-benchmark which exercises multiple buckets of pseudo-random copy sizes from to kb details below performance improvements with the optimization to for x windows to for x windows to for x ubuntuthe below charts show the performance speedup:! image below table has absolute clocks in ticks for million copy operations:! image the pseudo-code for the micro-benchmark buckets of copy sizes within specified ranges for int i i max_buckets i random rnd new random for int j j copylen j randomize copy length within bounds copylen j ushort rnd.next range changes with bucket begin datetime.now.ticks for int k k k for count count copylen count buffer.memorycopy(psource ptarget copylen count dest max size changes with bucket time datetime.now.ticks begin time reported for bucket
210171644,9775,https://api.github.com/repos/dotnet/coreclr/issues/9775,adiaaida,0,0,0,1,0,0,this change adds scripting to run perf testing in the lab we perform thetesting by running crossgen on a list of dlls it then writes the data to acsv file which is passed to other processing scripts
210156806,9773,https://api.github.com/repos/dotnet/coreclr/issues/9773,mikedn,6,0,0,3,0,0,if uint)i uint)a.len is true then we know that i is always within bounds and so a i does not need a range check
210126772,9768,https://api.github.com/repos/dotnet/coreclr/issues/9768,jamesqo,1,0,0,0,0,0,separated from these checks still needed in net core the comments mention things people using reverse p/invoke and people using call instead of callvirt the latter of which is emitted by c#/vb compilers for all classes both of these seem like they would be pretty rare./cc jkotas
209926106,9756,https://api.github.com/repos/dotnet/coreclr/issues/9756,AndyAyersMS,3,0,0,0,0,1,keep a ref count for runtime generic context lookups and track whenan inlinee requires a runtime lookup but then ignores the resultingcontext only report/keep the context alive if there are known uses.this pattern happens frequently in inlined generic code that usestype tests to extract properties of types.addresses
209922075,9754,https://api.github.com/repos/dotnet/coreclr/issues/9754,jkotas,1,0,0,0,0,0,fixes
209874129,9745,https://api.github.com/repos/dotnet/coreclr/issues/9745,daxian-dbw,3,0,0,0,0,0,we found the crossgened powershell assemblies targeting net core cause an intermittent hang when running our powershell class basic parsing tests on linux/osx we have been seeing this issue in our travis ci builds for some time i tried to reproduce it locally by running the tests in a loop and found it only reproducible with the crossgened assemblies see an example screenshot below).repro step install powershell_..-alpha.-ubuntu..._amd.deb on a ubuntu..-x machine the powershell assemblies from that package were crossgened and the crossgen executable used was from nuget/packages/runtime.ubuntu..-x.microsoft.netcore.runtime.coreclr/../tools/crossgen download the attached tests.tar.gz decompress it to get the tests folder and run powershell command foreach i in invoke-pester tests/scripting.classes.basicparsing.tests.ps this command basically runs that test file in a loop for times and a hang will happen for most of the time.things worth mentioning i couldnt reproduce the hang when using il assemblies on linux and osx the crossgened assemblies for windows work fine i never saw this hang happen in our appveyor ci builds the hang only happens on linux and osx those powershell class parsing tests generate a lot of dynamic assemblies powershell class is basically clr types powershell emits types and creates dynamic assemblies when parsing a powershell class in a script. tests.tar.gz
209855437,9742,https://api.github.com/repos/dotnet/coreclr/issues/9742,sivarv,1,0,0,0,0,0,"re-instating this optimization addressing gc-hole caused by initial implementation.the reason for gc-hole is that since struct promotion logic lies about the type of struct field as the type of its underlying single field ir could havegt_ind(gt_add(lclvaraddr valuewhere is the field offset representing a fieldseq but lclvaraddr type is not struct but a scalar due to retyping of struct as its underlying field).say the single field is a gc-type ref/byref in such a case lclvar type would be ref/bref and it is getting updated through an addr mode emitter wont be able to recognize that the addr mode is actually assigning to a localvar and doesnt emit gc-info indicating that the stack slot of lclvar is going live with gc-ref/byref.as a short term fix the above ir gets folded into lclvar value in rationalizer surprisingly rationalizer logic alone resulted in an asm diff imrovement for one of the pinvoke stubs in mscorlib.i have verified that fast span slice benchmark also benefits due to rationalizer change. here is ngen asm diff of mscorlib on desktop code size improvements code sizes in bytes filename baseline diff improvement improvement funcs mscorlib.dasm functions improved total bytes improvement improvement goes from to diff of valuecollection int,datetime system.int,system.datetime :getenumerator():struct:this improvement goes from to diff of valuecollection datetime,timespan system.datetime,system.timespan :getenumerator():struct:this improvement goes from to diff of keycollection datetime,timespan system.datetime,system.timespan :getenumerator():struct:this improvement goes from to diff of system.collections.generic.list datetime system.datetime :getenumerator():struct:this improvement goes from to diff of system.collections.generic.list gchandle system.runtime.interopservices.gchandle :getenumerator():struct:this improvement goes from to diff of system.collections.generic.list eventregistrationtoken system.runtime.interopservices.windowsruntime.eventregistrationtoken :getenumerator():struct:this improvement goes from to diff of system.collections.generic.list timespan system.timespan :getenumerator():struct:this improvement goes from to diff of keycollection eventregistrationtoken,__canon system.runtime.interopservices.windowsruntime.eventregistrationtoken,system.__canon :getenumerator():struct:this improvement goes from to diff of system.collections.generic.dictionary __canon,eventregistrationtokenlist system.__canon,system.runtime.interopservices.windowsruntime.windowsruntimemarshal+eventregistrationtokenlist :system.collections.generic.icollection>.add(struct):this improvement goes from to diff of valuecollection int,datetime system.int,system.datetime :system.collections.ienumerable.getenumerator():ref:this aggregated functions improved total bytes improvement improvement goes from to diff of x enumerator eventregistrationtoken,__canon system.runtime.interopservices.windowsruntime.eventregistrationtoken,system.__canon :movenext():bool:this improvement goes from to diff of x system.internal:nullablehelper():struct improvement goes from to diff of x enumerator eventregistrationtoken,__canon system.runtime.interopservices.windowsruntime.eventregistrationtoken,system.__canon :system.collections.ienumerator.get_current():ref:this improvement goes from to diff of x enumerator datetime,timespan system.datetime,system.timespan :system.collections.ienumerator.get_current():ref:this improvement goes from to diff of x enumerator datetime,timespan system.datetime,system.timespan :movenext():bool:this improvement goes from to diff of x enumerator __canon,eventregistrationtokenlist system.__canon,system.runtime.interopservices.windowsruntime.windowsruntimemarshal+eventregistrationtokenlist :system.collections.ienumerator.get_current():ref:this improvement goes from to diff of x domainneutralilstubclass:il_stub_reversepinvoke(long):long improvement goes from to diff of x enumerator int,datetime system.int,system.datetime :system.collections.ienumerator.get_current():ref:this improvement goes from to diff of x enumerator int,datetime system.int,system.datetime :movenext():bool:this improvement goes from to diff of x domainneutralilstubclass:il_stub_winrttoclr(long):int:this functions regressed total bytes regression regression goes from to diff of system.collections.generic.list datetimeoffset system.datetimeoffset :iscompatibleobject(ref):bool regression goes from to diff of system.collections.objectmodel.readonlycollection datetimeoffset system.datetimeoffset :iscompatibleobject(ref):bool regression goes from to diff of system.collections.generic.list datetimeoffset system.datetimeoffset :removeat(int):this regression goes from to diff of system.collections.generic.arraysorthelper datetimeoffset system.datetimeoffset :pickpivotandpartition(ref,int,int,ref):int regression goes from to diff of system.collections.generic.genericarraysorthelper datetimeoffset system.datetimeoffset :pickpivotandpartition(ref,int,int):int regression goes from to diff of system.collections.generic.list datetimeoffset system.datetimeoffset :findlast(ref):struct:this regression goes from to diff of system.collections.generic.list datetimeoffset system.datetimeoffset :find(ref):struct:this regression goes from to diff of system.collections.generic.genericarraysorthelper datetimeoffset system.datetimeoffset :heapsort(ref,int,int regression goes from to diff of system.collections.generic.arraysorthelper datetimeoffset system.datetimeoffset :heapsort(ref,int,int,ref regression goes from to diff of system.diagnostics.tracing.traceloggingtypeinfo datetimeoffset system.datetimeoffset :writeobjectdata(ref,ref):this aggregated functions regressed total bytes regression regression goes from to diff of x enumerator __canon,eventregistrationtokenlist system.__canon,system.runtime.interopservices.windowsruntime.windowsruntimemarshal+eventregistrationtokenlist :movenext():bool:this regression goes from to diff of x system.throwhelper:ifnullandnullsareillegalthenthrow(ref,int total"
209820009,9738,https://api.github.com/repos/dotnet/coreclr/issues/9738,stephentoub,1,0,0,0,0,0,ordinalcomparer was parameterized by ignorecase meaning every call to it switched on ignorecase and took a path based on whether stringcomparer.ordinal or stringcomparer.ordinalignorecase was used as both of these are so commonly used ive split the type into one sealed class for each and simplified the code for each even with the split total lines of c code decreased added a special path to string.equal(string stringcomparison for ordinalignorecase i switched stringcomparer.ordinalignorecase to use that rather than string.compare stringcomparison.ordinalignorecase i also then removed a couple of null checks that were optimizing for comparing a non-null string against a null string which shouldnt be the common case strongly-typed the various static readonly comparer fields on stringcomparer applied the same workaround used in that moves the return out of the loop in some microbenchmarks it had no effect on a few e.g comparing abcdefghijklmno to abcdefghijklmnz or ssssssssss to ssssssssss it had upwards of a improvement i tagged it with a comment with the associated issue number to undo if/when the jit is better able to optimize this
209762815,9736,https://api.github.com/repos/dotnet/coreclr/issues/9736,stephentoub,4,0,0,1,0,0,makes datetime.utcnow much more precise at the expense of being x slower than it was previously.for example prior to the change this code: c#var list new list();for int i i i list.add(datetime.utcnow.ticks);foreach long tick in list console.writeline(tick); produced results like: after the change it produces results like: fixes vancem jkotas
209618344,9727,https://api.github.com/repos/dotnet/coreclr/issues/9727,BruceForstall,0,0,0,1,0,0,we dont need to build the static lib and crossgen static libversions of the jit unless feature_merge_jit_and_engine is set.and since we currently dont set it this means doing twofewer jit builds
208953297,9683,https://api.github.com/repos/dotnet/coreclr/issues/9683,AndyAyersMS,3,0,0,0,0,0,"for fixed out args abis the jit currently computes the size of theout arg area during morph as it encounters calls that must pass argumentsvia the stack.subsequently the optimizer may delete calls either because they arepure and the results are unused or because they are conditional and theguarding predicates are resolved by the optimizer in such a way thatthe call is no longer reachable.in particular if all the calls seen by morph are subsequently removed bythe optimizer the jit may generate a stack frame that it never uses anddoesnt need if only some calls are removed then the stack frame may endup larger than necessary.one motivating example is the inlining of a shared generic method thatignores its generic context parameter the caller typically must invoke a purehelper to determine the proper argument to pass post inline the calls resultis unused and the helper call is deleted by the optimizer.this change defers the outgoing arg size computation until fgsimplelowering,which runs after optimization the code in morph now simply records theneeded size for each call in the associated fgarginfo.as before the outgoing arg size computation ignores fast tail calls sincethey can use the caller-supplied scratch area for memory arguments.the jit may introduce helper calls after optimization which could seeminglyinvalidate the out args area size the presumption here is that these callsare carefully designed not to use the caller-supplied scratch area thecurrent code makes the same assumption.this change introduces some unanticipated diffs optcse estimates theframe size to decide how aggressive it should be about cses of localvariable references this size estimate included the out args area whichappears to be something of an oversight there are no cse opportunitiesin this area and the offsets of the other local variables are not impactedby the size of this area with this change the out args area size is seenas zero during optimization and so the cse strategy for a method may bedifferent arguably the new behavior is more sensible"
208293582,9638,https://api.github.com/repos/dotnet/coreclr/issues/9638,VSadov,1,0,0,0,0,0,environment.currentexecutionid seems to be a generally useful api that can be used to correlate accesses to striped data in order to minimize unwanted cross core sharing.currently the best correlation option is the currentmanagedthreadid which helps with continuity of accesses to the same stripe within a thread but does not help much with preventing unwanted stripe sharing from threads running on separate cores
207761315,9607,https://api.github.com/repos/dotnet/coreclr/issues/9607,wateret,1,0,0,0,0,0,seems like this is missing part of x/linux port
207711388,9602,https://api.github.com/repos/dotnet/coreclr/issues/9602,parjong,1,0,0,0,0,0,esp may be variable when unix_x_abi is used and incorrect esp especially resuming from exception causes various issues such as jit.il_conformance.old.conformance_base.conv_ovf_r_i test failure.this commit attempts to insert sp-restore instruction in function epilog to fix such issues
207672418,9594,https://api.github.com/repos/dotnet/coreclr/issues/9594,sivarv,2,0,0,0,0,0,right now the existing implementation allows only structs with pointer sized fields this would mean int/uint/ref/byref on bit and long/ulong/ref/byref on bit we should be able to permit promotion of a following struct on bit for example struct foo struct bar int a int b} similarly the following struct both on bit and bit targets struct foo struct bar short a short b int c category:cqtheme:promotionskill-level:expertcost:medium
207339183,9562,https://api.github.com/repos/dotnet/coreclr/issues/9562,AndyAyersMS,3,0,0,0,0,0,the jit relies on a particular tree remaining intact during importationto optimize type equality tests commonly found in generics.in the jit started aggressively spilling the evaluation stack beforecalls which broke up the trees needed for the optimizations.in the special cases pertaining to type tests the trees can safely remainintact because we know the calls cant interact with the computations onthe stack recognize these cases and selectively suppress spilling.closes
207311337,9560,https://api.github.com/repos/dotnet/coreclr/issues/9560,JosephTremoulet,3,0,0,0,0,0,this is a pure helper w/o side-effects so add it to the lists oftractable helpers in value-numbering this allows redundant calls to becsed and fixes so we can again optimize away type checks on typeparameters in generic code a not-infrequent pattern
207070466,9541,https://api.github.com/repos/dotnet/coreclr/issues/9541,jkotas,2,0,0,1,0,0,rename jithelpers.containsreferences
207069950,9540,https://api.github.com/repos/dotnet/coreclr/issues/9540,benaadams,5,0,0,0,0,0,"list clear is warmspot in kestrel based clear trims to asmmarking list :clear():this as noinline because of unprofitable inlinesuccessfully inlined jithelpers:containsreferences():bool il bytes depth below always_inline size inline treeinlines into d list :clear():this il tr b below always_inline size jithelpers:containsreferences():bool il tr failed noinline per il/cached result array:clear(ref,int,int)budget initialtime finaltime initialbudget currentbudget=budget initialsize finalsize assembly listing for method list :clear():this emitting blended_code for x cpu with sse optimized code rsp based frame partially interruptible final local variable assignments v this v,t ref rcx this v outargs v lclblk rsp+x lcl frame size g_m_ig ec sub rsp nop g_m_ig c xor eax eax mov dword ptr rcx eax ffc inc dword ptr rcx+ g_m_ig c add rsp c ret total bytes of code prolog size for method list :clear():this shame about the no-inline...for remove i was looking to swap array.copy for buffer.memmove or similar however the span code for getting a pointer to a t element in an array is a little exotic"
207031781,9539,https://api.github.com/repos/dotnet/coreclr/issues/9539,benaadams,5,0,0,0,0,0,list add and clear are warmspots in kestrel is a mild tweak to add however as whats being cleared is a list of gchandle structs clear is a significant win.@jkotas is this a valid use of jithelpers.containsreferences() ?/cc stephentoub
206991990,9533,https://api.github.com/repos/dotnet/coreclr/issues/9533,sdmaclea,1,0,0,0,0,0,this is issue is to track the status for arm/unix on ubuntu it represents my view of the tree which includes all my published pull requests pal tests passing coreclr teststhere are currently about failing tests see crossgen rr failuresthere currently about tests which fail when using the rr system.private.corelib.ni.dll see gc stress see all testing results excludes known failures w/o stress unsupported on unix unexpected failures on unix amd also results exclude handful of tests failing due to timeout some modes of gcstress seems to increase runtime gcstress=x passing gcstress=xthere are currently about intermittent failures gcstress=xthere are currently about a dozen tests failing gcstress=x passing corefx testsno attempt to run
206948316,9520,https://api.github.com/repos/dotnet/coreclr/issues/9520,CarolEidt,1,0,0,0,0,0,we need to validate that all the il implementations are correct when vector
206743443,9491,https://api.github.com/repos/dotnet/coreclr/issues/9491,jkotas,1,0,0,0,0,0,coreclr does not have cas and so we can conveniently use it to mark methods with stackcrawlmark todecouple it from noinlining the original purpose of dynamicsecuritymethod was to disable inliningof the caller and to insert cas security checks so we are basically just keeping the first part.fixes
206672599,9477,https://api.github.com/repos/dotnet/coreclr/issues/9477,sivarv,1,0,0,0,0,1,fgpromotestructs has a heuristic to promote structs even if its fields are not accessed provided that struct has no more than fields once a struct is promoted if it gets passed as a parameter to a call or is assigned a return value from a call then it copying is done field by field assignment which may not be efficient than doing rep.stos or xmm reg based copying.there is scope for further refining this heuristic if it is known whether a struct local is passed as a param or is assigned return value from a call to reduce field-by-field assignment impact.category:cqtheme:promotionskill-level:intermediatecost:medium
206662483,9473,https://api.github.com/repos/dotnet/coreclr/issues/9473,benaadams,2,0,0,0,0,0,"gchandle is either mostly a thin wrapper around vm functions or simple bitshifts and casts however its current implementation has significant overhead as it is called a huge amount and its functions are marked by ngen as permanently uninlinable.previously gchandle calls for libuv write calls in marshal gchandle calls for libuv write calls in marshal they are fairly simple so for example while gchandle:setispinned is unprofitable and permanently no inline is asm ends up extremely simple asmmarking gchandle:setispinned():this as noinline because of unprofitable inlinesuccessfully inlined intptr:op_explicit(long):long il bytes depth below always_inline size successfully inlined intptr:.ctor(long):this il bytes depth below always_inline size inline treeinlines into e gchandle:setispinned():this il tr c below always_inline size intptr:op_explicit(long):long il tr bf below always_inline size intptr:.ctor(long):thisbudget initialtime finaltime initialbudget currentbudget=budget initialsize finalsize assembly listing for method gchandle:setispinned():this emitting blended_code for x cpu with sse optimized code rsp based frame partially interruptible final local variable assignments v this v,t byref rcx this v tmp v long zero-ref v tmp v,t long rax ld-addr-op v tmp v,t long rax v outargs v lclblk rsp+x lcl frame size g_m_ig ff nop g_m_ig b mov rax qword ptr rcx c or rax mov qword ptr rcx raxg_m_ig c ret total bytes of code prolog size for method gchandle:setispinned():this"
206658197,9471,https://api.github.com/repos/dotnet/coreclr/issues/9471,stephentoub,6,0,0,0,0,1,this pr attempts to reduce the overhead associated with executing tasks and invoking async methods.microbenchmarks look pretty good repeatedly creating an asynctaskmethodbuilder(object x having processorcount worker threads continually queueing a task to its local queue popping/executing it x having processorcount worker threads continually queueing a task to the global queue dequeueing/executing one fluctuated within noise long chain of synchronous continuations fluctuated within noise long chain of asynchronous continuations fluctuated within noise id like to hold off on merging though until doing some more verification on asp.net workloads to make sure theyre at least not negatively affected.)cc jkotas kouvel benaadams
206613521,9455,https://api.github.com/repos/dotnet/coreclr/issues/9455,sivarv,1,0,0,0,0,0,"this also addresses specific case of but the more generic issue remains.asm diffs indicate also the following benefits reduction in stack frame size eliminating the need to zero init stack frame in some cases or reduce the size of zero init totally eliminates some structs on frame due to copy prop.the regressions are the cases where the promoted struct is getting passed as a parameter to a call a copy of promoted struct is made which would be a field by field assignment instead of byte read and byte write if we had not promoted the struct.here are the spmi diffs on cqperf and fx assemblies:cqperf suite code size improvements code sizes in bytes filename baseline diff improvement improvement funcs cq_perf_clean_thin_unique_all.dasm functions improved total bytes improvement improvement goes from to diff of knucleotide:kfrequency():this improvement goes from to diff of microsoft.codeanalysis.csharp.incontainerbinder:lookupsymbolsinsinglebinder(ref,ref,int,ref,int,ref,bool,byref):this improvement goes from to diff of platform.io.data.shareddata:getlongestspanat(long,int):struct:this improvement goes from to diff of microsoft.codeanalysis.csharp.binder:lookupmembersinclass(ref,ref,ref,int,ref,int,ref,bool,byref):this improvement goes from to diff of microsoft.codeanalysis.csharp.localscopebinder:lookupsymbolsinsinglebinder(ref,ref,int,ref,int,ref,bool,byref):this improvement goes from to diff of microsoft.codeanalysis.csharp.binder:lookupattributetype(ref,ref,ref,int,ref,int,bool,byref):this functions regressed total bytes regression regression goes from to diff of microsoft.codeanalysis.csharp.symbols.sourcenamedtypesymbol:get_layout():struct:this regression goes from to diff of microsoft.codeanalysis.common.commonchildsyntaxlist:getenumerator():struct:this regression goes from to diff of assemblydataforassemblybeingbuilt __canon,__canon system.__canon,system.__canon :bindassemblyreferences(struct,ref):ref:this regression goes from to diff of microsoft.codeanalysis.commonreferencemanager __canon,__canon system.__canon,system.__canon :resolvereferencedassemblies(struct,struct,ref,bool):ref total fx assemblies code size improvements code sizes in bytes filename baseline diff improvement improvement funcs all_fx_clean_thin_unique_all.dasm functions improved total bytes improvement improvement goes from to diff of system.numerics.matrixx:createconstrainedbillboard(struct,struct,struct,struct,struct):struct improvement goes from to diff of system.numerics.matrixx:createworld(struct,struct,struct):struct improvement goes from to diff of system.numerics.matrixx:createbillboard(struct,struct,struct,struct):struct improvement goes from to diff of system.numerics.matrixx:createlookat(struct,struct,struct):struct improvement goes from to diff of system.numerics.vector:negate(struct):struct improvement goes from to diff of system.servicemodel.activities.workflowservice:createoperationproperties(ref):ref:this improvement goes from to diff of system.numerics.matrixx:decompose(struct,byref,byref,byref):bool improvement goes from to diff of qname:equals(ref):bool:this improvement goes from to diff of system.numerics.vector:multiply(struct,float):struct improvement goes from to diff of system.numerics.vector:multiply(float,struct):struct aggregated functions improved total bytes improvement improvement goes from to diff of x system.xml.linq.xcontainer:addfirst(ref):this functions regressed total bytes regression regression goes from to diff of system.collections.generic.arraysorthelper xamlnode system.xaml.xamlnode :swapifgreater(ref,ref,int,int regression goes from to diff of system.collections.generic.arraysorthelper arraysegment system.arraysegment system.byte :swapifgreater(ref,ref,int,int regression goes from to diff of system.collections.generic.arraysorthelper section system.identitymodel.xmlbuffer+section :swapifgreater(ref,ref,int,int regression goes from to diff of system.collections.generic.arraysorthelper section system.servicemodel.xmlbuffer+section :swapifgreater(ref,ref,int,int regression goes from to diff of system.collections.generic.arraysorthelper alternativeissuerendpoint system.servicemodel.security.tokens.issuedsecuritytokenparameters+alternativeissuerendpoint :swap(ref,int,int regression goes from to diff of system.collections.generic.arraysorthelper xamlnode system.xaml.xamlnode :swap(ref,int,int regression goes from to diff of system.servicemodel.channels.defaultwebsocketconnectionhandler:parsesubprotocolvalues(ref):struct regression goes from to diff of system.collections.generic.arraysorthelper alternativeissuerendpoint system.servicemodel.security.tokens.issuedsecuritytokenparameters+alternativeissuerendpoint :swapifgreater(ref,ref,int,int regression goes from to diff of system.collections.generic.arraysorthelper arraysegment system.arraysegment system.byte :swap(ref,int,int regression goes from to diff of system.collections.generic.arraysorthelper sectio"
206604314,9454,https://api.github.com/repos/dotnet/coreclr/issues/9454,mikedn,3,0,0,0,0,0,il doesnt have a cne instruction so compilers use cgt.un instead the jit recognizes certain patterns that involve gt_ne e.g x and fails if gt_gt is used instead transform x gt_gt.unsigned into x gt_ne and x gt_le.unsigned into x gt_eq the later case is rare it sometimes occurs as a result of branch inversion.fixes contributes to
206582962,9451,https://api.github.com/repos/dotnet/coreclr/issues/9451,JosephTremoulet,1,0,0,0,0,0,"when a cse candidates defs all share the same conservative value number,its uses can be updated to share that conservative value number as wellwhen cse is performed because we are removing any reloads that may havebeen the cause of the divergence performing this update can improvesubsequent range check elimination when the cse use is array length orindex in a bounds check"
206317166,9418,https://api.github.com/repos/dotnet/coreclr/issues/9418,jkotas,0,0,0,1,0,1,fixes
205966875,9398,https://api.github.com/repos/dotnet/coreclr/issues/9398,mikedn,2,0,0,0,0,0,for bit target the importer sign extends the switch value to long but the switch value is supposed to be unsigned it is compared to the switch arm count which is unsigned int in the cil spec this widening is needed to index the jump table it is not needed when handling the default casechanging the cast to unsigned and moving it just before jump table indexing usually results in smaller code movsx becomes mov which is shorter the default case comparison no longer requires a rex prefix if r-r arent used)fixes
205802898,9392,https://api.github.com/repos/dotnet/coreclr/issues/9392,BruceForstall,1,0,0,0,0,0,it was noticed that many uses of gtgetop fully expect op toexist and be non-nullptr and the use of gtgetop was simplyfor style/readability purposes however it has a cost as itchecks whether the tree is binary first and returns nullptr ifnot for most cases this is unecessary and expensive.introduce a new gtgetpossibleop function that captures theprevious behavior checking if the tree node is binary beforereturning op or returning nullptr otherwise gtgetop ischanged to simply return gtop directly without any checkingin non-debug builds it can be used if you know the op exists.most uses of gtgetop were left alone and hence get the newbehavior the ones that need the old behavior were renamedgtgetpossibleop().mostly newer code is affected as older code would generallyaccess gtop directly whereas newer code started using gtgetop()for style and symmetry especially after gtgetop was introduced
205617210,9370,https://api.github.com/repos/dotnet/coreclr/issues/9370,qmfrederik,0,0,0,1,0,0,this issue track the process to get software and hardware exception handling working on arm linux.background as part of we enabled building coreclr on linux and got hello world to run.lessons learned were that we need llvm to compile for arm compile lldb from source at least on ubuntu zesty to debugcurrent focus is on ubuntu zesty although we may try other linux variants in a later stage too
205459127,9355,https://api.github.com/repos/dotnet/coreclr/issues/9355,jkotas,0,0,0,2,0,0,delete most cas support under mscorlib\src\system\security introduce temporary dummy stubs for a few types that are referenced in many places to be cleaned up later delete enough on the unmanaged side to break ties with the removed types on the managed side there is still quite a bit left though.contributes to
205442720,9351,https://api.github.com/repos/dotnet/coreclr/issues/9351,danmosemsft,0,0,0,1,0,0,fixes a few remaining diffs with the rewritten version it is still about kb larger as there are still diffs for constants that are no longer inlined and serialization helper functions.@jkotas stephentoub
205359429,9340,https://api.github.com/repos/dotnet/coreclr/issues/9340,benaadams,2,0,0,0,0,0,greatly reduces the allocations when calling tostring on a flag enumbefore
205299514,9321,https://api.github.com/repos/dotnet/coreclr/issues/9321,danmosemsft,0,0,0,2,0,0,there is lots of cas-only code codeaccesspermission and related types and code that uses them ideally it would all be removed im guessing one thing to take care of is making sure we continue to do the same parameter validation/throw the same exceptions that has been a gotcha for io in the past.removing remaining feature_cas_policy on the native side is already tracked by
205251593,9312,https://api.github.com/repos/dotnet/coreclr/issues/9312,litian2025,1,0,0,0,0,0,currently ryujit supports max simd intrinsic on float double unsigned byte rest of the types are not supported case simdintrinsicmax if basetype typ_float result ins_maxps else if basetype typ_double result ins_maxpd else if basetype typ_ubyte result ins_pmaxub else if basetype typ_short result ins_pmaxsw else unreached break;however since sse pmaxsd/pmaxsb/pmaxuw/pmaxud are introduced ryujit can take advantage of those intrinsic and support more related types
205249983,9311,https://api.github.com/repos/dotnet/coreclr/issues/9311,litian2025,1,0,0,0,0,0,currently ryujit supports min simd intrinsic on float double unsigned byte and short rest of the types are not supported case simdintrinsicmin if basetype typ_float result ins_minps else if basetype typ_double result ins_minpd else if basetype typ_ubyte result ins_pminub else if basetype typ_short result ins_pminsw else unreached break;however since sse pminsd/pminsb/pminuw/pminud are introduced ryujit can take advantage of those intrinsic and support more related types
205074802,9301,https://api.github.com/repos/dotnet/coreclr/issues/9301,hadi77ir,1,0,0,0,0,0,as both are microsofts properties is it possible i mean in legal terms to use parts of code from reference source in coreclr
204981873,9279,https://api.github.com/repos/dotnet/coreclr/issues/9279,stephentoub,1,0,0,0,0,0,main changes the work-stealing system was storing all of the local lists in a sparse array any time a thread went looking for work it would pick a random place to start in the array and iterate through all of the cells but the array often was much larger than the number of lists it contained because it a grows doubling each time and b never shrinks when threads are removed so all of the iterating needed to check for null on every cell and all of the reads were done with volatile.read to account for potentially concurrent writes as threads were added/removed however the addition/removal of thread-local lists is actually relatively rare even when the thread pool takes threads in and out of service its not generally not allocating new threads or destroying old ones just keeping them in reserve on the side for a while instead we can just use an immutable array thats always the right size all of the old stackcrawlmark was still cluttering up unsafe}queueuserworkitem and preventing those functions and helpers from getting inlined ive removed that goo random.next is used to determine where a thread should start looking for work to steal and it was showing up in a trace as a few percentage points ive replaced it with a faster routine cleaned up some empty try blocks and the associated code around it and helped a few other functions that were showing up in traces be more inlineable.cc jkotas kouvel benaadams
204796815,9269,https://api.github.com/repos/dotnet/coreclr/issues/9269,danmosemsft,0,0,0,2,0,0,contributes to applies all the changes that bclrewriter does to our actual code with the aim of making it possible to remove the rewriting step i did this mostly with a roslyn rewriter but some hand edits as well not ready for detailed review but perhaps someone can glance and see im not on the wrong track x do the delete x diff x windows debug against regular rewrite output using decompiler and using apireviewer x diff unix x and release binaries x review the changes delete empty files x ideally check the tests pass although the diff should be enough this is a big change
204783904,9265,https://api.github.com/repos/dotnet/coreclr/issues/9265,parjong,12,0,0,0,0,2,this issue for tracking x/linux progress with respect to the regression tests.here is the current status on ubuntu docker container on ubuntu x and full result test results coreclr bin dir tests discovered passed failed skipped the above result comes from de with and
204748508,9256,https://api.github.com/repos/dotnet/coreclr/issues/9256,CarolEidt,1,0,0,0,0,0,move all the register requirements treenodeinfoinit code into lsra{arch}.cpp.split methods that currently do both tree transformation and register requirements
204459989,9234,https://api.github.com/repos/dotnet/coreclr/issues/9234,stephentoub,5,0,0,4,0,4,two main changes here theres a fair amount of cruft in the threadpool related to thread aborts as they dont exist on coreclr we can clean all of that up this includes removing one of the two methods from the ithreadpoolworkitem type as it was entirely about thread aborts in concurrentqueue
204443191,9230,https://api.github.com/repos/dotnet/coreclr/issues/9230,AndyAyersMS,18,0,0,5,0,5,"devirtualize calls where the this object type at a call siteis a subtype of the type described at the call site currently learnstypes from local and arg references and a subset of other operators.will devirtualize if either the class or method is final sealed in c#),or if the type is known exactly eg from a newobj).devirtualization is run twice once during importation and again in alimited way after inlinining calls devirtualized during importation areare subsequently eligible for inlining calls devirtualized during inliningcurrently cannot be inlined"
204197108,9208,https://api.github.com/repos/dotnet/coreclr/issues/9208,tmds,2,0,0,0,0,0,lifted from what should be the rid of the portable linux runtime and libraries with a glibc dependency?perhaps it makes sense to introduce a linux-glibc-x rid for this?this would make it clear what rid other c libraries could use e.g linux-musl-x make explicit the glibc dependency of the runtime make explicit the glibc dependency of the libraries\cc janvorli jkotas gkhanna
203844796,9191,https://api.github.com/repos/dotnet/coreclr/issues/9191,sandreenko,0,0,0,1,0,0,set class handler for calli create new flag and phase in the compiler make the transformation after importer in the separate phase
203823939,9189,https://api.github.com/repos/dotnet/coreclr/issues/9189,AviAvni,6,0,0,0,0,0,compile and run
203767728,9179,https://api.github.com/repos/dotnet/coreclr/issues/9179,sivarv,2,0,0,0,0,0,there are many benchstone benchmarks that would benefit from iv widening which currently legacy jit does.from benchmarkgames mandelbrot and nbody are such examples.category:cqtheme:loop-optskill-level:expertcost:large
203766135,9177,https://api.github.com/repos/dotnet/coreclr/issues/9177,sivarv,2,0,0,0,0,0,many such dead/unnecessary locals occur in regexdna bechmark hot method system.dll!system.text.regularexpressions.regexinterpreter.go which accounts for nearly of the execution time of the benchmark go is a big method with big switch statement inside a while-loop it has many calls of the following form: c#this.setoperator(this.runcodes this.runcodepos );ir stmtexpr void i-cxg call void regexinterpreter.setoperator this in rcx lclvar ref v this const int xg arg int xg field ref runcodes lclvar ref v this morphing of arg this.runcodes this.runcodepos introduces the following comma tree that has an assignment gt_comma(gt_comma(tmp this.runcodes bounds-chk on runcodes gt_ind to read array elem) since this arg has an assignment argscomplete routine marks all the previous args needing to be evaluated into temps in the above case this arg gets marked to be evaluated to a temp the new ir would look as follows at a high-level tmpforthis thiscall regexinterpreter.setoperator arg gt_comma(gt_comma(tmp this.runcodes bounds-chk on runcodes gt_ind to read array elem arg tmpforthis later copyprop replaces tmpforthis with actual this v since go method has nearly locals/temps that exceeds tracked lcl limit of tmpforthis is not treated as tracked due to its low refcnt as a result the dead assignment to tmpforthis doesnt get eliminated.as an experiment i have commented out the logic in argscomplete that marks all the previous args needing to be evaluated into temp if any of the args has an assignment the resulting go method has only locals and regexdna execution perf beats jit by that is the original go method has at least dead/unecessary locals along with their dead assignments these unnecessary temps also occupy stack frame space and zero initialized in prolog.category:cqtheme:basic-cqskill-level:expertcost:medium
203682330,9169,https://api.github.com/repos/dotnet/coreclr/issues/9169,JosephTremoulet,2,0,0,0,0,0,"this change teaches value numbering to track states of byref exposed memory,like it currently tracks states of heap memory the default value number for a loadcan then become a function of the memory state and pointer vn this enablescse and loop hoisting to kick in when there are no intervening stores.it also clears the way for us to chain byref exposed memory vns similar to howheap vns are chained via vnf_mapstore to enable value propagation throughbyref params and/or address-taken locals when there are no intervening conflictingstores.there are a few constituent changes a minor refactoring to facilitate the subsequent changes abstracting the current heap tracking into a slightly more general memory tracking that allows for multiple memory kinds of which heap is one adding the byref exposed memory kind value-numbering byref exposed memory states and loadsthe first three changes are no-diff"
203646923,9168,https://api.github.com/repos/dotnet/coreclr/issues/9168,maartenmensink,4,0,0,0,0,0,i have a project that i am trying to get working on the rpi ubuntu i installed the latest and greatest based on am able to run the samples from without any issue but when i try to start our project i get the following stack trace stack trace unhandled exception system.io.fileloadexception could not load file or assembly system.componentmodel.primitives version culture=neutral publickeytoken=bfffdaa the located assemblys manifest definition does not match the assembly reference exception from hresult x at microsoft.extensions.fileproviders.physicalfileprovider.createfilewatcher(string root at microsoft.aspnetcore.hosting.internal.hostingenvironmentextensions.initialize(ihostingenvironment hostingenvironment string applicationname string contentrootpath webhostoptions options at microsoft.aspnetcore.hosting.webhostbuilder.buildhostingservices at microsoft.aspnetcore.hosting.webhostbuilder.build at machine.manager.program.main(string args)aborted core dumped) enviroment ubuntu on raspberry pi runtime version beta-- project.json dependencies microsoft.netcore.app version type platform machine machine.core tools microsoft.aspnetcore.server.iisintegration.tools preview-final frameworks netcoreapp imports dnxcore dotnet portable-net+win dependencies microsoft.aspnetcore.mvc microsoft.aspnetcore.routing microsoft.aspnetcore.server.iisintegration microsoft.aspnetcore.server.kestrel microsoft.extensions.configuration.environmentvariables microsoft.extensions.configuration.fileextensions microsoft.extensions.configuration.json microsoft.extensions.logging microsoft.extensions.logging.console microsoft.extensions.logging.debug microsoft.extensions.options.configurationextensions system.componentmodel system.componentmodel.primitives system.threading buildoptions emitentrypoint true preservecompilationcontext true runtimeoptions configproperties system.gc.server true publishoptions include wwwroot cshtml appsettings.json web.config scripts postpublish dotnet publish-iis publish-folder publish:outputpath framework publish:fulltargetframework project.runtimeconfig.json runtimeoptions framework name microsoft.netcore.app version beta configproperties system.gc.server true
203547843,9163,https://api.github.com/repos/dotnet/coreclr/issues/9163,BruceForstall,1,0,0,0,0,0,during lower trycreateaddrmode will try to find addressmodes and convert them to gt_lea by calling gencreateaddrmode().later the treenodeinfoinit pass walks the ir annotatingnodes with register requirements it was also callinggencreateaddrmode and then clearing various previouslycreated register requirements but not actually changing thenode to a gt_lea in some cases in new code i have not checkedin yet this was leading to code that codegen couldnt handle.it turns out this second call to gencreateaddrmode isunnecessary and undesireable so ive removed it this causesno asm diffs on amd or x run on desktop superpmiand ngen respectively
203544175,9161,https://api.github.com/repos/dotnet/coreclr/issues/9161,ahsonkhan,1,0,0,0,0,0,currently the following span methods contain trivial implementations and they need to be optimized fill clear copyto
203478229,9143,https://api.github.com/repos/dotnet/coreclr/issues/9143,jamesqo,1,0,0,0,0,0,this is a revival of the pr at i had to close a few months earlier because it had too many comments i basically re-wrote the code i had written earlier except with a few changes i removed the optimizations for arm i know very little about that platform so someone more qualified should probably optimize it i kept things mostly the way they were for non-amd platforms the only major thing i changed was replacing branching at the beginning/end of the copy with unaligned writes i very conservatively kept the p/invoke threshold at bytes because even though my benchmarks said that the managed implementation was faster up to bytes nietras benchmarks were saying after this is merged ill open up a new pr where i increase it back to and we can discuss more about the threshold size i also renamed some things to make the code cleaner e.g so that variables have self-explanatory names. please note i am looking to get this merged mostly as-is because its a clear win over what we currently have once this gets in then we can open the door for further discussion/experimentation/etc over optimizations./cc jkotas nietras tannergooding benaadams fyi
203453045,9141,https://api.github.com/repos/dotnet/coreclr/issues/9141,pgavlin,1,0,0,0,0,0,all code under long_asg_ops and fancy_array_opt is statically dead(these symbols are never defined as anything besides this changeremoves this cruft
203420770,9138,https://api.github.com/repos/dotnet/coreclr/issues/9138,jkotas,0,0,0,1,0,0,fixes
203415108,9137,https://api.github.com/repos/dotnet/coreclr/issues/9137,qmfrederik,2,0,0,0,0,0,this pr enables cross-building coreclr to aarch android using ubuntu.its a first stab building on the efforts that cydhaselton and janvorli have undertaken over the holidays.the pr breaks down into a build system for android its based on the android ndk uses clang and allows to cross-compile for android from linux using the usual rootfs setup ive added an init-android.sh shell script which will download the ndk lldb for remote debugging and required third part packages and set up a rootfs for cross compile an cross/android/arm folder which contains the cmake configuration files required to cross configure various fixes to make the code compatible with android use getc and putc instead of getw and putc gcc_s pthread and rt dont need to be linked on android int_t wcsnlen int_min and page_size are already defined fix the thread-related code to use semaphore.h on android use data/local/tmp for temporary file storage not tmp fix an issue with the declaration of reserved with these changes applied all except pal tests pass two related to aarch and two related to tests using etc/password which doesnt exist on android.its a rather large pr so if its better for the review process happy to split up the pr on a commit-by-commit basis the idea is to get feedback early so we make sure we get this right
203268380,9128,https://api.github.com/repos/dotnet/coreclr/issues/9128,sivarv,2,0,0,0,0,0,we have an instance of that in hot method nextpermutation of fannkuch-redux benchmark bool nextpermutation int first p bounds check on p is not eliminated bounds check on p is not eliminated p p bounds check on p is not eliminated p first int i invariant field accesses this.count and this.count.length are not loop hoisted because this while loop entry is not at the top while count i i count i bounds check on p and p are not eliminated int next p p for int j j i j p j p j p i first first next return true look at josephtremoulets comments in this issue for more context on this issue.category:cqtheme:loop-optskill-level:expertcost:medium
203026672,9105,https://api.github.com/repos/dotnet/coreclr/issues/9105,Thealexbarney,14,0,0,0,0,0,the general guidelines that i see for writing in c usually say something like accept as general of an object as you can for your parameters for example instead of requiring a list
202934995,9091,https://api.github.com/repos/dotnet/coreclr/issues/9091,bbowyersmyth,1,0,0,0,0,0,case insensitive equality was found to be a bit of a hot spot in kestrel recently this pr looks at the ascii comparison portion of string.equals(string string stringcomparison.ordinalignorecase).these changes improve the situation where the two strings have mostly the same casing also provides greater consistency for uppercase values.the return value is no longer the case-insensitive difference for equals this is not important the other caller is compare(string string stringcomparison.ordinalignorecase which returns less-than-zero zero or greater-than-zero i double checked the msdn docs and statement the return value is the result of the last comparison performed is a little unclear. isolated perf results strings uppercase and equal method length mean stddev compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns both strings lowercase and equal method length mean stddev compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns string a uppercase string b lowercase and insensitive equal method length mean stddev compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns string a lowercase string b uppercase and insensitive equal method length mean stddev compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns compareordinalignorecaseold ns ns compareordinalignorecasenew ns ns
202727367,9080,https://api.github.com/repos/dotnet/coreclr/issues/9080,hifi,1,0,0,0,0,0,the root of coreclr has the mit license but seems to be some kind of generic microsoft eula for published net components which is included in the nuget packages built from this repo afaik.could this be cleared up
202691072,9072,https://api.github.com/repos/dotnet/coreclr/issues/9072,CarolEidt,1,0,0,0,0,0,this was a test case for an old bug it shows a regression with pr so it will be useful to have this test case available to reference in an issue even though it is not expected to be a common scenario and therefore may be low priority
202562563,9055,https://api.github.com/repos/dotnet/coreclr/issues/9055,markrendle,2,0,0,0,0,0,just been reading up on clearlinux after an official vm image for azure was published it looks great an intel-optimized linux designed for a running containers and b being the base image for containers.obviously i can run the existing debian-based microsoft/dotnet image on a clearlinux host possibly to great effect but i guess the coreclr build and native-compiled libraries wouldnt be taking advantage of whatever the intel optimizations are or would it i dont know about these things.assuming there would be performance benefits can clearlinux be added to the never-ending list of please support this linux
202478956,9053,https://api.github.com/repos/dotnet/coreclr/issues/9053,303248153,5,0,0,0,0,0,as i asked in previous issue now i want to known the relationship of these classes.i made a graph and several conclusions please help me determine theyre correct or wrong.! dia there one gcheap instance used for interface between gc and ee it didnt hold gc_heap instance there logical cores gcheap and gc_heap instances hold each other each gc_heap instance hold generation instances gen gen gen gen but why generation_table have numbergenerations elements gen gen gen point to same segment in the beginning gen points to the rightmost position gen use different segment list large heap segment each managed thread have its own alloc_context alloc_ptr is in the beginning so first gc_heap::allocate of each managed thread will always call allocate_more_space gen and gen have its own alloc_context they will be used when there no explicit allocation context provided like gcheaputilities::useallocationcontexts returns false when the allocation context has run out it will try to allocate more space from free list or segment endalso i have a other small question whats alloc_context::home_heap stand for and whats the purpose of balance_heaps?cc swgillespieplease help me if you have some time thanks your guys first
202446478,9044,https://api.github.com/repos/dotnet/coreclr/issues/9044,danmosemsft,0,0,0,1,0,0,these are always defined in the coreclr build and now we no longer want to preserve mergeability with desktop we can remove them.fixes in progress diff decompilation for each architecture
202302123,9038,https://api.github.com/repos/dotnet/coreclr/issues/9038,tn0502,7,0,0,0,0,0,can we add support for loading symbols within the hosting application as documented here as a mono extension if the library being loaded is internal then the main program is searched for method symbols this is equivalent to calling dlopen with a filename of null this allows you to p/invoke methods that are within an application that is embedding mono.this will make it easier for existing applications to expose method symbols to managed code without having to separating desired methods to a separate dynamic library or passing tables of function pointers to managed code on initialization
202282268,9036,https://api.github.com/repos/dotnet/coreclr/issues/9036,sivarv,3,0,0,0,0,0,knucleotide benchmark heavily uses dictionary lookups it uses the following struct as key into hash table struct bytestring public byte array public int start public int length public override int gethashcode int hc for int i i length i hc hc array start i return hc public bool equals(bytestring other if length other.length return false for int i i length i if array start+i other.array other.start+i return false return true call chain: dictionary.trygetvalue findentry calls gethashcode and equals methods on bytestring. in case of equals or gethashcode methods bytestring accessed is either thisptr or argument passed to the method struct args on windows are considered implicitly by-ref and hence struct fields get accessed through an indirection on a byref legacy jit was able to loop hoist this.array this.array.length this.start other.array other.array.length and other.start by recognizing them as loop invariant this shows up as execution perf difference between ryujit vs legacy jit.category:cqtheme:loop-optskill-level:expertcost:medium
202029097,9019,https://api.github.com/repos/dotnet/coreclr/issues/9019,sivarv,4,0,0,0,0,0,this issue surfaced while analyzing knucleotide benchmark on windows.one of its hot methods kfrequency calls into dictionary.trygetvalue(struct passing it a struct key as param trygetvalue is a simple wrapper method that passes its struct param to dictionary.findentry(struct ref bool) . call chain kfrequency trygetvalue findentry() before in-lining trygetvalue in-liner makes a copy of actual param key and uses the copy within in-linee method body v copy of keyuse v in the place of key while in-lining trygetvalue(). now v in turn is getting passed to findentry by value hence jit will make another copy during argument morphing the resulting ir would be v copy of keyv copy of vfindentry(addr of v) in this particular case there are no more uses of v other than passing it as an arg to findentry though method got in-lined additional struct copies created in that process remain behind in this particular case copy v can be eliminated.the above case occurs twice in knucleotide hot method kfrequency i.e two unnecessary struct copies in a hot loop eliminating such unnecessary copies would benefit real world code as well
201641212,8988,https://api.github.com/repos/dotnet/coreclr/issues/8988,gkhanna79,1,0,0,0,0,0,this does not happen today as evidenced in where build.cmd passes even when crossgen failed: --t::.z command execution succeeded.--t::.z build generating native image of system.private.corelib for windows_nt.arm.checked--t::.z e:\a\_work\\s\bin\product\windows_nt.arm.checked\x\crossgen.exe platform_assemblies_paths e:\a\_work\\s\bin\product\windows_nt.arm.checked out e:\a\_work\\s\bin\product\windows_nt.arm.checked\system.private.corelib.ni.dll e:\a\_work\\s\bin\product\windows_nt.arm.checked\system.private.corelib.dll--t::.z build error crossgen system.private.corelib build failed refer to e:\a\_work\\s\bin\logs\crossgencorelib_windows_nt__arm__checked.log--t::.z e:\a\_work\\s\bin\logs\crossgencorelib_windows_nt__arm__checked.log--t::.z section finishing run build.cmd
201433101,8974,https://api.github.com/repos/dotnet/coreclr/issues/8974,cesarbs,1,0,0,0,0,0,corefx packages contain a version.txt with the commit the package was built from this is really useful to determine if a given change was included in the package.coreclr packages dont have that file making it hard to determine if a change made it to a recent build would be nice to have it there too
201313465,8969,https://api.github.com/repos/dotnet/coreclr/issues/8969,benaadams,5,0,0,0,0,0,up to x faster on encoding.getbytes(string s for utf and ascii when string is ascii.have if bigendian the changes as dont have have a good way of confirming the pattern for little endian.call chains changed mostly to virtual call->validate->concrete call previously it would do virtual call chains with validations on each call.the string overload has a wrinkle it will optimistically take string.length as the length of they output bytes if it encounters a non-ascii char it will then count from that point forward reallocate the array and copy the bytes to the correct sized array then pass over to the current implementation to complete so you maybe get double byte allocations the array versions dont exhibit this behaviour.following up on cc jamesqo
200565815,8939,https://api.github.com/repos/dotnet/coreclr/issues/8939,cesarbs,1,0,0,0,0,0,it appears that os x does not enable xsave on older processors such as the core duo in my late macbook air leading to the process being killed with sigill when xmmymmstatesupport gets called.this is also causing failures on travis test runs on os x for kestrel e.g
200527955,8938,https://api.github.com/repos/dotnet/coreclr/issues/8938,ellismg,1,0,0,0,0,0,corefx is going to be merging changes soon that will break how weconsume them to do our testing to give us time to react well fixthe version of the repository we build to a commit before thechanges well also download artifacts from a saved build producedbefore the change took place so the layout is as we expect.the issue tracking cleaning this up is
200456820,8927,https://api.github.com/repos/dotnet/coreclr/issues/8927,qmfrederik,2,0,0,0,0,0,opening an issue to track the efforts to bring up coreclr/corefx on alpine linux arm.weve re-scoped this issue to track getting hello world to run on bit linux as a next step well work to get exception handling to work on linux see related threads coreclr on android cydhaselton/coreclr#current approach is to use a docker container on an arm device for building coreclr that one is stored here the native components for alpine arm x compile coreclr build.sh arm skipgenerateversion skipmscorlib x run pal tests src/pal/tests/palsuite/runpaltests.sh home/coreclr/bin/obj/linux.arm.debug x compile corefx cplus_include_path=/usr/include/c++/../aarch-alpine-linux-musl/:/usr/include/c src/native/build-native.sh arm x cross compile mscorlib on linux for arm build.sh skipnative arm debug verbose rebuild putting together a sample app x compile and publish a demo stand-alone net core app copy that one over to alpine arm x copy home/corefx/bin/linux.arm.debug/native and home/coreapp cp coreclr/bin/product/linux.arm.debug to the app dir as well as bin/product/linux.arm.debug/mscorlib.dll and bin/product/linux.arm.debug/system.private.corelib.dll from the cross-build on linux x.backlog fix libunwind getcontext call currently stubbed out hardware exception handling on aarm unit tests for the various functions that had to be re-written in assembly?open items:compile clang for alpine this version may include some welcome bug fixessources are here build process here process: mkdir mybuilddircd mybuilddircmake path/to/llvm/source/rootcmake build j cmake build target install or cmake dcmake_install_prefix=/usr p cmake_install.cmake and at least patches from the same for clang lld
200440706,8924,https://api.github.com/repos/dotnet/coreclr/issues/8924,danmosemsft,3,0,0,0,0,0,see corefx there are instances of code like this try finally finally block to protect against corruption due to a thread abort between setting next and setting tail volatile.write(ref tail._next newsegment ensure segment not published until item is fully stored tail newsegment in some cases these are heavily nested for some reason.this is a hangover from support for thread abort which coreclr does not support the coreclr jit therefore should elide the try and finally if the jit is used on runtimes that do support thread abort i guess it shouldnt do it there worth checking with jkotas andyayersms
200439234,8923,https://api.github.com/repos/dotnet/coreclr/issues/8923,mikedn,3,0,0,0,0,0,the jit cant eliminate range checks if it cant see length and uses loop cloning which generates a lot of code even in cases where not all range checks can be eliminated and loop cloning is used anyway its still preferable to have fewer range checks.for example sortexceptions is bytes shorter after this change despite the fact that loop cloning is still being used
200237904,8906,https://api.github.com/repos/dotnet/coreclr/issues/8906,sivarv,1,0,0,0,0,0,here is the prolog of next_term method from pi-digits benchmark: inb push rinc push rind push rine push rinf push rdiina push rsiina a push rbpina b push rbxina c sub rsp ina mov rsi rcxina lea rdi rsp+h ina b mov ecx ina xor rax raxina rep stosd the below two are unecessary movesina mov rcx rsiinaa mov rsi rcxinab a mov edi edx these unnecessary moves materialize in prolog whenever zero-init of the frame needs to use block-init rep stosd in this case rcx is preserved by moving to rsi and later restored later lsra could set entry point conditions of the first basic block to have rcx param moved to rsi.such unnecessary moves are present in the following methods of pi-digits benchmark:calculatenext_termeliminate_digitextract_digitthis issue is present on all ryujit targets.category:cqtheme:register-allocatorskill-level:expertcost:medium
199930028,8879,https://api.github.com/repos/dotnet/coreclr/issues/8879,russellhadley,0,0,0,0,0,1,implements two field span struct which is comprised of a byref fieldthat may be an interior pointer to a managed object or a nativepointer indicating the start of the span and a length field whichdescribes the span of access.since there is no msil operation which assign a byref field the jitgets involved and treats the constructor and getter of a special structcalled byreference that contains an declared intptr this specialstruct is then used as a field in the span implementation and recognizedby the runtime as a field that may contain a gc pointer inimplementation the ctor of byreference is converted into an assignmentof the byref passed as the arguemnt and the getter of the byreferencevalue is returned by a reverse assignment.since there are some dependencies on corefx for the span implementationlocal testing of the implementation has been done using thebasicspantest.cs in the coreclr tests once this is checked in and ispropagated to corefx the apporopate code in the packages will be enabledand then may be referenced in coreclr tests at that time more spantests will be added
199896688,8876,https://api.github.com/repos/dotnet/coreclr/issues/8876,pgavlin,1,0,0,0,0,0,if only the live-out set for a block changes during live variableanalysis the lva algorithm does not need to be re-run as per thedataflow equations for lva liveout(block union(livein(s for all s in successors(block))thus unless a change to the live-out set for a block propagates throughto a change to the live-in set for that block it will not affect thelive-in/out sets of any of its predecessors and liveness need not bere-run
199889273,8874,https://api.github.com/repos/dotnet/coreclr/issues/8874,adiaaida,0,0,0,1,0,0,currently only checked runs can be triggered for x this adds a triggerfor release runs as well
199722322,8868,https://api.github.com/repos/dotnet/coreclr/issues/8868,stephentoub,1,0,0,0,0,0,the most common uses of createlinkedtokensource involve passing in one or two tokens but even for these cases we end up allocating an array of registrations this commit fixes that.cc kouvel
199716551,8867,https://api.github.com/repos/dotnet/coreclr/issues/8867,AndyAyersMS,1,0,0,0,0,0,add a variant that uses a class and out parameter instead of returninga struct by value this variant is similar to version from the benchmarksgames site but with validation added and parallelism removed.see related analysis in according to xunit-perf runs this versionsperformance is improved by enabling the model inlining policy whenthe model policy is enabled the inliner will inline the two outermost callsto childtreenodes in the innermlost loop.also make sure the new and the original version to build the same way inrelease and debug
199649144,8857,https://api.github.com/repos/dotnet/coreclr/issues/8857,danmosemsft,0,0,0,1,0,0,we do not need to retain the ability for coreclrs corelib to build for desktop it has probably rotted anyway.diffing the defines i see in src\mscorlib with the defines i see going to the compiler code marked with these defines seems eligible for removal either the code or the define from code x feature_advanced_managed_etw_channels x feature_case_sensitive_filesystem x feature_codepages_file x feature_cominterop_managed_activation x feature_cominterop_winrt_desktop_host x feature_compressedstack x feature_crypto x feature_leak_culture_info x feature_legacysurface x feature_link_demand x feature_method_rental x feature_norm_idna_only x feature_pls x feature_rwlock x feature_serialization x feature_unsafe_contracts x feature_x x feature_x_securestringsthis is just the feature ones perhaps some others here are the files: alldiffsincode.txt specific build functionality including x can presumably go also.care to not trample on concurrent work by jamesqo although many of these will be in code hes not removing also a delete of some code in a file ought to merge fine with a delete of the file itself.@jkotas is the above correct
199589988,8853,https://api.github.com/repos/dotnet/coreclr/issues/8853,mikedn,1,0,0,0,0,0,it seems to me that this option should be enabled by default in a new framework such as net core the only reason i can think of why one might want to disable this option is poorly written unsafe code that assumes that objects cant be larger than gb and thus offsets can be represented using int any compat concerns?fixes
199427602,8846,https://api.github.com/repos/dotnet/coreclr/issues/8846,stephentoub,1,0,0,0,0,0,the lazy-initialization code of task.completedtask is causing it to be an unprofitable inline for workloads that make heavy use of task-returning methods that complete synchronously this is showing up as a measurable impact e.g in a simple benchmark reading and writing to the channels in the channels lib on corefxlabs its resulting in overhead however as its used by a bunch of core net types e.g a bunch of streams like filestream and memorystream its rare that it wont be needed and its often needed very early in a programs execution this commit just removes the lazy-initialization removing a branch and allowing the getter to be inlined.cc jkotas andyayersms
199293791,8837,https://api.github.com/repos/dotnet/coreclr/issues/8837,sivarv,3,0,0,0,0,0,consider the following methods and call chain from binarytrees benchmark internal static treenode bottomuptree int item int depth treenode t childtreenodes(out t item depth return t static void childtreenodes out treenode node int item int depth node new treenode(item if depth childtreenodes(out node.left item depth childtreenodes(out node.right item depth internal int itemcheck if right null return item else return item left.itemcheck right.itemcheck main bottomuptree childtreenodes() legacy inlining policy inlines bottomuptree in main but considers not profitable to in-line childtreenodes as a result main methods ends up with an addr exposed local which is updated by childtreenode using a writebarrier since it cannot reason about its out-param further the addr-exposed local is pointing to the root of the binary tree if the main method is such that it calls bottomuptree many times it will end up with that many addr-exposed untracked gc-ref locals on stack that is unused objects get held up and will not be freed while executing within main as a result of which gc would have to do more work which in turn impacts execution perf this precisely happens with binarytrees benchmark.with model in-lining policy it so happens that even childtreenodes gets in-lined when called inside a doubly nested loop and benchmark gets the benefit eliminating untracked local and unnecessary write-barrier the observation here is it seems beneficial to factor in eliminating an addr-exposed obj-ref local at a call site to determine whether it is profitable to in-line a call at a particular call site category:cqtheme:inliningskill-level:expertcost:medium
199027918,8821,https://api.github.com/repos/dotnet/coreclr/issues/8821,mikedn,2,0,0,0,0,0,array indices are signed according to the ecma spec but theyre subject to bound checks that reject negative values so we can treat them as unsigned when widening to pointer size.the advantage is that we end up using a mov instruction instead of a movsx instruction the former sometimes has smaller encoding and it is supposed to have latency on recent intel cpus
199022239,8820,https://api.github.com/repos/dotnet/coreclr/issues/8820,pgavlin,1,0,0,0,0,0,this field was never used
199020005,8819,https://api.github.com/repos/dotnet/coreclr/issues/8819,benaadams,3,0,0,0,0,0,investigation of dispatch costs are states for an interface callsite attached methods unresolved lookup stub attached method monomorphic dispatch stub n attached methods megamorphic resolve stub for a monomorphic interface call it always goes via a stub to do dispatch which is roughly the same cost as chained non-inlined direct calls method mean stddev scaled rps interfacemonomorphic ns ns interfacepolymorphicx ns ns interfacemegamorphicx ns ns interfaceunsafecastconsttest ns ns interfaceunsafecastvartest ns ns directviacastindirected ns ns directviacastnotinlined ns ns directviacastinlined ns ns which is in line with the botr virtual stub dispatch where the call site calls stub which calls method! figure resolved type monomorphic it looks roughly like this excuse the pseudo-code) cppfunction callinterface virtualstub dispatch callsite_dispatch dispatch.invoke(obj.methodtable);}class dispatchstub virtualstub type expectedmt pcode impltarget pcode failtarget invoke(methodtable methodtable if expectedmt methodtable this->impltarget else this->failtarget however if the lookupstub and resolvestubs returned as mt then the dispatchstub could be turned into a regular poco and the call inlined? cppfunction callinterface var dispatch callsite_dispatch var expectedmt dispatch->expectedmt if expectedmt expectedmt obj.methodtable dispatch->impltarget else dispatch->failtarget class dispatchstub virtualstub type expectedmt pcode impltarget pcode failtarget;}class lookupstub virtualstub type expectedmt pcode impltarget invoke pcode failtarget class resolvestub virtualstub type expectedmt pcode impltarget invoke pcode failtarget comparable examples inline caches in smalltalk java javascript questionwould there be any benefit to this change
198812636,8806,https://api.github.com/repos/dotnet/coreclr/issues/8806,sandreenko,1,0,0,0,0,0,change childs order in gentreeboundschk.index tree has to be executed before arrlength.it is possible to change only execution order but this variant is more obvious.fix
198330371,8772,https://api.github.com/repos/dotnet/coreclr/issues/8772,ciplogic,1,0,0,0,0,0,ryujit could handle it more seriously the sealed contract and devirtualize and inline more aggresively. issue in roslyn repository
198206363,8758,https://api.github.com/repos/dotnet/coreclr/issues/8758,lilith,10,0,0,0,0,5,we were very close to achieving loose coupling in net via assembly neutral interfaces then victory was snatched from our grasp with its removal in i know this would also need to be added to net full but it is a very worthwhile feature diamond dependencies are a problem mxn adapter proliferation is madness and this is a pain point even for basic tasks this small thing would represent a significant reduction in pain/friction for oss authors seeking interoperability with other packages were tired we want our time and keystrokes to go farther and preferably while remaining on nettrue structural typing has been suggested for c but it looks like this is unlikely to get any attention foreach getenumerator alone gets this special ability ani consumption was supported by all clr languages.if the nuget ecosystem is never able to expand past the interfaces in system how will we ever start making progress on library compatibility?adding dependencies just for interface assemblies does not happen particularly if interoperability is not absolutely crucial its not worth the risk and cost id like to reiterate the comments when the supporting lines of code for ani were pulled boooooooo chrismckee*why adamralph yeah whats with this jetskinooo markrendleand kindly request that this feature be reconsidered for inclusion in both versions of net
198167523,8755,https://api.github.com/repos/dotnet/coreclr/issues/8755,JosephTremoulet,1,0,0,0,0,0,parameter newvnsforphis of method fgvaluenumberbasicblocks is unused;its presence and comment are confusing/misleading what actually happensis that fgvaluenumberblock itself checks whether the value numbers forincoming phi args ssa defs are defined yet or not
197450635,8719,https://api.github.com/repos/dotnet/coreclr/issues/8719,jkotas,1,0,0,0,0,0,replace special unmanaged memory pool used by pathhelper by shared arraypool custom memory pools are not good for global system performance and the particular implementation of the unmanaged memory pool was also problematic for corert port because of its dependencies
196779789,8694,https://api.github.com/repos/dotnet/coreclr/issues/8694,MarkPflug,1,0,0,0,0,0,"im reporting this issue with the expectation that it cannot be fixed but id like someone to consider it anyway.the exception.stacktrace property is virtual so it appears that a derived exception can provide a custom stack trace implementation we would like to do this in our application when we get an exception out of a script engine which would otherwise provide no stack info for the script code the problem is that even though the stacktrace property is virtual it isnt very useful to override because the base exception.tostring method doesnt use the stacktrace virtual property but instead calls the private getstacktrace method which is what stacktrace calls internally we can override tostring which is also virtual however the base tostring method also doesnt call the virtual tostring on the inner exception but calls the private tostring(bool,bool method so that doesnt work either if the base tostring method would call either the virtual stacktrace or the virtual tostring on the inner exception it would be a lot more useful to provide overrides.as i said i suspect this cannot be improved for fear of breaking existing code but it seems like a bizarre design to have these virtual methods that the base implementation doesnt consume"
196435259,8680,https://api.github.com/repos/dotnet/coreclr/issues/8680,mskvortsov,1,0,0,0,0,0,"this patch is a tribute to the issue and is mostly a copy of the arm code.a simple helloworld as well as a number of jit/codegenbringuptests tests compile and run successfully complus_jitdisasm=main complus_altjit=main coreclr-debug/corerun windows_nt.x.release/jit/codegenbringuptests/add/add.exe assembly listing for method bringuptest:main():int emitting blended_code for generic arm cpu optimized code sp based frame partially interruptible final local variable assignments v loc v,t int r v outargs v lclblk sp+x lcl frame size g_m_ig b push r,lr}g_m_ig movs r f movw r x fcb movt r xbc blx r bringuptest:add(int):inte cmp r d bne short g_m_ig movs r g_m_ig bd pop r,pc}g_m_ig ff ff mov r g_m_ig:a bd pop r,pc total bytes of code prolog size for method bringuptest:main():int echo"
196289917,8677,https://api.github.com/repos/dotnet/coreclr/issues/8677,xoofx,17,0,0,0,0,3,this is a followup of the issue work done by rohansi and the original issue this is pr is not mergeable as it is it is a single commit for now to simplify the tracking of things that are changed i will recommit everything once i have cleanup some bits here and there the changes are very rough now i havent followed also using the define feature_collectible_alc ...etc.)the difference with is that a single assemblyloaderallocator is now associated to the assemblyloadcontext without changing much this class i have added the ability to add a domainassembly instead of the previous setdomainassembly method to chain it to another domain assembly that is in the same alc via the member domainassembly::m_nextdomainassemblyinsamealc it allows to use the original code for single collectible assembly.also the assemblyloadcontext creates a weak handle on itself instead of a strong handle otherwise it cannot self finalize the destroy of this context doesnt actually delete the native alc but instead release a strong handle to the loaderallocator managed object associated to the assemblyloaderallocator then the finalizer of the loaderallocator via the loaderallocatorscout will be called and there we will cleanup everything including releasing the native assemblyloadcontext .a simple test with an assembly loaded in loop seems to indicate that the memory is stable and nothing so far is crashing but i expect many problems in many places so this is really an early poc.i originally didnt use the pr and tried to perform the changes on my side but i had to cherry pick some parts of the previous pr while encountering the same issues one thing im really not happy currently is the code in the loaderallocator::gcloaderallocators_removeassemblies i had to fight with issues with part of the code gc_notrigger and others incompatible gc_triggers ...etc one thing i dont like is to have multiple methods to remove all the internal caches associated to a domainassembly in the appdomain this code should be part of appdomain instead there is also some issues with some maps that are using some assemblyspec that were problematic because they were doing some gc_triggers and the original gcloaderallocators_removeassemblies was gc_notrigger so yeah this part has to be heavily rewrite/cleanup somehow.comments are welcome sorry if it is a bit of a mess!)cc jkotas gkhanna rahku
196048407,8660,https://api.github.com/repos/dotnet/coreclr/issues/8660,agoretsky,0,0,0,0,0,1,hi there!after upgrading our project to net core we have faced with memory leak problem on linux i cant reproduce it on windows so i cant profile it i found code which causes this problem and published it here reproduce you will need provide p certificate file path and password in main method.steps to reproduce problem take this repository provide path to p certificate file path and password in program.cs main method run it on linux see consumed memory using top i see about mb change microsoft.netcore.app to and netcoreapp to netcoreapp in project.json run it on linux again see consumed memory using top i see about gb
195466875,8634,https://api.github.com/repos/dotnet/coreclr/issues/8634,xoofx,3,0,0,0,0,0,"hi,this is a general question about ryujit and the current careful maintained balance between throughput and generated code efficiency.in the case of corert when using ryujit as a backend where the jit throughput is bit less important still but it makes sense to unleash the compiler and let it optimize as much as it can...im not sure that there is today an aot mode for ryujit but suppose that we could introduce such mode im wondering what are the top optimizations/improvements that could be part of this mode?category:proposaltheme:optimizationskill-level:expertcost:extra-large"
195439437,8629,https://api.github.com/repos/dotnet/coreclr/issues/8629,parjong,0,0,1,0,0,0,this is the first step to resolve
194972075,8596,https://api.github.com/repos/dotnet/coreclr/issues/8596,janvorli,1,0,0,0,0,0,currently we dont handle non-trivial cases of tail calls on unix due to the non-portable andcomplex way it is implemented this pull request describes a design of a portable way ofhandling these cases so that it can be used uniformly over all our jitted and aot ahead of time)platforms
194916403,8592,https://api.github.com/repos/dotnet/coreclr/issues/8592,sjsinju,1,0,0,0,0,0,i found that secure delegate stubs are compiled every time during application execution which has a negative impact on execution performance like the getmulticastinvoke method getsecureinvoke checks the hashtable when the method is executed and uses it if it already exists
194883926,8586,https://api.github.com/repos/dotnet/coreclr/issues/8586,Artoria2e5,2,0,0,0,0,0,while werror is a great thing for engineering and especially for ci testing it gives users unnecessary problems as compilers may add new warnings in new releases therefore putting werror in a non-development versions for users to compile is usually a short-sighted move.from what i can see now coreclrs werror is especially troublesome for cutting edge distros like arch linux it has also broken on fresh os x releases as well as with new library versions that deprecate old methods although these information can be helpful for coreclr developers in finding potential problems it must be recognized that users should be given a easy way to just make it compile instead of having a package randomly break due to non-critical outside changes.(by easy disabling i am referring to some flags to append not just sed it away.)list of werror spots
194742989,8579,https://api.github.com/repos/dotnet/coreclr/issues/8579,benaadams,1,0,0,0,0,0,"currently string.equals currently never inlines string.equals(string value stringcomparison comparisontype never inlines they both then call other non-inlining methods failed noinline per il/cached result string:equals(ref):bool:this failed noinline per il/cached result string:equals(ref,int):bool:this this change allows the forms of string.equals to inline for reference equality and length differences and call the final non-inlining method directly e.g equalshelper compareordinalignorecasehelper cultureinfo.xxxculture.compareinfo.compare )as the comparisontype is generally a constant e.g stringcomparison.ordinalignorecase the inlining also means the jit branch eliminates all the other references to the other comparison types.so for example a call to csharpvalue.equals(value stringcomparison.invariantcultureignorecase) only pulls in the invariant culture ignore case branch il tr a below always_inline size string:equals(ref,int):bool:this il tr aa aggressive inline attribute string:equalshelpercomparison(ref,ref,int):bool il tr ad aggressive inline attribute string:equalsculture(ref,ref,int):bool il tr ae aggressive inline attribute string:notpossiblyequals(ref,ref):bool il tr ac below always_inline size cultureinfo:get_invariantculture():ref il tr a failed target not direct compareinfo:compare(ref,ref,int):int:this il tr ad failed target not direct cultureinfo:get_compareinfo():ref:this a call to csharpvalue.equals(value stringcomparison.ordinalignorecase) only pulls in the ordinal ignore case branch il tr a below always_inline size string:equals(ref,int):bool:this il tr aa aggressive inline attribute string:equalshelpercomparison(ref,ref,int):bool il tr ac aggressive inline attribute string:equalsordinalignorecase(ref,ref):bool il tr ae aggressive inline attribute string:notpossiblyequals(ref,ref):bool il tr failed cannot get method info string:isascii():bool:this il tr failed noinline per il/cached result string:isascii():bool:this il tr d failed too many il bytes string:compareordinalignorecasehelper(ref,ref):int il tr d profitable inline textinfo:compareordinalignorecase(ref,ref):int textinfo:compareordinalignorecase inline is a simple unwrap to internalcomparestringordinalignorecase ordinal string:equals is unwrapped down to the non-inlining string:equalshelper il tr a below always_inline size string:equals(ref):bool:this il tr bd failed does not return throwhelper:thrownullreferenceexception il tr ab aggressive inline attribute string:equalsordinalcasesensitive(ref,ref):bool il tr ae aggressive inline attribute string:notpossiblyequals(ref,ref):bool il tr failed noinline per il/cached result string:equalshelper(ref,ref):bool etc"
194652743,8566,https://api.github.com/repos/dotnet/coreclr/issues/8566,JohnChen0,1,0,0,0,0,0,fixes issue
194644183,8565,https://api.github.com/repos/dotnet/coreclr/issues/8565,nicolasr75,4,0,0,0,0,0,is there any way to detect whether a user or the system closes a console application i support ctrl-c for closing by a user but since the system provides the ability to simply close the console window i can not clean up my application which is important since it performs regular tasks that should be terminated cleanly the same goes for system shutdown.i tried system.runtime.loader.assemblyloadcontext.default.unloading but that does not fire when the window is closed
194525853,8555,https://api.github.com/repos/dotnet/coreclr/issues/8555,JeremyKuhne,0,0,0,2,0,0,strips out the securitysafecritical and securitycritical attributes and the rest of the feature_coreclr defines.the first commit is the removal for the attributes and the empty feature_coreclr defines those that could be matched via simple regex.)the second commit is the rest of the feature_coreclr blocks.im in the process of cleaning up the io code from here notably removing the dead security code which is still allocating and doing unneeded checks
194503482,8551,https://api.github.com/repos/dotnet/coreclr/issues/8551,AndyAyersMS,0,0,0,3,0,0,preliminary implementation of empty finally removal and finally cloning passing local tests for both x and x so figured id run it through ci to see what else might crop up.still a few important todos and potentially a lot of code cleanup left so setting no merge
194478847,8545,https://api.github.com/repos/dotnet/coreclr/issues/8545,JeremyKuhne,1,0,0,0,0,0,removes the rest offeature_cas_policyfeature_remotingfeature_macland another significant chunk of!feature_coreclr
194470093,8542,https://api.github.com/repos/dotnet/coreclr/issues/8542,AndyAyersMS,5,0,0,0,0,0,in some cases small fixed-sized stackalloc s could be turned into regular local vars which if this transformation could be anticipated would unblock inlining see related discussion in benaadams feel free to add pointers to examples youve found
194273037,8524,https://api.github.com/repos/dotnet/coreclr/issues/8524,hqueue,1,0,0,0,0,0,in lowerxarch.cpp local variable srcuns is defined but not usedat lowering::lowercast(gentree tree
194229407,8513,https://api.github.com/repos/dotnet/coreclr/issues/8513,justinvp,1,0,0,0,0,0,avoid the intermediate toupper string allocation
194226471,8512,https://api.github.com/repos/dotnet/coreclr/issues/8512,justinvp,1,0,0,0,0,0,use comparison
193965586,8497,https://api.github.com/repos/dotnet/coreclr/issues/8497,jkotas,1,0,0,0,0,0,introduce internal byreference
193961698,8496,https://api.github.com/repos/dotnet/coreclr/issues/8496,YongseopKim,4,0,0,2,0,0,we yongseopkim chunseoklee hseok-oh hqueue are going to work for enabling ryujit backend for arm.any information that we should know like that somebodies are working some feature of ryujit on arm
193902150,8481,https://api.github.com/repos/dotnet/coreclr/issues/8481,mikedn,2,0,0,0,0,0,in my experience sorting an array or list of objects using something like sort((x y x.age.compareto(y.age is quite common these days building a custom comparer object is usually a waste of time and as well see it is also less efficient than using comparison .but arraysorthelper is based on icomparer.create((x y x.age.compareto(y.age comparison.default.sort(array array.length pc arraysorthelper.default.sort(array array.length dc arraysorthelperdelegate.default.sort(array array.length dpc arraysorthelperdelegate.default.sort(array array.length ddc console.writeline(sw.elapsedticks);} version ticks compare overhead---|---|---arraysorthelper comparer interface callarraysorthelper comparison interface call delegate callarraysorthelperdelegate comparer delegate callarraysorthelperdelegate comparison delegate call arrayshorthelperdelegate is a version of the original arraysorthelper that uses comparison .notice that when arrayshorthelperdelegate is used it makes no difference if a comparer or a comparison is used thats because the cost of interface lookup is paid only once at delegate creation time.now its easy to add arraysorthelperdelegate and route the existing sort(comparison
193893528,8480,https://api.github.com/repos/dotnet/coreclr/issues/8480,janvorli,1,0,0,0,0,0,when grsec/pax has randmmap enabled it never honors the address passed to mmap unless the map_fixed option is passed in but there are two parts of coreclr that rely on the fact that mmap honors the address unless there is an overlapping mapping first part is the executable allocator in pal that tries to reserve memory range in close vicinity of the libcoreclr.so within gb range to make sure that jitted managed code that calls into libcoreclr.so doesnt have to use jump stubs.the second part is the jump stub allocator if code in one jitted module calls code in another one and the distance of the jump is larger than gb jitter tries to allocate jump stub within gb range from the caller address.both of these mechanisms fail on grsec/pax enabled linux since we cannot control the address where we create mappings the result is either coreclr_initialize failure with hr x or an out of memory exception since the mapping address picked by the kernel is random sometimes after many attempts we can actually start and run fine if by a chance the mapping picked by the kernel matches the requested one.there is a workaround for this disabling the randmmap for dotnet corerun or the renamed coreconsole executables using the paxctl c r command but it would be great to make it work possibly with lower performance even without this workaround
193467890,8457,https://api.github.com/repos/dotnet/coreclr/issues/8457,georgehara,4,0,0,0,2,0,"hi,according to github.com/dotnet/coreclr/issues a bug in net causes a slow down of certain operations the item is marked as fixed.however after investigating some other code i have found that either the issue is not fixed in production or i have found a similar bug.specifically i have created the attached solution to reproduce the problem this is consistent on computers a laptop and desktops all with intel processors an i an i with vs update update and vs rc the project targets net but is installed on all computers.the results after running the attached solution is as follows after two runs for each combination with prefer bit is off uselegacyjit is not in config the speed is mb/s s with prefer bit is off uselegacyjit is the speed is mb/s s with prefer bit is on uselegacyjit is not in config the speed is mb/s s yes there is an astonishing times increase with prefer bit is on uselegacyjit is the speed is mb/s s).in the production code combination is consistently faster than combination with about mb s but thats clearly irrelevant.oh and one really bizarre thing is that for combination if some private readonly table variables are also declared static the speed is mb/s s so its worse for the other combinations the performance is very slightly better like mb s more).my problem is that i cant compile the production code with prefer bit on because i have some other code thats optimized to run on bit code which slows down in a similar way so there are conflicting needs.to put things in perspective the code that needs to run on bit is rijndael from which the test presented here was extracted and the code that needs to run on bit is sha regards,george speedtest.zip"
192343463,8352,https://api.github.com/repos/dotnet/coreclr/issues/8352,danrozenberg,1,0,0,0,0,0,i have posted this question on stack overflow but perhaps on github it would be more appropriate i dont know if this is the best dotnet repo to post this though so apologies in case i am wrong here is my original post:i am trying to figure out what i could be doing wrong in this sample project i am getting an error when my net application references a netstandard library the application has a dependency on system.collections.immutable which targets netstandard according to nuget the library depends on netstandard.library am i setting up either of these projects wrong i would greatly appreciate any insight on this...here are their project.json app buildoptions emitentrypoint true dependencies somelibrary frameworks net dependencies system.collections.immutable version library buildoptions allowunsafe true dependencies frameworks netstandard dependencies netstandard.library version all the library has is this interface using system.collections.generic namespace somelibrary public interface someinterface int getvalue(keyvaluepair(key console.writeline(answer class concreteimplementation someinterface public int getvalue(keyvaluepair
192084436,8323,https://api.github.com/repos/dotnet/coreclr/issues/8323,svick,1,0,0,0,0,0,when i open system.private.corelib.sln in vsrc system.private.corelib.csproj fails to load with the following error error the required attribute remove is empty or missing from the element internal_resgendefines generatesplitstringresources.targetsremoving the offending elements does let me load and build the project successfully but i dont know if it breaks something else).the project also works fine unmodified in vs so i dont know if this is an issue in coreclr or in vs
192058688,8322,https://api.github.com/repos/dotnet/coreclr/issues/8322,RussKeldorph,1,0,0,0,0,0,as of aaddcdcbbecfa ryujit is now the default x jit replacing the legacy_backend jit built from these sources and jit which shows up in the official x packages from microsoft for now setting complus_usewindowsxcorelegacyjit in the environment will make coreclr load the older jit legacy_backend or jit instead.update relevant documentation in this repo to indicate the above
191484927,8302,https://api.github.com/repos/dotnet/coreclr/issues/8302,davidfowl,40,0,0,0,0,6,im running into a problem: unhandled exception system.io.fileloadexception could not load file or assembly system.runtime.compilerservices.unsafe version culture=neutral publickeytoken=bfffdaa the located assemblys manifest definition does not match the assembly reference exception from hresult x) it would be great if this exception could tell me what version of system.runtime.compilerservices.unsafe was referenced what assembly referencing system.runtime.compilerservices.unsafe triggered the load what the version of the reference to system.runtime.compilerservices.unsafe is that is causing the mismatch. bonus points where the assembly was loaded on disk if it is on disk though i can get this from the modules window in vs).that would save me so much time..../cc gkhanna
191405917,8291,https://api.github.com/repos/dotnet/coreclr/issues/8291,sivarv,2,0,0,0,0,0,right now ryujit supports sse and avx instruction set for simd codegen sse/ssse/sse./sse instruction sets gets used only if the machine supports avx these code changes are meant to take advantage of sse instruction set on a target that doesnt support avx but supports sse_.summary points:complus_enablesse setting is added to disable use of sse by setting complus_enablesse and complus_enableavx we can test sse based simd codegen i will be filing a git work item to add such a test leg in oss ci.code changes are mostly in simd.cpp/lowerxarch.cpp/simdcodegenxarch.cpp/emitxarch.cpp right now sse instructions are leveraged for dot product horizontal add packed multiply of bit uint ptest packed compare of long vectors and insertps.asm diffs:superpmi asm diffs show a k code size improvement across all sse spmi collection baseline diff improvement improvement funcstotal kestrel and ravendb would benefit from sse support
191388917,8289,https://api.github.com/repos/dotnet/coreclr/issues/8289,CarolEidt,1,0,0,0,0,0,a number of issues remain in the handling of promoted struct arguments gt_field_list after pr we currently push the fields in reverse order which is what we want to do for pointer-sized fields however for smaller fields we should keep them in the list order so that we can push the first field in the slot as bits and then store the remaining fields we dont require the byte fields to be in byteable registers but it would be nice if we could preference them that way the current mechanism for indicating preferences relates mostly to preferencing to another lclvar or tree node if we have sub-pointer-sized fields we always allocate an internal register even though we may not need it one strategy if any of the sub-pointer-sized fields are either tree temps or last-use lclvars for the first such field require a register i.e dont make it regoptional this register can then be also used as a temporary register to load up the remaining sub-pointer-sized fields for the first byte field make it require a register this may be the same as above or in addition to one could fine-tune this but its probably not really worth it if we need to adjust the stack for padding or holes in the struct we currently use a series of pushes of we should consider whether it would be better to generate a sub in some or all cases and/or we should use push eax has the legacy jit does my concern with the latter was that i wasnt sure how careful we need to be about what eax might contain if its padding it isnt guaranteed to be zero but not sure if its safe to just push any arbitrary value).category:cqtheme:structsskill-level:expertcost:medium
191285698,8279,https://api.github.com/repos/dotnet/coreclr/issues/8279,sahithreddyk,3,0,0,0,0,0,hello copied locally downloaded vsts-agent-rhel..-x-...tar.gz to the linux and extracted the contents executed mkdir myagent cd myagent~/myagent tar xzf downloads/vsts-agent-rhel..-x-...tar.gz while running config.sh getting below error and i dint downloaded libunwind.x failed to load bin/libcoreclr.so error libunwind.so cannot open shared object file no such file or directoryfailed to bind to coreclr at bin/libcoreclr.socan someone please advise me pleasethanks in advance
191172398,8263,https://api.github.com/repos/dotnet/coreclr/issues/8263,AndyAyersMS,5,0,0,0,0,0,"an inline pinvoke is a pinvoke where the managed/native transitionoverhead is reduced by inlining parts of the transition bookkeepingaround the call site a normal pinvoke does this bookkeeping ina stub method that interposes between the managed caller and thenative callee.previously the jit would not allow pinvoke calls that came from inlinesto be optimized via inline pinvoke this sometimes caused performancesurprises for users who wrap dll imports with managed methods see forinstance inline pinvokes were also disallowed for x for pinvoke calls in tryregions this was a holdover from earlier runtimes more generalruntime support was eventually added but the jit continued to followolder restrictions.this change lifts both of those limitations pinvokes from inlinedmethod bodies are now given the same treatment as pinvokes in theroot method and pinvokes in try regions can be optimzied via inlinepinvoke the legality check for inline pinvokes has been streamlinedslightly to remove a redundant check inline pinvokes introducedby inlining are handled by accumulating the unmanaged method countwith the value from inlinees and deferring insertion of the specialbasic blocks until after inlining so that if the only inline pinvokescome from inline instances they are still properly processed.inline pinvokes are still disallowed in filter and handler regions(catches and finallies).inline pinvokes are also now suppressed in rarely executed blocks,for instance blocks leading up to throws or similar.this change also adds a new test case that shows the variety ofsituations that can occur with pinvoke inlining and eh.the inliner is now also changed to preferentially report inlinereasons as forced instead of always when both are applicable"
191163887,8260,https://api.github.com/repos/dotnet/coreclr/issues/8260,BruceForstall,2,0,0,3,0,0,jit becomes compatjit.dll and ryujit legacy_backend becomes legacyjit.dll(and is an altjit).if jit is not being built then ryujit legacy_backend becomes compatjit.dlland is a normal jit not an altjit).both clrjit.dll and compatjit.dll are added to the jit nuget package
190738319,8225,https://api.github.com/repos/dotnet/coreclr/issues/8225,asadsahi,3,0,0,0,0,0,i also installed vs rc and opend my project which added csproj file i deleted that asuming that project.json will still work but getting this error:aspnetcorespa.xproj error msb the imported project c:\program files\dotnet\sdk\..-preview-\extensions\microsoft\visualstudio\v.\dnx\microsoft.dnx.props was not found confirm that the path in the import declaration is correct and that the file exists on disk. csproj xproj project.json the whole story is really really confusing. any simple way to upgrade to net from
190435061,8208,https://api.github.com/repos/dotnet/coreclr/issues/8208,adiaaida,1,0,0,0,0,0,by removing hiop and loop from lir and then putting them back in weinadvertantly reversed the order of operations for high and lo this is anissue when op is a long add or sub where the order of operations isimportant.fixes
190393781,8205,https://api.github.com/repos/dotnet/coreclr/issues/8205,kvochko,0,0,0,0,0,2,this pr fixes incorrect section/thunk addresses on arm due to thumb bit being raised section addresses now have the thumb bit cleared and thunks have an offset of this resolves various sigbus errors under lldb on arm.@mikem janvorli ptalcc chunseoklee dmitri-botcharnikov ayuckhulk
190339677,8203,https://api.github.com/repos/dotnet/coreclr/issues/8203,stephentoub,1,0,0,0,0,0,arraypool currently uses a spinlock per bucket to protect each buckets state the lock covers only a small number of instructions and generally performs well however if a thread happens to be interrupted while holding the spin lock all other threads can be prevented indefinitely from making forward progress
190331654,8201,https://api.github.com/repos/dotnet/coreclr/issues/8201,redknightlois,1,0,0,0,0,0,if there such big differences into code-gen between avx and sse then ishardwareaccelerated is not enough granularity to make it viable to optimize using simd we need to be able to detect which of the code-gen paths are being used in order to take appropriate action per comment by sivarv at enum instructionsettype sse avx}public static class vector jitintrinsic public static bool issupported instructionsettype instructionset return instructionset instructionsettype.sse the jit should also treat issupported return as a late binded constant for the platform.cc caroleidt mellinoe category:proposaltheme:intrinsicsskill-level:intermediatecost:medium
190265446,8199,https://api.github.com/repos/dotnet/coreclr/issues/8199,Maoni0,0,0,0,1,0,0,this is the first step in separating the diagnostics code out from gc.cpp except gcs own diagnostics for the local gc project the goal for this commit is to not have code that requires intimate knowledge about diagnostics stuff eg profiling etw stress log perf counters in gc.cpp some of the diagnostics stuff exists in gcee.cpp today so they will need to be refactored out later.the rule is gc will call the diagnostics functions at various points to communicateinfo and these diagnostics functions might call back into the gc if they requireinitimate knowledge of the gc in order to get certain info this way gc.cpp doesnot need to know about details of the diagnostics components eg the profiling context;and the diagnostics components do not need to know details about the gc.still wip i havent taken care of the gcsample part for example but wanted to get some early feedback profiling and what profiling and etw shared were the most problematic part so thats what i separated out i stopped at the rest of the etw part as they are just firing events in a straightforward way the plan was to keep gc etw events on the gc side so its probably not worthwhile to have a wrapper that just calls the fireetw functions in another file i am open to suggestions.stress log is similar to etw we just have some simple stress log messages sprinkled in gc.cpp perf counter stuff is all in gcee.cpp right now
190200209,8188,https://api.github.com/repos/dotnet/coreclr/issues/8188,seanshpark,4,0,0,0,0,1,i would like to enable coreclr for bit x linux based on the base with current windows x codes.im thinking this task to be in two stages first is to fix all build errors and then to make it work properly with unit tests task items to do will be added to below lists i hope compile will be done in both bit host native and bit host cross building.fix build error x fix and add for x cmake configuration x q compile directive for x/linux x fix compilation in pal x fix redefined dispatcher_context compile error x q x/linux stdcall calling convention ignored on variadic function x fix compile error redifinition runtime_function x fix stdcall calling convention ignored on variadic function x fix unsupported architecture in seh-unwind.cpp x fix no matching function for call to internalcreatethread x fix compile error with exception handling x fix seh try is not supported on this target x fix unknown type name ptr_runtime_function x fix comparison of two values with different enumeration types x fix unknown type name exinfo x fix constructor missing in unmanagedtomanagedframe x supports to build pal tests under x/linux x fix compile error in zapcode x fix compile error in codeman x fix error variable td is uninitialized x enable field endaddress only for amd in pal of runtime_function x renames i as amd in arch pal parjong x add missing files in x/linux pal parjong x fix stdcall here was previously declared without x q x/linux shift count width of type error x fix cannot initialize a variable of type clrflsgetblock x fix ignored attribute warning for x/linux build parjong x disable feature_avx_support parjong x fix the mistmatch between gc_thread_stub and gcthreadfunction parjong x add virtual dtor for arraystubcache class parjong x emit compile error on porting issue when portability_check is set parjong x revise realcodeheader and codeheader parjong x disable feature_avx_support parjong x fix the mismatch over lpoverlapped_completion_routine parjong x fix mismatch between sortversioning.h and sortversioning.cpp parjong x uses portable rotate_left for x/linux parjong x fix inconsistency between the declarations of getappdomain parjong x fix mismatch between longfilepathwrappers.cpp and longfilepathwrappers.h parjong x disable windows-specific code for x/linux parjong x declares getcallersp for winexception not for target_x parjong x disable ehwatsonbuckettracker for non-windows platforms parjong x disables framehandlerexrecordwithbarrier for non-windows platforms parjong x disable winexecption and fix related changes x fix dacp structure size mismatch x declare ctorftntype only when it is used parjong x disable printsehchain for non-windows platforms parjong x disable checkstackbarrier for non-windows platforms parjong x revises exception handling macros for x/linux parjong x disable leavecatch for non-windows platforms parjong x do not invoke verifyvalidtransitionfrommanagedcode for non windows parjong x updates m_lastredirectip and m_spincount only for non-unix platforms parjong x push framehandlerexrecord when feature_pal is not defined parjong x fix extraneous parentheses x fix cannot jump from this goto statement to its label x adjust the definition of fnstaticbasehelper for x parjong x fix error within x uses hcimpl in the impl of jit helpers parjong x exclude jithelp.asm for x/linux parjong x fix mismatch between signature and implementation of activationfunctions parjong x fix prototype for gcthreadstub x add parentheses aroung logical operations parjong x port exception_registration_record parjong x re-enable framehandlerexrecord for x/linux parjong x disable watson-related code for non-windows platforms parjong x re-enable umthkcallframe and fix compile errors parjong x add portable popsehrecords as nyi parjong x resolve linking errors due to duplicated functions parjong x mark several windows-specific functions in excepx.cpp as nyi parjong x use unhandledexceptionhandlerunix only when winexceptions is defined parjong x fix dangling theumentryprestub reference parjong x fix several unknown pragma compile errors parjong x fix several parentheses compile warnings parjong x fix unused function warning parjong x hide winodws-specfic methods parjong x re-enable methods in stublinkercpu parjong x enclose stub-linking methods with feature_stubs_as_il parjong x fix exception handling routine parjong x revert umthkcallframe-related changes parjong x fix dangling clr_impersonateloggedonuser reference parjong x extract arraystubs_as_il code from stubs_as_il region parjong x fix dangling stublinkercpu::emitdelegateinvoke in x/linux parjong x enclose arrayopstub exceptions with feature_arraystub_as_il parjong x fix dangling doubletonumber and numbertodouble parjong x use portable floating-point arithmetic helpers parjong x use portable shift jit helpers parjong x use portable lmul jit helper parjong x fix no known conversion from void to void x fix all paths through this function will call itself x fix indirection of non-volatile null pointer will be deleted x fix dangling clrcapturecontext parjong x add a stub for throw_control_for_thread_function parjong x add dummy files and port gmsasm.asm parjong x fix inconsistency in getclrfunction definitions parjong)fix sos build error lucenticus x q what are the dbg_target_xxx used for x disable arm target support for xplat x fix datatarget::getpointersize for x x dont include utilcode.h in gcdump(x).cpp x add callback aka stdcall to function declarations x add dummy exception handler fix execution error x create the theumentryprestub asm helper x port asmhelpers.asm x port jithelp.asm x port stublinkercpu::emitsetup x add definitions in cmakelists.txt file of lldbplugin x get correct stack pointer from dt_context x port several stubs as nyi corefx initial support of x cross build dotnet/corefx add rid definition in coreclr corefx and core-setup repos add to cross targeting support in the build get product build clean get linux x packages generated enable ci support for build enable pipeline build supportonce the above is done we should be able to produce net core for linux for x ee
190132486,8181,https://api.github.com/repos/dotnet/coreclr/issues/8181,jbayardo,1,0,0,0,0,0,"we have the following snippet of code and corresponding generated assembler): asm var originaldata unsafe.read>(original i);ffdbbfec mov r,rdi ffdbbfeca add r,qword ptr rsi+h ffdbbfece movups xmm,xmmword ptr r var modifieddata unsafe.read>(modified i);ffdbbfed mov r,rdi ffdbbfed add r,qword ptr rsi+h ffdbbfed movups xmm,xmmword ptr r allzeros modifieddata vector.zero;ffdbbfedd pxor xmm,xmm ffdbbfee movaps xmm,xmm ffdbbfee pcmpeqd xmm,xmm ffdbbfee pshufd xmm,xmm,eh ffdbbfeed andps xmm,xmm ffdbbfef pshufd xmm,xmm ffdbbfef pand xmm,xmm ffdbbfef movd rd,xmm ffdbbfefe cmp rd,ffffffffh ffdbbff sete rb ffdbbff movzx rd,rb ffdbbffd and byte ptr rsi+h ,rb equalsall generates similar code for vector.equalsall(modifieddata vector.zero shouldnt the same result be achievable through xor and ptest sse or even phadd ssse also the loading could be done using movdqa / movdqu instead of movaps and avoid the floating point conversion altogether"
189857170,8148,https://api.github.com/repos/dotnet/coreclr/issues/8148,kae,1,0,0,0,0,0,repro.zip attached repro for quite strange behavioryou need to import pfx from archive to localuser/my container first.then if you set var fail true you will get system.executionengineexception when trying to create certificate from rawdata byte array.when var fail false everything is working like a charm difference is loading any certificate from pfx file).changing netcore version to will result in nonissue with any value for fail variable
189781347,8143,https://api.github.com/repos/dotnet/coreclr/issues/8143,jamesqo,1,0,0,0,0,0,relevant comment whenever gethashcode is called on an enum in a generic context it is boxed and a virtual call to object.gethashcode is made for example: csprivate int gethashcode(t obj obj?.gethashcode generates this output it would be nice if the jit could recognize when it is enums avoid making such boxes then we could safely improve valuetuple.gethashcode perf by using obj?.gethashcode instead of equalitycomparer.default.gethashcode knowing that the former version will never box
189465748,8130,https://api.github.com/repos/dotnet/coreclr/issues/8130,BruceForstall,1,0,0,0,0,0,a clean build leaves the following files in the src tree according to git status src/.nuget/microsoft.netcore.ilasm/localpkg src/.nuget/microsoft.netcore.ilasm/win/localpkg src/.nuget/microsoft.netcore.ildasm/localpkg src/.nuget/microsoft.netcore.ildasm/win/localpkg src/.nuget/microsoft.netcore.jit/localpkg src/.nuget/microsoft.netcore.jit/win/localpkg src/.nuget/microsoft.netcore.runtime.coreclr/localpkg src/.nuget/microsoft.netcore.runtime.coreclr/win/localpkg src/.nuget/microsoft.netcore.testhost/localpkg src/.nuget/microsoft.netcore.testhost/win/localpkg src/.nuget/microsoft.targetingpack.private.coreclr/localpkg/ should these either be hidden by adding to gitignore or should they be created in the bin directory for the build flavor instead?bottom-line they shouldnt appear in git status output
189201264,8119,https://api.github.com/repos/dotnet/coreclr/issues/8119,russellhadley,3,0,0,0,0,0,extend ryujit to use forward substitution to expand the impact of morph optimizations.category:cqtheme:optimizationskill-level:expertcost:extra-large
189200643,8118,https://api.github.com/repos/dotnet/coreclr/issues/8118,russellhadley,1,0,0,0,0,0,morph implements a subset of the traditional expression optimizations work is to implement the remaining optimizations can be derived via llvm or internal compilers).depends on category:cqtheme:optimizationskill-level:expertcost:extra-large
189199700,8117,https://api.github.com/repos/dotnet/coreclr/issues/8117,russellhadley,2,0,0,0,0,0,morph has had a bug tail as well as an issue with unexpected diffs due to the fact that it has expansions required for correctness intermixed with optimizations the canonical example of this is the remorphing of expressions after cse its required for correctness but the optimizations that are rerun can invalidate vns and cause diffs requiring extra work to reduce this bug tail as well as give a better handle on throughput the logic that implements the two separate concerns should be separated.category:correctnesstheme:big-betsskill-level:expertcost:extra-large
189150978,8114,https://api.github.com/repos/dotnet/coreclr/issues/8114,AlexRadch,5,0,0,0,0,0,fixed string join(string separator params object values method.calling string.join null return empty string but should
189033175,8112,https://api.github.com/repos/dotnet/coreclr/issues/8112,AlexRadch,1,0,0,0,0,0,"hello,i think for fast strings processing stringbuilder should have fast methods to append and insert other stringbuilder.now when i gather string from many parts i gather each part into separated strindbuilder for example in different threads for speed and then when i gather all parts to one stringbuilder the standard library made many copy operations to convert each stringbuilder to string and then to copy each string to stringbuilder chunks it is bad because after each part is appended to final stringbuilder it is no longer used or changed it is just collected by garbage so it would be great just append chunks from one stringbulder to other without copy them two times.so to fast append second stringbuilder to first stringbuilder it can just append chunks from second to first after that it can set copyonchange flag in common chunks of first and second stringbuilders later if copyonchange chunk should be changed very rare unusual case it should be duplicated before changing"
188960559,8106,https://api.github.com/repos/dotnet/coreclr/issues/8106,mikedn,2,0,0,0,0,0,fixes this fixes all issues mentioned in by moving magic division to lowering and fixing gt_mulhi register requirements.as mentioned in the issue doing magic division during global morph has a few problems increased ir complexity missed or partial cse and licm missed magic division in cases that depend on constant propagation and folding.it did however had one positive effect in code like a x b x most of the common division code was cseed to preserve this useful side-effect i expanded x to x x in morph there was already code to do this for arm this allows cse to remove a redundant x if any).this expansion is currently done only if we know that lower will do magic division because magic division does the expansion anyway we could do this for mod by power of but the lowering or something else will need to fold shl(shr(x into a single and like the current mod by power of does but thats stuff for another pr
188917995,8105,https://api.github.com/repos/dotnet/coreclr/issues/8105,ekolis,5,0,0,0,0,0,sorry if this is the wrong place to suggest this ive never tried to contribute to net in this way before!anyway in a project of mine i wrote a serializer that relied heavily on reflection and it was horribly slow however i was able to speed it up quite a bit by creating compiling and caching a lambda expression for each property getter and setter of each class i was serializing i was thinking something like this could be built into the clr to make reflection much faster i dont know what this does to memory usage but perhaps at least there could be a static flag to set on some class somewhere or a core library which does what i was doing in case anyone needs it
188841083,8089,https://api.github.com/repos/dotnet/coreclr/issues/8089,sivarv,3,0,0,0,0,0,scenario bing team needs to copy giga bytes of data from cosmos to bing servers receiving side uses crc of the data to verify that the data is correctly received.on targets where sse is not supported managed implementation should fall-back to a non-accelerated crc-c algorithm that intel uses.this needs to be supported both on desktop and coreclr
188802931,8085,https://api.github.com/repos/dotnet/coreclr/issues/8085,stephentoub,4,0,0,0,0,0,every call to datetime.now ends up allocating a daylighttime as it computes the offset from utcnow daylighttime is just a plain old object that stores two datetimes and a timespan ideally we could just change it to be a struct but its public instead this commit adds an internal daylighttimestruct which is the same as daylighttime except as a value type and changes some of the internal uses of daylighttime to instead use daylighttimestruct as a result datetime.now is allocation-free.cc tarekgh jkotas
188675802,8079,https://api.github.com/repos/dotnet/coreclr/issues/8079,mjsabby,4,0,0,0,0,0,acquiring timestamps stopwatch.gettimestamp is an important activity in many applications including modern web services often breaking down an applications execution time into scopes aids in performance analysis and is achieved by taking timestamps at predetermined code-sites usually interesting logical points in the applications execution.furthermore often these timestamps are taken in beginactivity/endactivity pairs to get regions of code therefore each region is represented at a minimum with two timestamps and usually also some symbolic name to identify the activity.an example to illustrate this pattern: csstatic void foo using monitoredscope.create(nameof(foo csclass monitoredscope idisposable public static monitoredscope create(string activityname logbegin(stopwatch.gettimestamp activityname public void dispose logend(stopwatch.gettimestamp today the jit would encounter the call stopwatch.gettimestamp cil instruction and if it inlines the method body at the call-site the generated code would be raising a pinvoke frame and then calling into the pal supplied function for example on unix systems that would be systemnative_gettimestamp the pal function defined in the corefx repo would then call into the os supplied function clock_gettime ).that is a total of calls the pinvoke frame the majority of the cost is the pinvoke frame and we could remove that if we make this an fcall in the runtime.however we can improve on this further if we can teach the jit intrinsic to call directly into the os supplied function and do away with the extra call into the pal.given that getting to these timestamps usually ends up being an rdtsc or equivalent instruction on modern oses with modern hardware all recent windows machines and i suspect quite a few linux ones as well maybe some os code its a pretty good win if all were adding by running on the runtime is an indirect call into the os function which is what a non-runtime language like c would also achieve you could imagine that one could take this further and provide an intrinsic for only the rdtsc instruction and maybe thats also a valid issue to file but i see it being significantly less portable at a proportionally higher maintenance cost.as a final note this will be a particularly major cpu efficiency improvement in addition to the wall-clock time improvement in large datacenter applications like bing.com.category:proposaltheme:runtimeskill-level:intermediatecost:medium
188377572,8065,https://api.github.com/repos/dotnet/coreclr/issues/8065,sivarv,1,0,0,0,0,0,kestrel server has following hot methods and the only eh they have is a try-finally block microsoft::aspnetcore::server::kestrel::internal::http::socketinput::consumingcomplete()this method uses lock(obj for synchronization and results a in try-finally whole of the method logic is in try block and finally used for releasing monitor lock microsoft::aspnetcore::server::kestrel::internal::http::frame::takestartlinethis method explicitly uses try-finally block here too whole of the method logic is in try block and finally block has a single method call microsoft::aspnetcore::server::kestrel::internal::http::frameresponseheaders::copytofastthis method uses c foreach that results in try-finally.in-lining finally block within try-block for non-eh execution would be beneficial for these methods at least in-lining simple finally funclets that have a single basic block in a non-nested try-finally case would benefit the above mentioned methods or similar such methods).another related issue right now if the main method saves/restores callee saved regs even funclet methods irrespective of whether they use those callee saved regs also save/restore those callee saved regs this would become a non-issue from execution perf perspective for simple try-finally blocks where we succeed in in-lining finally in the corresponding try
188299958,8056,https://api.github.com/repos/dotnet/coreclr/issues/8056,adiaaida,0,0,0,0,0,1,in the formatting job if there are formatting errors we will run theformatter in fix mode and generate a patch which will be uploaded toazure storage
188249385,8053,https://api.github.com/repos/dotnet/coreclr/issues/8053,AndreyAkinshin,1,0,0,0,0,0,"this issues is based on these so question and answer look at the asm of int math.round(data j ) .legacyjit-x eb fld qword ptr eax+edi eb fistp dword ptr ebp-h ryujit-x d cebd vmovsd xmm,qword ptr rax+rdx*+h de edcef call clr!comdouble::round d d cebce vcvttsdsi ebp,xmm source of clr!comdouble::round clr!comdouble::round d ec sub rsp,h d f movaps xmmword ptr rsp+h ,xmm d fc xorps xmm,xmm dc ffcc cvttsdsi rax,xmm d fc movaps xmmword ptr rsp+h ,xmm d ff movaps xmm,xmm d f movaps xmmword ptr rsp+h ,xmm df ffac cvtsisd xmm,rax d fec ucomisd xmm,xmm d a jp clr!comdouble::round+x da da jne clr!comdouble::round+x da dc f movaps xmm,xmmword ptr rsp+h d fc movaps xmm,xmmword ptr rsp+h d f movaps xmm,xmmword ptr rsp+h dc c add rsp,h da c ret da fc movaps xmm,xmm da ffca addsd xmm,mmword ptr clr!_real f ds: f=fe dae fc movaps xmm,xmm db e call clr!floor dd db fec ucomisd xmm,xmm dbc ff movaps xmm,xmm dbf a jp clr!comdouble::round+x dc dc fafc je clr fnodobfm:: string+xddc dc dc fce movaps xmm,xmm dca fc movaps xmm,xmm dcd ff call qword ptr clr!_imp__copysign dad dd ebb jmp clr!comdouble::round+xc dc)because of this math.round on x runs much slower than on x why ryujit-x uses clr!comdouble::round instead of some kind of a light intrinsic e.g based on cvtsdsi )?category:correctnesstheme:helpersskill-level:intermediatecost:medium"
188056322,8038,https://api.github.com/repos/dotnet/coreclr/issues/8038,AndyAyersMS,6,0,0,0,0,1,remove inlining limitation for methods that return values and haveconditional throws this limitation was most likely a vestige of anolder inlining implementation that did not break trees at inlinecall sites.also removed the now-unused observation and the seenconditionaljump member variable merged ifdef blocks in impinit .ran full desktop testing no issues.enables a handful of inlines in the various code size suites for themost part these slightly increase code size but can often shorten thenon-eh paths in the code
187886555,8034,https://api.github.com/repos/dotnet/coreclr/issues/8034,jamesqo,1,0,0,0,0,0,now that arraypool is in the coreclr repo it may be worth trying to use stackalloc for the int table required by split if the length of the string is small enough otherwise using arraypool
187857782,8030,https://api.github.com/repos/dotnet/coreclr/issues/8030,adityamandaleeka,1,0,0,0,0,0,example here seems to be happening consistently in these jobs i just noticed this and havent investigated it at all but my first hunch is that this is related to guess is that were now now trying to open proc/meminfo with write access with the call to readalllines which is occurring in multiple processes at once).@jeremykuhne
187601353,8018,https://api.github.com/repos/dotnet/coreclr/issues/8018,justinvp,1,0,0,0,0,0,port of lazily allocates and caches a utfnobom instance while binarywriter always allocates new instances instead the same cached instance can be shared between both writers.cc ianhays stephentoub
187588738,8017,https://api.github.com/repos/dotnet/coreclr/issues/8017,justinvp,1,0,0,0,0,0,port new instance of utfencoding is created every time binaryreader.ctor(stream is called which creates an instance of utfencoding that has no preamble however binaryreader does not use the preamble at all so it doesnt matter if the encoding has a preamble or not thus the cached encoding.utf instance can be used instead which has a preamble).note i considered adding an ifdef for non-coreclr to continue to use an instance of utfencoding without a preamble out of an abundance of caution to maintain the exact same serialization output of the m_decoder field when that binaryreader ctor is used but decided it wasnt worth the added complexity.cc jkotas ianhays stephentoub
187432022,8001,https://api.github.com/repos/dotnet/coreclr/issues/8001,JosephTremoulet,1,0,0,0,0,0,since the vector
187323585,7995,https://api.github.com/repos/dotnet/coreclr/issues/7995,stephentoub,1,0,0,0,0,0,fixes
187262465,7994,https://api.github.com/repos/dotnet/coreclr/issues/7994,Petermarcu,5,0,0,0,0,0,we need to come up with a solution that doesnt require users to first install the vc redist in order to install net core
187222068,7988,https://api.github.com/repos/dotnet/coreclr/issues/7988,ramarag,1,0,0,0,0,0,brianrob drewscoggins mmitche ptalfollowup on
186667859,7942,https://api.github.com/repos/dotnet/coreclr/issues/7942,jamesqo,1,0,0,0,0,0,this pr adds string.join overloads that take a char separator which has been approved by dotnet/corefx it supplants please note that while ive verified the code ive wrote compiles its completely untested since i dont have a way to run tests on it that will be done when the api is exposed in corefx.another note i didnt add a join(char ienumerable
186531345,7929,https://api.github.com/repos/dotnet/coreclr/issues/7929,stephentoub,0,0,0,1,0,0,as a follow-on to cleans up remaining cases where nameof can be used
186382782,7914,https://api.github.com/repos/dotnet/coreclr/issues/7914,AndyAyersMS,8,0,0,0,0,0,there are some idiomatic patterns in the async state machines created by the c compiler that cause the jit to generate sub-optimal code.a motivating example is the method requestprocessingasync>d__ context microsoft.aspnetcore.hosting.internal.hostingapplication+context :movenext():this from kestrel source code the movenext method is a value class method that holds a pointer to the associated frame class frame field references in movenext thus must go through one extra level of indirection the jit also spills the this pointer in movenext leading to code sequences like the following: asmg_m_ig b mov rdx bword ptr rbp+h rdx=this b mov rdx gword ptr rdx rdx=this.<>__this frame ba mov ecx dword ptr rdx null check ba mov rcx gword ptr rdx rcx this.<>_this.somefield b mov rdx bword ptr rbp+h rdx this b mov rdx gword ptr rdx rdx this.<>_this frame b mov rdx qword ptr rdx b mov rcx gword ptr rcx+ the jit should be able to cse some of these redundant loads see for a small repro case the c compiler could help the jit by caching this in a local and perhaps by inserting an early null check the method is roughly speaking an outermost switch such methods can incur relatively high prolog costs from zero initializations in the prolog and this method is a good example: asm dbdffffff lea rdi rbp-ah b mov ecx c xor rax rax fab rep stosd most of the zeroing comes from structs with gc references possible mitigation routes more aggressive copy and reverse-copy prop of structs tracking struct field lifetimes or stack packing code layout because this method has eh cold code cannot be aggressively moved to the end of the method it could however be moved to the end of the enclosing try regions for instance right after the first switch in the method there are a couple of throw blocks: asmg_m_ig ffe jmp rcxg_m_ig bd mov rdx rbx bacfff mov rcx xfffca eebe call corinfo_help_isinstanceofclass c test rax rax jne short g_m_ig bcb mov rcx rbx eafcee call corinfo_help_throwg_m_ig bc mov rcx rax ee call system.runtime.exceptionservices.exceptiondispatchinfo:capture(ref):ref bc mov rcx rax cmp dword ptr rcx ecx efe call system.runtime.exceptionservices.exceptiondispatchinfo:throw():this inlining there are some examples here where an always_inline case pulls in a call to a method with an aggressive inlining attribute we might want to reconsider such cases and force the profitability heuristics to kick in instead for example il tr e below always_inline size configuredtaskawaiter:getresult():this il tr e below always_inline size system.runtime.compilerservices.taskawaiter:validateend(ref il tr aggressive inline attribute system.threading.tasks.task:get_iswaitnotificationenabledornotrantocompletion():bool:this switch codegen there are some degenerate switch cases that would be better expressed as if/then ladders it would probably be worth surveying other async methods to see if this is a common occurence for example: il switch il_b il_b il_b il_b il_b il_b il_b il here there are only targets and theres no interleaving.more detailed notes and various jit artifacts can be found on this gist
186371016,7906,https://api.github.com/repos/dotnet/coreclr/issues/7906,JosephTremoulet,1,0,0,0,0,0,when optrecordloop tries to identify a fixed initial value for a loop iv it must ensure that the proposed initial value is the reaching def on entry to the loop the current check simply checks if the head block which ends with initialization possibly followed by a duplicated loop condition dominates the entry block but this is insufficient because there could be a path from head to entry which modifies the induction var.i believe we can check instead whether all the preds of the entry block that are not the head block are in the loop since if the loop had multiple entries it would be irreducible
186342069,7903,https://api.github.com/repos/dotnet/coreclr/issues/7903,JosephTremoulet,3,0,0,0,0,0,"value numbering is rightly conservative w.r.t indirections off byrefs but should at least be able to remove back-to-back redundant loads for example consider method detail below: c#using system;using system.runtime.compilerservices;public class example public string color public string make public string model public string year public struct car example ex public car(example e ex e methodimpl(methodimploptions.noinlining public void detail describe(ex.color ex.year ex.make ex.model methodimpl(methodimploptions.noinlining public void describe(string color string make string model string year console.writeline(this is a n color make model year public static int main(string args example e new example e.year e.make gmc e.model k e.color rusty car c new car(e c.detail return we generate redundant loads of this.ex for each of the arguments: asm assembly listing for method car:detail():this emitting blended_code for x cpu with avx optimized code rsp based frame partially interruptible final local variable assignments v this v,t byref rcx this v outargs v lclblk rsp+x lcl frame size g_m_ig ec sub rsp g_m_ig b mov rdx gword ptr rcx b mov rdx gword ptr rdx mov gword ptr rsp+h rdx b mov rdx gword ptr rcx b mov rdx gword ptr rdx cb mov r gword ptr rcx db mov r gword ptr r cb mov r gword ptr rcx db mov r gword ptr r efbffff call car:describe(ref,ref,ref,ref):this nop g_m_ig c add rsp c ret when value numbering the indirection via this rather than falling down into this code that uses an entirely opaque value number youd think we could use something that is a function of the pointer and heap values possibly theres some subtlety around the cases where the managed pointer doesnt point into the heap id have to check to recall whether we lump address-taken locals and statics into the heap value number or not if locals are an issue perhaps limiting the scope to byref parameters would help"
186231294,7899,https://api.github.com/repos/dotnet/coreclr/issues/7899,JPBlanc,1,0,0,0,0,0,sorry not a real issuei perhaps lose something but i cant find a way to install net core on raspberry pi.i post the issue on dotnet/cli my answer was closed and i was redirected to this project by piotrpmsft is there a roadmap to target these machines can i help in testing or developping i used to be a system developper on unix os and then windows from to and then applictive over net now i spend more time batching with powershell than writing code but i still support my code.regards.jpb
186187458,7897,https://api.github.com/repos/dotnet/coreclr/issues/7897,stephentoub,1,0,0,1,0,0,cc jkotas jeremykuhne
185962181,7876,https://api.github.com/repos/dotnet/coreclr/issues/7876,pgavlin,1,0,0,0,0,0,"with the advent of operands that are register-optional at the point ofuse the validity of gtregnum has become dependent on whether or notan operand is in fact in a register at the point of use if the operandis in a register then gtregnum is the register that it occupies atthe point of use if it is not in a register then gtregnum is theregister that the operand occupied at the point of def failing toobserve this distinction can result in silent bad code generation aswas observed in vso in this case the spilled result of adouble-returning call that was used by a double->double cast was nevermoved into the casts destination register because the code generatorwas using gtregnum to determine whether or not a move was necessary.to fix this issue this change introduces two new apis on gentree: gentree::regatdef and gentree::regatuse the former returns theregister defined by a node if any and the latter returns the registerin which the nodes value is available at the point at which it is used. gtregnum has also been changed to assert that the node is not contained,in which case gtregnum may return an invalid result for reg-optionaloperands.the new apis should be used as follows when generating code for a node regatdef should be used to determine the register that will contain the nodes value when generating code that consumes a particular node if the node may be contained either because it was marked as such during lowering or because it is register-optional regatuse should be used to determine the register in which the nodes value is available if the node may not be a memory operand gtregnum should be used instead"
185914813,7873,https://api.github.com/repos/dotnet/coreclr/issues/7873,janvorli,0,0,0,1,0,0,this change removes some unused pal functions and the corresponding pal tests
185836151,7869,https://api.github.com/repos/dotnet/coreclr/issues/7869,parjong,1,0,0,0,0,0,soft fp abi enforces a return value to be passed via integer registerseven though it is of float/double type which means that r r shouldbe preseved even for functions that return a float/double value).the current implement of hasfloatregister and getfpreturnsize doesnot consider this abi difference which makes calldescrworkerinternalfunction to preserve fp registers instead of r r and spoilsr/r during preservation which leads to this commit revises these functions in order to fix
185829291,7867,https://api.github.com/repos/dotnet/coreclr/issues/7867,Clockwork-Muse,0,0,0,1,0,0,replaces most use of hardcoded parameter names for argumentexception and its subclasses.corrects a few errors relating to parameters ie where the parameter name and message arguments were flipped or some name mismatches).this was a global find/replace so its possible some slipped through the cracks some remaining instances were left deliberately where the parameter referenced doesnt exist at all didnt investigate but im assuming its generated where its referencing something in a calling method so isnt available at callsite where the parameter is probably a reference to a derived value or otherwise no good substitute.builds and passes on my machine waiting for report confirmation for non-windows systems.was not able to run corefx tests to verify would like instruction there if available the current instructions dont work
185722529,7847,https://api.github.com/repos/dotnet/coreclr/issues/7847,CarolEidt,1,0,0,0,0,0,this fixes devdiv bug and includes a test case it also improves the code generation for the general case of promoted structs though tuning is still needed.the bug was a case where after decomposing the long fields we had entries in the gt_field_list each of which was requesting a register.since lowering wont know which fields may be in registers it must be prepared to handle fields in memory also if the fields are not register candidates we should make them contained and push them directly.in most cases we should use push for promoted structs they are generally small-ish and pushes of lclvars and constants are cheaper than loading into a register).this could be optimized for consecutive float or double fields
185683166,7843,https://api.github.com/repos/dotnet/coreclr/issues/7843,JosephTremoulet,1,0,0,0,0,0,this is mentioned briefly in but im splitting it out into its own issue to make tracking easier.since vector.count is not a constant at source level any non-intrinsic aggregation/searching over vector.count is a constant at jit time and is typically small and the codegen for fixed-offset indexing extracts the elements from the registers without the copy through memory these loops are excellent candidates for full unroll this has been seen e.g in aspnet/kestrelhttpserver
185272321,7815,https://api.github.com/repos/dotnet/coreclr/issues/7815,Petermarcu,6,0,0,0,0,0,lots of logging happens in build systems and services with time stamps in text utf format the most frequently used method for converting datetime to text is datetime.tostring(o round trip format).it turns out single method call allocates objects including stringbuilder objects for total of bytes in bit for datetimekind.local case
185262532,7812,https://api.github.com/repos/dotnet/coreclr/issues/7812,gokarnm,2,0,0,0,0,0,context im creating a custom assemblyloadcontext in my application to load a plugin from a directory the plugin directory contains the output from dotnet publish command for the plugin project using a framework-dependent deployment if the plugin has dependencies which has platform specific implementations dotnet publish puts them in the publish/runtimes/{rid folders a appname}.deps.json file is present in the publish directory which contains metadata about dependencies this file contains information about managed and native dependencies which can be specific to a runtime identifier rid it also contains information about culture specific resource files satellite assemblies this file is used by corehost to build tpa list and resolve dependencies.snippet from deps.jsons targets section system.banana type package dependencies system.foo runtime lib/dnxcore/system.banana.dll resources lib/dnxcore/fr-fr/system.banana.resources.dll locale fr-fr native runtimes/osx..-x/native/libbananahelper.dylib system.diagnostics.tracesource dependencies snipped runtimetargets runtimes/unix/lib/netstandard./system.diagnostics.tracesource.dll rid unix assettype runtime runtimes/win/lib/netstandard./system.diagnostics.tracesource.dll rid win assettype runtime compile ref/netstandard./system.diagnostics.tracesource.dll questions is the resolution logic which uses deps.json to resolve dependecies implemented in the default assembly load context could you point me to the relevent classes/source files where this logic is implemented is there a way to reuse this resolution logic without having to replicate the rules in a custom assembly load context
184990363,7787,https://api.github.com/repos/dotnet/coreclr/issues/7787,sivarv,2,0,0,0,0,0,summary of code changes:gentree.h/gentree.cpp:legacy backend already uses gtf_zsf_set and gtf_set_flags these flags are now used by ryujit backend.gtf_zsf_set codegen of the tree node sets/modifies zf and sf flagsgtf_set_flags codegen of the tree node is required to set the flags this would mean codegen cannot optimize gt_add by generating lea.lowerxarch.cpp compare lowering logic checks to see whether op sets zf flag and if so sets gtf_set_flags on op to indicate to codegen not to perform any optimizations while generating code that would prevent it from setting flags.codegenxarch.cpp if gtf_set_flags is set on op test instruction is not generated.asm diffs:this gives bytes of code size win across all cq perf benchmarks bytes of code size win against desktop mscorlibexecution perf:this changes gives improvement in execution perf of crafty(before ater
184937939,7777,https://api.github.com/repos/dotnet/coreclr/issues/7777,ayuckhulk,0,0,0,0,0,3,this pr fixes various issues in gdb/jit that prevented the lldb from stepping in/through managed code.highlights more info about sequencepoints is passed from symbolreader into gdbjit this allows to generate more accurate dwarf line info and handle multiple prologues/epilogues and negative line changes fixed overlapping thunk sections from different methods by mapping each thunk symbol as a separate section this was preventing the debugger from correctly resolving thunk symbols in those sections.@mikem janvorli ptalcc dmitri-botcharnikov chunseoklee seanshpark lucenticus
184910029,7774,https://api.github.com/repos/dotnet/coreclr/issues/7774,AndyAyersMS,4,0,0,0,0,0,quite a few people have been surprised to see that methods with pinned locals fixed in c cant be inlined we should support inlining such methods where feasible.in c a fixed statement is used to prevent managed objects from being relocated by gc so that raw pointer math and/or gc-unaware code can be used to access the objects the fixed statement block is conceptually enclosed in a try/finally block to ensure that no matter how control leaves the scope of the fixed the pinned local variables are unpinned in our implementation the jit treats pinned locals as untracked gc lifetimes hence unpinning requires that the pinned locals be explicitly nulled out but in many cases in particular when the call site itself is not in a try/catch the c compiler can prove that the unpinning code is unobservable or unreachable and so the try/finally and possibly the unpinning code can be omitted.this fixed optimization done by the c compiler is both good news and bad news.good news it gets us past a deep-seated limitation in the jit about inlining methods with eh if the c compiler always used try/finally wed need to solve a much bigger problem to inline any method with pinning.bad news the jit must now recreate the unpinning logic after inlining or risk extending the scope of the pinning to handle the full set of cases the jit must be prepared to re-introduce the missing try/finally around the body of the inlined code.the proposal here is to support inlining of methods with pinned locals in the subset of cases where the c compiler has omitted the try/finally and the jit determines that likewise no try/finally need be introduced the jit will still need to synthesize and add unpinning code
184879113,7773,https://api.github.com/repos/dotnet/coreclr/issues/7773,janvorli,2,0,0,0,0,0,this change adds a shim layer between the icu libraries and the code insystem.globalization.native.so that automatically picks a version of the iculibraries that is installed on the current machine this enables usage ofthe same system.globalization.native.so on various linux distributions andtheir versions the minimal icu version supported is the one the system.globalization.native.so is built with
184382367,7750,https://api.github.com/repos/dotnet/coreclr/issues/7750,sivarv,1,0,0,0,0,0,example:kestrel server hot method seek method has the following doubly-nested do-while do if pcurrent byte block block index index return byte if pcurrent byte block block index index return byte if pcurrent byte block block index index return byte pcurrent index while pcurrent pend); here is the code generated for one if-stmt block ina c movzx rdx byte ptr r ina ca mov rd dword ptr v rsp+h ina cf cmp edx rdina d jne short g_m_iginaa d mov rcx rbpinab d mov rdx rinac da call corinfo_help_checked_assign_refinad df mov dword ptr rbp rdinae e mov rd dword ptr v rsp+h inaf e mov eax rdinb eb jmp short g_m_ig here pcurrent byte gt_ind byte/byte/byte are the bytes obtained using simd get i intrinsic from vector.here there is an opportunity to replace the first instructions with cmp byte ptr r rl example:@benaadams has the following pr open that updates seek method to accept byte type params and contruct vector
184308429,7740,https://api.github.com/repos/dotnet/coreclr/issues/7740,sivarv,1,0,0,0,0,0,"huffman benchmark uses an array of structsfor e.g the innermost triply nested while loop while(hufftree i .left if(getcompbit(comparray,bitoffset i=hufftree i .left else i=hufftree i .right bitoffset++;} cse recognizes bounds checked hufftree i as cse candidate and replaces with a lclvar.bounds check on hufftree i tmp lea(&hufftree i )now field accesses will turn into reg+fieldoffset if we could fold tmp into field access it will turn into hufftree indexreg*scale fieldoffset this avoids the need for a reg to tmp in fact for tmp there were no callee saved regs available and its gets spilled and reloaded across the call.there are many such opportunities in huffman benchmark to fold addr modes as it heavily accesses array of structs.category:cqtheme:basic-cqskill-level:intermediatecost:medium"
184277385,7738,https://api.github.com/repos/dotnet/coreclr/issues/7738,pkukol,11,0,1,1,0,2,the following is a list of areas being considered for throughput improvements in the near future if anyone wants to help with these just add a note here if we have lots of volunteers we can establish a simple tracking system note that the stuff gathered in this issue addresses the specific goal of speeding up il machine code conversion in ryujit iow things like better heuristics to decide when to use not use minopts finding more ways to avoid compilation at runtime via crossgen or whatever are not covered here importing il typically takes of overall jit time cache results of calling through icorjitinfo such as il token resolution option do this only for large methods no caching across compilations option cache things globally across methods requires retention policy cache the internal format of carefully chosen methods that are frequently inlined this only helps normal opts unless we extend minopts to do fast inlining needs retention policy so memory and any overhead for serializing the ir is not wasted closely tied to the inliner so this should probably be integrated into the inline policy etc logic recognize a tiny subset of trivial il body patterns for matched methods spit out canned ir to bypass the full import logic mark trivial bodies or parts of bodies and add simplified processing downstream for such bodies e.g no jumps no stores to locals or whatever find the most frequent paths through the most expensive jit ee calls and try to speed them up for some calls the jit may not need all the information the ee is currently returning add shortcuts and/or subset versions batch overlap defer ee calls this has ramifications for class loading order etc so feasibility is an open question when the importer asks about tokens methods fields it doesnt need all the info immediately split the relevant expensive ee calls into two parts the first hopefully much faster than the whole would only return the minimal info the importer must have right away the rest could come on a separate thread via an asynch callback or something like that if we do any quick look at il processing e.g to do some of the stuff above for trivial methods we could fire off calls to ask about the tokens we encounter speed up gengeneratecode i.e the far back end takes about of total time speed up gc info gathering and encoding gc encoder avoid sorting when possible speed up bit-twiddling etc instruction encoding try to speed up the most frequent emitxxxxx methods emitter::emitgcregliveupd speed up gcinfo::gcmakeregptrtable and related logic other things such as the scope tracking stuff codegen::sibeginblock etc note probably ignore codegen::gencodefortreenode even though its up to way too many little pieces speed up lsra around of total compile time and make it consume a lot less memory punting this entirely to the ra specialists slim down lowering::dophase currently up to of jit time completely bypass fginterblocklocalvarliveness up to of total time avoid doing lvasortbyrefcount for very small numbers of variables of total time other things returns probably diminish rapidly speed up morph around of total compile time spend less time spent recursively walking trees for minopts global improvements few percent shrink gentree nodes speed up tree walks allocate memory in larger chunks skip more things for minopts few percent skip parts of liveness analysis also see above bypass some tree optimizations just do the simplest easiest thing skip ordering passes evalorder/blockorder for trivial or reducible cfgs or some such short-cut things like lvasortbyrefcount for small numbers of variables etc.category:throughputtheme:throughputskill-level:expertcost:extra-large
184096635,7734,https://api.github.com/repos/dotnet/coreclr/issues/7734,JeremyKuhne,1,0,0,0,0,0,copy arraypool source from corefx and expose in system.private.corelib.this is part of facilitating the move of filestream stephentoub sokket jkotas
183777558,7704,https://api.github.com/repos/dotnet/coreclr/issues/7704,lt72,1,0,0,1,0,0,gc information is coupled with expensive object tracking information making cheap gc events exposed from profiling apis unusable simple information such as start/stop/generation/memory reclaimed should be more readily available
183217165,7635,https://api.github.com/repos/dotnet/coreclr/issues/7635,teo-tsirpanis,1,1,0,0,0,0,according to msdn documentation the random class is using a modified version of donald e knuths subtractive random number generator algorithm.this algorithm is somewhat obscure i have found only this paper that can be said that refers to this algorithm.therefore i propose a change of the default rng in random class to the permuted cogruential generator(pcg according to its site pcg is more difficult to predict smaller both in code size internalsample will be only five lines of code and random s constructor will be another five lines and in memory usage just bytes in comparison with the bytes the existing rng uses more statistically random can also provide some other useful features is a more detailed comparison of pcg and other rngs here submitted to apply these changes but i was told to temporarily close it and to open an issue instead for further discussion.the implementation is based on this one has also added some constructors to random class that allow it to be seeded with the longer ulong seeds pcg allows it also implements multiple codebooks the original constructors are retained so i guess this isnt a breaking api change
183164325,7628,https://api.github.com/repos/dotnet/coreclr/issues/7628,wtgodbe,1,0,0,0,0,0,this is a pretty substantial change which will allow us to build tests against packages in coreclr as well as to build a useable coreoverlay for any os we support this is the test overlay directory containing all the binaries that tests need to run against currently an end-to-end non-windows test run looks like the following build product on windows build tests on windows copy product tests to non-windows build coreclr product on non-windows build corefx product non non-windows call runtest.sh which will gather binaries from both builds of coreclr the build of corefx then run tests against those binariesafter this change the same test run will look like the following build tests on windows copy tests coreoverlay to non-windows run teststhis change does not remove the ability to run tests the old way though that may be coming later it just adds the option of doing it in the new way such a test run would involve the following commands: windows test run ./build-tests.cmd buildagainstpackages ./tests/runtest.cmd againstpackages non-windows test run ./build-tests.cmd buildagainstpackages runtimed insert target runtime id here> (copy tests coreoverlay to non-windows) ./tests/runtest.sh coreoverlaydir=coreoverlay dir testrootdir=test root dir this change will also require some minor changes to pipebuild once it goes in in publish-packages.sh/cmd we will need to change p:containername to container=cc gkhanna dotnet/coreclr-contrib
182940864,7611,https://api.github.com/repos/dotnet/coreclr/issues/7611,BruceForstall,1,0,0,0,0,0,this is always on it hadnt been turned off in a long longtime if ever and we dont expect to ever turn it off
182462936,7580,https://api.github.com/repos/dotnet/coreclr/issues/7580,benaadams,1,0,0,0,0,0,all throwhelper calls are now recognised as cold code.adds gtcallmoreflags gtf_call_m_does_not_return to fgfindjumptargets which happens in early in pipeline which may mark the method as uninlinable so prevent the later setting in fgfindbasicblocks).count the bbj_returns in fgmakebasicblocks rather than recounting afterwards perf)reduced the immediate throw path in throwhelper to help with recognition of the only throws condition.there were some regressions with so much more recognised as cold code and moved out of the main execution path so i added some common exception arguments as extra functions for the generics to call in throwhelper which resolved this kept as individual commits)with current branch diff improvementresolves for mikedn andyayersms pgavlin
182356752,7569,https://api.github.com/repos/dotnet/coreclr/issues/7569,hypersw,14,0,0,0,0,0,the string::format methods have been updated some time ago to eliminate excessive array object allocations and reduce memory traffic.was c#public static string format(string format object arg return format(null format new object arg now c#public static string format(string format object arg return string.formathelper((iformatprovider null format new paramsarray(arg unfortunately with ryujit x this makes simple functions execute up to ten times slower than before in code paths which do not call string::format .here is a code sample c methodimpl(methodimploptions.noinlining public static int fastfunctionnotcallingstringformat(int param if(param throw new exception(string.format(we do not like the value n param if(param int.maxvalue throw new exception(string.format({:n is maxed out param if(param int.maxvalue throw new exception(string.format(we do not like the value n either param return param methodimpl(methodimploptions.noinlining public static int fastfunctionnothavingstringformat(int param if(param throw new argumentoutofrangeexception(param we do not like this value if(param int.maxvalue throw new argumentoutofrangeexception(param maxed out if(param int.maxvalue throw new argumentoutofrangeexception(param we do not like this value either return param private static int main int sum for(int a int.maxvalue a sum unchecked(sum fastfunctionnothavingstringformat(a sum unchecked(sum fastfunctionnotcallingstringformat(a console.writeline(sum return a real-life example of this mock-up would be a collection object which has range checks with diagnostics in its get_item indexer thats how weve hit it a simple enough indexer suddenly showed up as the hottest function in the profile.notice that string::format is never called within the course of execution supposedly these two functions should run at the same speed.now thats what it looks like in the profiler:! image of these functions calls formatting but the one which merely has it on unused code paths takes tenfold well almost time to execute.if we go even deeper the code which takes up the extra time is asmlea rdi ptr rsp+x mov ecx xxor eax eaxrep stosd dword ptr rdi it is located in the function head before any user code.thats like doing zeromemory on the stack frame and quite an amount of that.from this i can guess that jit has inlined the string::format function into the fastfunctionnotcallingstringformat body system.paramsarray now lives on the stack frame of fastfunctionnotcallingstringformat even though the scopes of the three system.paramsarray copies do not intersect each seems to be getting its own space in the stack frame the amount is x sizeof(dword or bytes which is enough for entire sizeof(paramsarray even though these system.paramsarray s are never used or created in the actually executed code zeromemory for them has been pulled up to the head of the function and it affects any call to this function.so string-formats which are only sitting there but are never called do suddenly have a cost upd mostly the same happens in bit runtimes even the relative speeds are the same even though both lower somewhat.i hope for the following improvements costly zeromemory could be moved closer to the usage the jitter might even know when it is safe to omit it altogether but the point is to avoid this until and unless the structure is put to use memory could be reused for structures whose lifetimes never intersect and even are of the same type
182087880,7552,https://api.github.com/repos/dotnet/coreclr/issues/7552,vancem,0,0,0,0,0,2,the previous readme.md associated with the coreclr repo very inadequate for developers to successfully make a coreclr runtime change there was simply too much missing information.this update reorganizes the readme.md to fix this now the readme is a top level document that describes what the repo contains new tells you how to build it existing what gets built new how to use the built artifacts new and how to run tests it still needs work information on running tests is pretty incomplete as well as how to debug but this is a big step forward note that much of the content is new or dramatically changed so it is probably easier to simply read the end result at rather than try to read the diffs if the changes you want are hard to describe in the comments you may wish to simply wait until i merge and then do the update yourself my main goal is to insure that some basic information that i needed to actually do something useful with the repo is there for others
181843686,7535,https://api.github.com/repos/dotnet/coreclr/issues/7535,appsolutegeek,10,0,0,0,0,0,"hi,getting the following errors,launching a debug session from vs code it seems to work but why so many errors loaded usr/local/share/dotnet/shared/microsoft.netcore.app/../system.private.corelib.ni.dll cannot find or open the symbol file.loaded users/ian/downloads/testdotnet/bin/debug/netcoreapp./testdotnet.dll symbols loaded.loaded usr/local/share/dotnet/shared/microsoft.netcore.app/../system.runtime.dll cannot find or open the symbol file.loaded usr/local/share/dotnet/shared/microsoft.netcore.app/../mscorlib.dll cannot find or open the symbol file.loaded usr/local/share/dotnet/shared/microsoft.netcore.app/../system.console.dll cannot find or open the symbol file. anyone help"
181763886,7527,https://api.github.com/repos/dotnet/coreclr/issues/7527,adiaaida,1,0,0,0,0,0,long term it is best that individual gentree nodes that deal with byte types have logic to specify byteable reg specification in the corresponding treenodeinfoinit routine.that way we can tailor the conditions for byteable register specification for each gentree node and other gentree nodes that dont deal with byte types dont need to be concerned about this logic.category:cqtheme:irskill-level:intermediatecost:medium
181469476,7508,https://api.github.com/repos/dotnet/coreclr/issues/7508,CarolEidt,3,0,0,0,0,0,the raytracer benchmark uses wrapped simd types this is the most straightforward way to adapt an existing application to use the simd types however without struct promotion these fields must always reside in memory furthermore since they use the generic struct assignment and initialization code they may use integer forms of the sse instructions further impacting performance
180754484,7465,https://api.github.com/repos/dotnet/coreclr/issues/7465,sivarv,2,0,0,0,0,0,say a local variable is allocated a reg loaded its value from memory say there were many uses of local variable in ir and afterwards local variable needs to be spilled due to register pressure we can avoid writing reg back to memory if there are no intervening updates to reg on the path where it was loaded from memory to the point where it needs to be spilled.category:cqtheme:register-allocatorskill-level:expertcost:medium
180681610,7459,https://api.github.com/repos/dotnet/coreclr/issues/7459,benaadams,1,0,0,0,0,0,"the vector(b ctor is non-inlinable and does a lot of extra worke.g csharpvar v new vector( \n ); wont inline il tr failed too many il bytes vector :.ctor(ubyte):this which leads to the optimal method of using broadcast byte vectors as creating them as statics and then passing them byref such as in but then they arent guaranteed to be aligned.it generates the following asm asm inline treeinlines into vector :.ctor(ubyte):thisbudget initialtime finaltime initialbudget currentbudget=budget initialsize finalsize assembly listing for method vector :.ctor(ubyte):this emitting blended_code for x cpu with sse optimized code rsp based frame fully interruptible final local variable assignments v this v,t byref rcx this v arg v,t ubyte rdx v loc v byref rsp+x must-init pinned v loc v,t int rax v loc v byref zero-ref pinned v loc v int zero-ref v loc v byref zero-ref pinned v loc v int zero-ref v loc v byref zero-ref pinned v loc v int zero-ref v loc v byref zero-ref pinned v loc v int zero-ref v loc v byref zero-ref pinned v loc v int zero-ref v loc v byref zero-ref pinned v loc v int zero-ref v loc v byref zero-ref pinned v loc v int zero-ref v loc v byref zero-ref pinned v loc v int zero-ref v loc v byref zero-ref pinned v loc v int zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v ref zero-ref v tmp v,t long rcx v tmp v long zero-ref v tmp v long zero-ref v tmp v long zero-ref v tmp v long zero-ref v tmp v long zero-ref v tmp v long zero-ref v tmp v long zero-ref v tmp v long zero-ref v tmp v long zero-ref v outargs v lclblk rsp+x lcl frame size g_m_ig ec sub rsp c xor rax rax mov qword ptr rsp+h raxg_m_ig c xor rax rax fc xorpd xmm xmm fff movdqu qword ptr rcx xmm c mov bword ptr rsp+h rcxg_m_ig bc mov rcx bword ptr rsp+h cc movsxd r eax mov byte ptr rcx+r dl ffc inc eax f cmp eax ced jl short g_m_igg_m_ig c xor rax rax mov bword ptr rsp+h raxg_m_ig c add rsp c ret total bytes of code prolog size for method vector :.ctor(ubyte):this"
180646127,7454,https://api.github.com/repos/dotnet/coreclr/issues/7454,pkukol,1,0,0,0,0,0,the emit code and emit gc+eh tables phases of the jit take up to of total compile time which seems pretty high this is esp critical for the minopts path look for opportunities to speed these up.category:throughputtheme:throughputskill-level:expertcost:large
180508593,7447,https://api.github.com/repos/dotnet/coreclr/issues/7447,svick,5,0,0,0,0,0,"conditional jumps especially those that are hard to predict are fairly expensive so they should be avoided if possible one way to avoid them is to use conditional moves and similar instructions like sete as far as i can tell ruyjit never does this and i think it should.for example take these two methods c# methodimpl(methodimploptions.noinlining) static long sete_or_mov(bool cond return cond methodimpl(methodimploptions.noinlining) static long cmov(long longvalue long tmp longvalue xffffffff return tmp longvalue tmp;} for both of them ryujit generates a conditional jump asm assembly listing for method program:sete_or_mov(bool):long emitting blended_code for x cpu with sse optimized code rsp based frame partially interruptible final local variable assignments v arg v,t bool rcx v tmp v,t int rax v outargs v lclblk rsp+x lcl frame size g_m_ig:g_m_ig c test cl cl jne short g_m_ig c xor eax eax eb jmp short g_m_igg_m_ig b mov eax g_m_ig c movsxd rax eaxg_m_ig c ret total bytes of code prolog size for method program:sete_or_mov(bool):long assembly listing for method program:cmov(long):long emitting blended_code for x cpu with sse optimized code rsp based frame partially interruptible final local variable assignments v arg v,t long rcx v loc v,t long rax v outargs v lclblk rsp+x lcl frame size g_m_ig:g_m_ig bffffffff mov eax xffffffff c and rax rcx c test rax rax je short g_m_igg_m_ig c retg_m_ig bc mov rax rcxg_m_ig c ret total bytes of code prolog size for method program:cmov(long):long for comparison here are the same methods compiled using clang and gcc with o by compiler explorer asmsete_or_mov(bool test dil dil setne al movzx eax al sal rax retcmov(unsigned long mov eax edi test rax rax cmove rax rdi ret clang asmsete_or_mov(bool sete_or_mov(bool movzx eax dil shl rax retcmov(unsigned long cmov(unsigned long mov eax edi mov ecx and rcx rdi cmove rax rdi ret category:cqtheme:basic-cqskill-level:expertcost:large"
180415559,7434,https://api.github.com/repos/dotnet/coreclr/issues/7434,sivarv,1,0,0,0,0,0,here is the ir and code generated: n t const ref null reg rcx vn.null t ref n da--g st.lclvar ref v tmp d rbx reg rbx rvn n t lclvar ref v tmp u rdx last use reg rdx rv aa t ref n da st.lclvar ref v tmp d rdx reg rdx rvn n t lclvar ref v tmp u rbx last use reg rbx rv vn.null t ref n da st.lclvar ref v tmp d rcx reg rcx rvn n t lclvar ref v tmp u rdx last use reg rdx rv aa t ref n da st.lclvar ref v tmp d rdx reg rdx rvn n t lclvar ref v tmp u rcx last use reg rcx rv vn.null t ref n da st.lclvar ref v tmp d rbx reg rbx rv here are the assignments:v indir(some const addr)v null xor rbx rbxv v both get rdx and hence no mov gets generated v last use herev v mov rcx rbx v last use herev v both get rdx and hence no mov gets generated v last use here v is used laterv v mov rbx rcx v was assigned rbx v is used laterdb xor rbx rbxbcb mov rcx rbxbd mov rbx rcxbdfc mov rcx xcdf as you can see we have two separate chains of assignment indir(some const addr v v v null v v vlsra got its preferencing right for first chain and there were no redundant moves.in the second chain it didnt get preferencing right and lead to redundant moves.if ryujit did copy prop we could reduce both chains of assignment toi v indir(some constant addr)ii v nullin general it is good to avoid these redundant assignments by copy propagation prior to rationalization these assignments were part of a gt_comma tree and that could be the reason why copy propagation might have not taken palce bb stmt stmtexpr void il x n const ref null vn.nulln a--g---r ref vn.nulln d------n lclvar ref v tmp d vn.null bb stmt stmtexpr void il n n lclvar ref v tmp u last use vn.nulln a------r ref vn.nulln d------n lclvar ref v tmp d vn.nulln a comma void vn.nulln n lclvar ref v tmp u last use aan a------r ref aan d------n lclvar ref v tmp d aa bb stmt stmtexpr void il n n lclvar ref v tmp u last use vn.nulln a------r ref vn.nulln d------n lclvar ref v tmp d vn.nulln a comma void vn.nulln n lclvar ref v tmp u last use aan a------r ref aan d------n lclvar ref v tmp d aa similar redundant assignments/copies occur at different places within the same method.category:cqtheme:copy-propskill-level:expertcost:medium
180196013,7422,https://api.github.com/repos/dotnet/coreclr/issues/7422,sivarv,1,0,0,0,0,0,"there are quite a few front-end optimizations that ryujit can do on simd vector types constant vector propagation.e.g back-end lowerxarch.cpp looks to see if in)equality operation is against a zero vector it checks to see if op is a zero vector if front-end phases propagate constant vectors and make sure they appear as op in a comparison will increase the chance of back-end making the optimization cseing of operations on simd typesright now the setevaloder costs need to be updated for simd types note that depending on the target simd vector size could be bytes on sse machines or bytes on avx machines therefore these costs cannot be static constants should be a function of vector size when two successive indexed accesses of a simd vector take place why not ryujit optimize vextractf/shift operations generated? offset if vectorulongspan u vector offset if vectorulongspan u vector and the assembly it generated:vextractf xmm,ymm vmovd rdi,xmm test rdi,rdi jne fff mov esi vextractf xmm,ymm vpsrldq ymm,ymm vmovd rdi,xmm one possible route is that simd vector index operations are expanded into extract and shift operations early in front-end phase cse phase could evaluate extract operation into a temp and replace all further occurrences that could be eliminated with the temp loop unrolling to iterate over individual vector elements one usesfor int i i vector.count i v i elimination of gt_simd_chk when the index is a non-const in loops like above.vector indexed access using a non-constant would result in writing vector to memory and accessing the required element from memory when the loop is small enough it might be beneficial to unroll loop so that simd vectors are indexed using constant indices one such opportunity is in kestrel server findfistequalbyte method loop hoisting of constant vectorse.g we can hoist the following constant vectors in the below loop vector.one vector.zero new vector(t val)for vector.one b pi new vector.zero promotion of structs containing simd type fields.this is tracked by issue category:cqtheme:vector-codegenskill-level:intermediatecost:large"
180194198,7421,https://api.github.com/repos/dotnet/coreclr/issues/7421,sivarv,1,0,0,0,0,0,this is a place holder issue to review and identify all the opportunities for improving simd codegen or adding new intrinsics that would benefit asp.net scenarios.category:cqtheme:vector-codegenskill-level:intermediatecost:medium
179781229,7399,https://api.github.com/repos/dotnet/coreclr/issues/7399,CarolEidt,1,0,0,0,0,0,extract the main code generator loop the register management methods and some debug info code
179701591,7394,https://api.github.com/repos/dotnet/coreclr/issues/7394,dougkpowers,1,0,0,0,0,0,based on and i would expect the default assemblyloadcontexts unloading event to fire when the application receives a sigterm however the event handler doesnt seem to ever be called.code to reproduce: public class program{private static void unloadtask(assemblyloadcontext obj console.writeline(unloading public static void main(string args console.writeline(starting app assemblyloadcontext.default.unloading unloadtask try console.readline catch system.exception console.writeline(aborted dotnet run$kill term pidoutput:starting appexpected output:starting appunloadingsame behavior with dotnet on osx and windows
179651980,7387,https://api.github.com/repos/dotnet/coreclr/issues/7387,matt-richardson,1,0,0,0,0,0,i see that there are instructions for building on freebsd but there doesnt appear to be any instructions for how to install the built version on see that freebsd builds are all looking happy and looking through the issues i cant actually tell if freebsd is considered complete or not.if it is complete can instructions be added or if not can some information be added somewhere to clarify the status.thanks
179576387,7379,https://api.github.com/repos/dotnet/coreclr/issues/7379,gkhanna79,1,0,0,0,0,0,we will use a central location to set the version of packages produced in the repo if a package needs to override then it can explicitly specify the packageversion.also setup a central flag stabilizepackageversion that can be flipped to true to generate stabilized version packages.@weshaggard ericstj ptalcc russkeldorph
179489377,7376,https://api.github.com/repos/dotnet/coreclr/issues/7376,pkubaj,1,0,0,0,0,0,"im about to send a working freebsd port it builds fine against icu but recent upgrade to broke it.it seems coreclr is not compatible with new icu building c object src/inc/cmakefiles/corguids.dir/__/pal/prebuilt/idl/fusionpriv_i.c.o/wrkdirs/usr/ports/devel/coreclr/work/coreclr-../src/corefx/system.globalization.native/collation.cpp error ucol_setvariabletop is deprecated werror,-wdeprecated-declarations ucol_setvariabletop(pclonedcollator ignoresymbolsvariabletop perr usr/local/include/unicode/ucol.h note ucol_setvariabletop has been explicitly marked deprecated hereucol_setvariabletop(ucollator coll"
178989752,7338,https://api.github.com/repos/dotnet/coreclr/issues/7338,sbomer,1,0,0,0,0,0,these changes are a port of the variablehome and typeid apis that were added to desktop to support better error messages for nullreferenceexceptions the port doesnt have any significant changes compared to the desktop implementation.variablehome apis:the change introduces an icordebugcode::enumeratevariablehomes which gives an icordebugvariablehomeenum each icordebugvariablehome can query for its parent icordebugcode its argument index or slot index location type register or register-relative for now and live range logical native offsets cordbvariablehome is the implementation of this interface.typeid apis:allow the debugger to determine the layout of types without an instance of the type
178938793,7334,https://api.github.com/repos/dotnet/coreclr/issues/7334,sivarv,1,0,0,0,0,0,instructions like addps/addpd/subps/subpd etc allow the second operand to be a memory-op right now this is not taken advantage of by simd codegen partly the reason is that these instructions require simd vector to be aligned on a byte sse or byte avx boundary simd vector locals allocated on stack are aligned by jit and those on heap are not guaranteed to be byte aligned that would mean in cases where memory operand is known to be on stack we should be able to mark the second operand as contained to reduce register pressure.category:cqtheme:vector-codegenskill-level:expertcost:medium
178881411,7332,https://api.github.com/repos/dotnet/coreclr/issues/7332,JosephTremoulet,2,0,0,1,0,0,when presented with an argument marked gft_order_sideeff mark theargument arghassideeff and allow inlining remove the vestigial code todisallow inlining in these cases it corresponded to a prior inlinerimplementation with a different import path that has since been removed;the inliner now re-uses the main import path which can handle thenecessary stack spilling in the presence of gtf_order_sideeff .also remove some related stale/bogus assertions.fixes
178748407,7329,https://api.github.com/repos/dotnet/coreclr/issues/7329,sivarv,2,0,0,0,0,0,this issue was surfaced as part of techempower analysis by intel against netcore rtm as per that analysis kestrel.internal.infrastructure.memorypooliterator.seek is one of the hot methods that has the following in-efficient codegen pattern access th element of ref vectorvar byte bytevector var byte bytevector var byte bytevector currently we are generating vmovd ymm ymmword ptr rbx vpextrw edi xmm xmovz edi diland edi xff instead we should be able to generate movzx edi byte ptr rbx though seek method requires that we optimize th element access in general we should be able to optimize getitem simd intrinsic when simd vector is a memory-op irrespective of whether index is const or in reg getitem intrinsic has two operands op simd vector op index getitemx/y/z/w simd intrinsics on fixed vectors also get materialized in terms of getitem intrinsic that is even getitem operations on fixed vectors will benefit fixing this issue.when op is a memory-op gt_ind or gt_lcl_fld we should be able generate basereg or base+offset or base+sizeof(simd basetype)*indexreg+offset addressing modes to directly access required element from memory the addr operand of gt_ind could be a gt_lea gt_cls_var_addr or lclvar or const all of these are handled by always evaluating addr into a reg for that op of gt_ind should not be marked as contained in lowering we already have a similar case of virtual stub calls on xarch flag gt_inds this flag is now renamed to indicate that addr should be evaluated to a reg and used for flagging gt_ind operand of getitem intrinsic as well.genconsumeaddress this routine was implemented with the assumption that gt_lea are always contained it is no longer true with this change first this routine needs to check whether addr is contained this is required in getitem codegen path as we can have a case of gt_ind is marked as contained but not its addr.superpmi asm diffs indicate that there many cases in simd tests that benefited with this optimization.simd sse tests methods impacted with bytes of code size improvement simd avx tests methods impacted with bytes of code size improvement cq perf one helper method from console mandelbrot benchmark had bytes of size improvement.since that method was not in hot path it didnt move execution perf number.apart from code size improvement this change also results in stack frame saving since we no longer allocate a stack temp to copy simd vector to memory.fix
178453901,7296,https://api.github.com/repos/dotnet/coreclr/issues/7296,gkhanna79,1,0,0,0,0,0,weshaggard ericstj ptalcc leecow wtgodbe dagood
178231821,7286,https://api.github.com/repos/dotnet/coreclr/issues/7286,pkukol,1,0,0,0,0,0,i made the bucket limits nice numbers like the other ones in the same file.@pgavlin mikedn ptal/cc dotnet/jit-contrib
178216336,7283,https://api.github.com/repos/dotnet/coreclr/issues/7283,helloguo,1,0,0,0,0,0,jit_memcpy on x windows may benefit from using wider copies using ymm registers for certain copy lengths on hardware that support it requires cpu dispatch and may additionally require vzeroupper instruction to avoid transition penalties category:cqtheme:helpersskill-level:expertcost:medium
178215950,7282,https://api.github.com/repos/dotnet/coreclr/issues/7282,helloguo,1,0,0,0,0,0,the current implementation of jit_memcpy on x windows checks for address overlap and different paths are taken depending on result however ecma mentions the behavior of cpblk is unspecified if the source and destination areas overlap an optimized version without overlap check may be worth evaluating and implementing category:cqtheme:helpersskill-level:expertcost:medium
178191895,7280,https://api.github.com/repos/dotnet/coreclr/issues/7280,JosephTremoulet,1,0,0,0,0,0,honor this config flag by having assertion prop treat all bounds checknodes as redundant when it is set.also change the flags lookup options to regutil_default to match therest of the jit-focused flags.note that support for this flag is conditional on having the preprocessorflag feature_enable_no_range_checks defined which requires a custombuild with line of inc/switches.h un-commented or with compile flagsaltered to include dfeature_enable_no_range_checks the purpose ofthe flag is to facilitate experiments to estimate the cumulative cost ofbounds checking in various workloads
178076503,7272,https://api.github.com/repos/dotnet/coreclr/issues/7272,mburbea,1,0,0,0,0,0,currently the clr creates a unique type for each delegate declared and there is no conversion for those which have the same return and type parameters.e.g csharpaction a console.writeline(whatever);threadstart s a; throws error error cs cannot implicitly convert type system.action to system.threading.threadstartbefore generics there was a good reason to declare your own delegate type but in the generic age its pretty much frowned upon most people usually use func action or eventhandler(tkey key ref tvalue value);...trygetvalue().trygetvalue; thus i propose the following::if a delegate types invoke method has the same signature then the types are assignment compatible this may break existing code but i dont think its realistic e.g csharpif delegate is action callmethodonaction(@delegate as action else if(@delegate is threadstart callmethodonthreadstart(@delegate as threadstart);} would suddenly invoke the wrong path however i think gettype should still return the type it was created as because while its unlikely you were differentiating between delegates having the same exact arguments you may have code disambiguating between different arrities and having them return a different type may break existing code thus the assignment should not be a silently creating a new delegate like it does in vb.possible issues delegate variance csharpdelegate tret variant(t v);delegate tret nonvariant(t v); should these two delegates be considered equivalent i would argue yes delegate variance imo should have been implicit where applicable csharp here variance is not legal.delegate tret nonvariant(ref t v i think doing something like this could allow c to consider a cannonical representation which would allow stronger type inference this can even be limited to those assignable to func or action e.g or less arguments for unusual delegates like those using byref out then you would still have to declare your own.currently the following statement would fail to compile because lambdas are not typed csharpfunc(func
177967167,7270,https://api.github.com/repos/dotnet/coreclr/issues/7270,CarolEidt,1,0,0,0,0,0,see the code in lowering::treenodeinfoinitcmp and codegen::gencompareint if op is a constant it should be able to swap them to generate cmp r/m imm
177884675,7262,https://api.github.com/repos/dotnet/coreclr/issues/7262,pkukol,1,0,0,0,0,0,enable count_ast_opers in jit.h to get the output below the example is from asp.net musicstore).ptal pgavlin bruceforstall caroleidt/cc dotnet/jit-contrib gentree operator counts approximate gt_lcl_var bytes each gt_ret_expr bytes each gt_cns_int bytes each gt_nop bytes each gt_arr_length bytes each gt_cast bytes each gt_addr bytes each gt_ind bytes each gt_storeind bytes each gt_add bytes each gt_asg bytes each gt_eq bytes each gt_ne bytes each gt_comma bytes each gt_lea bytes each gt_jtrue bytes each gt_list bytes each gt_field bytes each gt_call bytes each gt_beg_stmts bytes each gt_stmt bytes each gt_return bytes each gt_phi bytes each gt_phi_arg bytes each gt_argplace bytes each gt_putarg_reg bytes each all other gt_xxx small large total all small large
177820915,7255,https://api.github.com/repos/dotnet/coreclr/issues/7255,CarolEidt,1,0,0,0,0,0,eliminate gtlsrainfo and combine the treenodeinfoinit with the building of refpositions.some more info on this issue:to do the current implementation actually includes five traversals the interval building is actually done in three traversals which should be merged into one the first traversal which is actually the second phase of lowering records the constraints and hints the second traversal builds the intervals this could be done with the first traversal the third traversal sets the last use bits this is done separately because there are currently inconsistencies between the gtnext/gtprev links and the actual order of codegen once this is resolved the lastuse bits should be set prior to register allocation by dataflow and/or ssa analysis bugs and the gtlsrainfo could/should be eliminated with the merging of the first two traversals it is really only a mechanism for communicating information from the lowering::treenodeinfoinit phase to the linearscan::buildintervals phase
177711038,7252,https://api.github.com/repos/dotnet/coreclr/issues/7252,CarolEidt,0,0,0,1,0,0,"add support for gt_obj for x and allow them to be transformed into a listof fields in morph if it is a promoted struct add a new list type forthis gt_field_list with the type and offset and use it for the multiregarg passing as well for consistency.also refactor fgmorphargs so that there is a positive check for remorphing,rather than relying on gtcalllateargs which can be null if there are noregister args.in codegenxarch modify the struct passing genputstructargstk to work forboth the x/ux and x case including the option of pushing fields ontothe stack.eliminate the redundant ins_movs_ptr and replace with the pre-existingins_movsp"
177702214,7251,https://api.github.com/repos/dotnet/coreclr/issues/7251,davidfowl,1,0,0,0,0,0,today the supported way to get the byte representation of a guid is to use tobytearray which allocates a byte instead it would be great if there was an overload that could write into an existing byte
177531128,7239,https://api.github.com/repos/dotnet/coreclr/issues/7239,vkvenkat,1,0,0,0,0,0,the kestrel.internal.infrastructure.memorypooliterator.seek function in memorypooliterator.cs tries to access an element of a byte vector public unsafe int seek ref vector
177516895,7234,https://api.github.com/repos/dotnet/coreclr/issues/7234,lt72,2,0,0,0,0,0,this work item is a follow up to pr for issue currently memmove and memcpy are defined and undefed is a few places in the code base addressing all usages of memcpy/memmove may require identifying or creating a central place where to create a definition for those methods that is eventually routed to the correct implementation also addressing all individual usages should be carried out incrementally by providing adequate performance measurements
177062290,7200,https://api.github.com/repos/dotnet/coreclr/issues/7200,adiaaida,1,0,0,0,0,0,after we format the sources again we will be turning on the pr tests for formatting which will enforce jit formatting.see the jit-format documentation for how to run jit-format
177053402,7198,https://api.github.com/repos/dotnet/coreclr/issues/7198,helloguo,6,0,0,2,0,0,this pr provides an optimized version of jit_memset/jit_memcpy assembly helper functions on bit windows jit_memset gets invoked when bytecode initblk is executed while jit_memcpy gets invoked when bytecode cpblk is executed jit_memcpy takes care of both overlap and non-overlap scenarios the use of this optimized jit_memcpy is extended to buffer::blockcopy and buffer::internalblockcopy by replacing the crt memmove this pr addresses the issue the unit test is used as reference and modified so that the copy length varies from byte to bytes this micro benchmark tests buffer::blockcopy jit_memcpy the following chart and table show the result on intel(r core(tm i-x cpu ghz with gb ram os is windows enterprise image also measure the performance of techempower json serialization and plaintext tests the experimental configuration for the app server is intel(r xeon(r cpu e v ghz with gb ram running windows server r bits the difference between baseline and the prototype is within the run to run variation for json serialization test vtune profiling shows the default jit_memset takes of overall cycles while the optimized jit_memset takes cycles for our prototype same thing happens to plaintext test the default jit_memset takes of overall cycles while the optimized jit_memset takes of overall cycles for both json serialization and plaintext tests jit_memset improves by about both json serialization and plaintext tests do not use jit_memcpy in terms of buffer::blockcopy the profiling shows most of the copy lengths are from bytes to bytes for which crt memmove and the optimized jit_memcpy have similar performance so the improvement is negligible for techempower.these optimized routines may need to be revisited when vc/universal crts get updated from both performance and maintenance points of view
176958568,7187,https://api.github.com/repos/dotnet/coreclr/issues/7187,adiaaida,1,0,0,0,0,0,for x rotate a long by a variable amount we will just default to whatlegacy backend does which ultimately will generate two helper calls inthe future we may want to write a helper function for rotate for thesecases to eliminate one of the helper calls
176909195,7184,https://api.github.com/repos/dotnet/coreclr/issues/7184,Dmitri-Botcharnikov,1,0,0,0,0,0,in sos.symbolreader we obtain path to pdb file form assemblys debugdirectoryentry if however assembly was built on windows machine by dotnet cli toolchain such entry contains full windows-style path when were trying to extract file name from this full path on linux machine during debugging session the path.getfilename returns the same full path so when combined with directory name of assembly results invalid path and prevents opening pdb see src/toolbox/sos/netcore/symbolreader.cs tryopenreaderfromcodeview method.cc mikem kvochko lucenticus seanshpark chunseoklee
176713335,7166,https://api.github.com/repos/dotnet/coreclr/issues/7166,adiaaida,1,0,0,0,0,0,gt_div gt_mod gt_udiv gt_rol gt_ror and gt_mulhi will never make itto decompose so remove the case statements for those operations theywill fall through to the default case which noway_asserts that we haventgotten to decompose with an oper that we dont recognize
176687060,7161,https://api.github.com/repos/dotnet/coreclr/issues/7161,vancem,1,0,0,0,0,0,lists addrange method immediately defers to list.insertrange which has the following code has a special case if the passed ienumerable is an icollection so that it can determine how many things will be added and do an ensurecapacity so there will only be at most one resize operation this is great however it then allocates a temporary array and copies the range into that array and into the target list this is very inefficient there is an unnecessary allocation as well as two rather than one copy per element).fix this so that instead of using copyto it simply enumerates the values and places the in the correct locations in the target array this is always more efficient and a minor code change stephentoub jkotas if someone does not beat me to it i will prepare a pull request for this
176596542,7155,https://api.github.com/repos/dotnet/coreclr/issues/7155,Dmitri-Botcharnikov,0,0,0,0,0,1,this pr adds libcoreprof.so an implementation of profiler for linux/arm currently it was checked only on arm/softfp the build is wrapped with feature_linux_profiler build.sh arm-softfp cross cmakeargs dfeature_linux_profiler=true to run: coreclr_profiler={dafe-fdca-de--cdeeba coreclr_enable_profiling coreclr_profiler_path=./libcoreprof.so prof_execution_trace prof_collect_method=sampling prof_line_trace prof_trace_filename=profile.log corerun demoapp.dll the resulting log file contains vm events and samplings based on ltt ng.cc chunseoklee seanshpark lemmaa kvochko lucenticus
176277634,7137,https://api.github.com/repos/dotnet/coreclr/issues/7137,DemiMarie,0,1,0,0,0,0,system.nullreferenceexception should never be thrown by user code this pr marks its public constructors as obsolete
176248636,7135,https://api.github.com/repos/dotnet/coreclr/issues/7135,fschmied,4,0,0,0,0,0,this feature request was originally at its really hard to implement a correct algorithm that gets the parent definition of a methodinfo propertyinfo or eventinfo representing a member override a naive implementation is bound to contain bugs regarding overloading shadowing generics and overrides with non-matching accessibility the only support reflection offers for the not so uncommon use case of walking the member override chain is the methodinfo.getbasedefinition api which can be used to check whether two methodinfos are part of the same override chain they are if they have equivalent base definitions however even using getbasedefinition one can easily make mistakes e.g forgetting to take the reflectedtype of a methodinfo into account this influences equality comparisons and the resulting code is likey to suffer from bad performance.on the other hand runtimemethodinfo contains an internal getparentdefinition method that can efficiently and correctly return the base method info of an override the attribute class contains an algorithm for walking the base member chain for properties and events based on runtimemethodinfo.getparentdefinition .i suggest that these existing apis are made public add public fast getparentdefinition apis on methodinfo propertyinfo and eventinfo that can be used to safely walk the override chain in reflective code
176217073,7132,https://api.github.com/repos/dotnet/coreclr/issues/7132,justinvp,0,0,0,1,0,0,add array.reverse.reverse to use it api-approved)cc jkotas stephentoub weshaggard jamesqo benaadams
175795697,7106,https://api.github.com/repos/dotnet/coreclr/issues/7106,pgavlin,1,0,0,0,0,0,dont find uses unless necessary this saves about milliseconds whilecrossgening mscorlib
175643808,7103,https://api.github.com/repos/dotnet/coreclr/issues/7103,treziac,1,0,0,0,0,0,using vs update with netcoreapp.(sdk preview create an assembly with a class a with internal property prop make this assembly visible to an other assembly assembly internalsvisibleto(test in assembly test try to access prop with both dynamic and typed variables var typed new a();dynamic dyn new a(); typed.prop works but dyn.prop generates runtimebinderexceptionin net-net both work
175478527,7083,https://api.github.com/repos/dotnet/coreclr/issues/7083,mattwarren,32,0,0,0,0,7,backgroundi came across this idea after seeing that java has implemented it see jep for the full details plus this infoq article for some extra info.im aware of the corefx labs effort to implement a utf string library but this proposal doesnt require using a different library it changes the implementation of all strings in the coreclr a bit ambitious i know!!)note this optimisation work because many types of strings in web-based applications can actually be encoded as ascii or iso latin for instance urls http headers etc so even with internationalised applications there are still some possible savings implementationone way of implementing this is to change the internal string layout to the following with an extra m_type field cpppublic sealed class string icomparable icloneable iconvertible ienumerable icomparable
175124555,7056,https://api.github.com/repos/dotnet/coreclr/issues/7056,benaadams,4,0,0,0,0,1,common example is foreach csharpforeach var item in col becomes something like csharpvar enumerator col.getenumerator();try while enumerator.movenext var item enumerator.current finally enumerator.dispose();} usually dispose is an empty function but a function that uses foreach will be discounted for inlining due to failed has exception handling it would be helpful if the dispose was detected as empty inlined then the finally block detected as empty then the whole try/finally removed
175092796,7055,https://api.github.com/repos/dotnet/coreclr/issues/7055,ntsekouras,1,0,0,0,0,0,add support for windows server sp
174623308,7029,https://api.github.com/repos/dotnet/coreclr/issues/7029,bbowyersmyth,3,0,0,0,0,0,squeeze a little more performance out of stringbuilder ctor tostring others the default ctor and by far the most used goes through conditions a string pin and a function call none of which are needed changed implementation to be just the two things that are required the ctor(int second most common also does a string pin and function call redirect to the smaller ctor(int int overload missing uint cast caused additional casting code to be generated fix on array instead of array for less generated il lengths are checked beforehand moved return statements inside the fixed block so that the char doesnt need to be nulled out test before after ctor ms ms ctor ms ms tostring ms ms perf test code test
174586025,7026,https://api.github.com/repos/dotnet/coreclr/issues/7026,jkotas,2,0,0,0,0,0,i have compared perf of unix toupper/tolower between corert and coreclr versions corert version is faster so i am switching coreclr to it as well with a small tweak to make it even better:perf result for e invocations on mac before ms after ms
173747876,6956,https://api.github.com/repos/dotnet/coreclr/issues/6956,Dmitri-Botcharnikov,0,0,0,0,0,1,this pr adds support for gdb/jit feature ability to set breakpoints on managed code by using lldb breakpoint set command: (lldb breakpoint set f hello.cs l breakpoint no locations pending).warning unable to resolve breakpoint to any actual locations.(lldb cprocess resuming location added to breakpoint location added to breakpoint process stopped thread tid xafaffc jit(xeb) show_message at hello.cs name corerun stop reason breakpoint frame xafaffc jit(xeb) show_message at hello.cs public class program public void show_message string a hello world string b coreclr console.writeline(a b);(lldb nprocess stopped thread tid xafaffe jit(xeb) show_message at hello.cs name corerun stop reason step over frame xafaffe jit(xeb) show_message at hello.cs public void show_message string a hello world string b coreclr console.writeline(a b lldb c this pr changes gdb/jit feature so that debugging information is generated for all jitted methods in assemblies listed in coreclr_gdbjit environment variable: export coreclr_gdbjit=hello..exe cc lucenticus chunseoklee lemmaa mikem jkotas
173703306,6954,https://api.github.com/repos/dotnet/coreclr/issues/6954,jkotas,0,0,0,0,0,1,generic arraypinninghelper resulted into incorrect array data offset for reference types use non-generic one instead add array covariance checks to guarantee type safety
173595101,6951,https://api.github.com/repos/dotnet/coreclr/issues/6951,benaadams,1,0,0,0,0,0,with this change monitor.tryenter(o moves from the slowest opportunistic locking to the fastest when using the inline asm path)corefx tests pass not sure how to trigger the track_sync flag?m iterations method pre ms post ms improvement monitor.tryenter(o x usage from apisof.net method api port nuget monitor.tryenter(object monitor.tryenter(object bool monitor.tryenter(object int monitor.tryenter(object int bool monitor.tryenter(object timespan monitor.tryenter(object timespan bool resolves
173475934,6934,https://api.github.com/repos/dotnet/coreclr/issues/6934,CyrusNajmabadi,6,0,0,0,0,0,issue and a discussion with stephentoub prompted me to file this issue to get some knowledgeable eyes to look at an idea i had.specifically in the course of that bug being fixed i was made aware that the corefx implements array.sort(comparison(t t t t icomparer i have an idea about how this would work but i wanted to run it by people here to see if there would be any roadblocks that would get in the way its my understanding and please correct me if im wrong that a delegate is mostly just a class that inherits from system.delegate or system.multicastdelegate it has a compiler provided invoke method with the signature specified it seems to me that this class could just implement the specified interface and that the invoke method would fill in the slot for the interface table in that class.my hope would be that this would then just work the comparison s id like to play around in il later to see if thats the case however i wanted to run it by the people here to see if theres any concern at the clr level about if this is possible or not are there special shenanigans or other delegate specializations going on that would make this approach not work or does this seem like an easy thing to do that would provide for a small alloc win in the case i ran into this was actually a hot path the delegate was cached but it never occurred to me that the runtime would then be adding an alloc each time i called sort thanks for your help
173266034,6915,https://api.github.com/repos/dotnet/coreclr/issues/6915,JosephTremoulet,6,0,0,0,0,0,when all of the arguments of an interface call are invariant w.r.t a containing loop the jit could rewrite the interface call as a call to corinfo_help_virtual_func_ptr to fetch the function pointer followed by an indirect call on that pointer the helper call could then be hoisted from the loop this would remove a couple levels of indirection i.e dereferencing the cell jumping to the thunk verifying in the thunk that the callsite is monomorphic and dereferencing the cached function pointer per loop iteration i presume that this would have to be weighed against the cost of redoing the lookup on each invocation of the method being compiled which if i understand our thunk calls correctly would otherwise have its result cached across invocations. im migrating an optimization suggestion from connect to github category:cqtheme:loop-optskill-level:expertcost:medium
173230317,6912,https://api.github.com/repos/dotnet/coreclr/issues/6912,ikopylov,0,0,0,0,0,3,this is the issue for year old pr hopefully it will help to move forward.semaphoreslim uses pulseall to notify all waiting threads that the release happened but in fact only few of the waiting threads will exit the lock according to the value of semaphore currentcount all other threads will waste the cpu resources just to check the condition and return to the wait state that becomes a bottleneck when the number of waiting threads is larger than the number of cpu cores.the resolution will be to call pulse according to the number of releasecount and waitcount math.min(releasecount waitcount) ).performance comparison can be found here here
173183434,6910,https://api.github.com/repos/dotnet/coreclr/issues/6910,sjsinju,0,0,0,1,0,0,"now arm emulator failed by out of space on tests to resolve,a temp folder in the jobs workspace would be bound to tmp and then runtest.sh run by some directories bound from tmp"
173094915,6906,https://api.github.com/repos/dotnet/coreclr/issues/6906,redknightlois,24,0,0,0,0,5,tldr the design guidelines for system.numerics conflict with general simd needs as stated at until that happen support for simd will be constrained by design decisions made when xna was still current like years ago while numerics is a good way to support the math oriented most common vector operations the simd world is far bigger that simd support is tied to system.numerics is an artificial design decision that hampered the ability of supporting true simd with many of the most important instructions like advance bits manipulation bits packing shuffle permutations etc.my proposal is to leave system.numerics alone and separate the raw simd support on a different namespace and follow a simplier approach for it then system.numerics can use that support as anyone else there are many issues already opened and discussed that exist because simd support lives with system.numerics instead of as standalone primitives that can be used by any library like it is done in c/c through compiler intrisics the ones i track are upside of supporting simd as primitives is that if the plumbing is there for the jit to do that and we need a new instruction we can just go and add it in an up-for-grabs task cc mellinoe caroleidt terrajobst
173055935,6902,https://api.github.com/repos/dotnet/coreclr/issues/6902,JosephTremoulet,1,0,0,0,0,0,consider this code c#using system;using system.diagnostics;class arrayperf private static int m_arr private const int max_array_size private static readonly int dim max_array_size static void main(string args long iterations int.parse(args int value m_arr new int dim for int i i dim i m_arr i i for int j j dim j value m_arr j var sw stopwatch.startnew for long i i iterations i for int j j dim j value m_arr j value m_arr j value m_arr j value m_arr j value m_arr j value m_arr j value m_arr j value m_arr j value m_arr j value m_arr j sw.stop console.writeline(sw.elapsedmilliseconds even with fixes in place for and were unable to hoist the invariant array length loads that get inserted for the bounds-checks on all those m_arr i accesses out of the loops because the m_arr i expressions look like this when opthoistloopcode runs: n a--xg indir int l c:$>n const long fseq #firstelem cn n byref cn n const long cn n long cn cast long int cn i lclvar int v loc u n n byref l:$a c:$>n lclvar ref v tmp u last use l c:$c>n xg comma void l c:$b>n x arrbndschk_rng void l c:$>n x arrlen int l:$c c:$c>n lclvar ref v tmp u l c:$c>n lclvar int v loc u n acxg comma void l c:$c>n g indir ref l c:$c>n const(h long xbf static fseq m_arr n cxg comma ref l c:$>n h-cxg call help long helper.corinfo_help_getshared_nongcstatic_base cn arg in rcx const long xffbbe cn arg in rdx const int n acxg---r ref l c:$>n d------n lclvar ref v tmp d l c:$c> note that the static field m_arr is loaded and then stored to a local in the left side of a comma then subsequently referenced in the arrlen and load expressions even though the arrlen expression is loop-invariant and recognized as such with fixes for and in place we cant hoist it because opttreeisvalidatloophead fails for it the use of lclvar ref v tmp the temp which holds the pointer to the array cant be hoisted above its definition without a rewrite the rewrite that wed need actually does happen as a result of the rhs of the assign into the def being hoisted out of the loop during cse but since that runs after optloophoist were at something of an impasse.to my mind this sort of issue is an argument for a rewrite-as-you-go ssa-based implementation of cse and licm which would necessitate recording heap dependencies in ssa but also ought to enable dropping the liberal/conservative value number bifurcation).category:cqtheme:loop-optskill-level:expertcost:medium
173034858,6898,https://api.github.com/repos/dotnet/coreclr/issues/6898,benaadams,4,0,0,0,0,0,fail faster for wait when no counts available.dont allocate in the wait and waitasync fail paths.m iters server gc method pre ms post ms improvement wait x waitasync x memory allocations saves mb over the m ops
172981087,6892,https://api.github.com/repos/dotnet/coreclr/issues/6892,jamesqo,1,0,0,0,0,0,list.insertrange currently allocates an intermediary array to copy the items into then copies it into the lists buffer this changes it to copy directly into the lists buffer.i realize that this was probably intentionally done in case a bad icollection implementation held on to the array in copyto however list is already mutable as-is so the only thing this would let such an implementation do is modify the arrays contents without changing version .@jkotas do you think this is a change worth making i understand it could cause problems with such a faulty implementation but for other collections esp large ones it seems worth it.also ccing omariom mikedn
172813414,6874,https://api.github.com/repos/dotnet/coreclr/issues/6874,rahku,1,0,0,0,0,0,u and bpmd sos commands do not work anymore most likely due to pr i tried this on windows x debug builds u ffdddenormal jit generated codeporgram.main()begin ffddde size ce exception in f:\coreclrgit\coreclr\bin\tests\windows_nt.x.debug\tests\core_root\sos.dll.u debugger extension pc ffd baf va r/w parameter it seems like sos is trying to load diasymreader.dll which it is unable to find
172626585,6855,https://api.github.com/repos/dotnet/coreclr/issues/6855,jyoungyun,1,0,0,0,0,0,the long value can use the signed bit to express a big number in bit machine.just because the long value uses the signed bit it doesnt mean that thevalue is a negative so toint function should return the original valuewithout changing this issue is related to system.diagnostics.tests.processmoduletests.testmoduleproperties tc in corefx.in bit machine the address can use the all bit including the signed bit(the th bit).but this value currently is interpreted in negative value while converting long to void because the signed bit is true.here is the example code long val unsafe intptr val new intptr((void val console.writeline(val val.toint val val.toint and results: val val.toint acb ffffffffacbjust because the long value uses the signed bit in bit machine it doesnt mean that the value is a negative so toint function should return the original value without changing.after applying this patch the result is like below: val val.toint fix
172037319,6805,https://api.github.com/repos/dotnet/coreclr/issues/6805,jamesqo,2,0,0,0,0,0,currently there is a method findentry in dictionary it returns the index of the given keys entry in the dictionarys entries field returning if not found at all of its call sites including trygetvalue and the indexer its being used like this csint i findentry(key);if i tvalue value entries i .value;} this has the downside that since the jit doesnt know anything about the properties of i it needs to generate a range check when accessing the array which bloats the callers enough so that theyre not inlined as a result every time someone calls get_item or trygetvalue there are method calls to the method itself since its not inlined due to this range check and to findentry .this change eliminates findentry entirely replacing all such usages with trygetvalue this has the effect of making the code more readable and reducing code bloat as for trygetvalue itself all of the hashing/entry-searching code is now written inline in there so there is only method call performance impactthere is about a improvement from s to s assuming int is the key type and there are no collisions source code i know the difference is small but its still there and imo the new code is cleaner/higher-level.the reason the difference is so small is presumably due to all of the other stuff going on in the method there are at least interface calls to comparer.gethashcode and comparer.equals not to mention the operator being used on the hashcode which is quite slow with a string key the difference becomes almost immeasurable since the randomized string hashing takes almost as long as the dictionary lookup itself.i examined the assembly for containskey the indexer get_item and trygetvalue and made sure all of them were jitted to calls to trygetvalue i also tested the first and made sure there were no regressions.cc jkotas benaadams omariom gspp mikedn
171976079,6798,https://api.github.com/repos/dotnet/coreclr/issues/6798,redknightlois,1,0,0,0,0,0,currently the native generation is able to use pgo and as stated by jkotas on it is going to be supported at coreclr eventually already supported at the desktop framework being able to allow the jit to consume that information without the need to generate a native executable would allow software developers to pack that data into their executables to get the same benefits in a portable way.category:cqtheme:profile-feedbackskill-level:expertcost:extra-large
171949696,6792,https://api.github.com/repos/dotnet/coreclr/issues/6792,agonzalezm,1,0,0,0,0,0,i am trying to run net core and powershell on centos but get error:/usr/lib/libstdc++.so version glibcxx not foundwould be possible you add support for centos centos is used in lot of servers you are supporting and providing packages for last two version of ubuntu and ubuntu would be great you support last two centos major version
171911306,6790,https://api.github.com/repos/dotnet/coreclr/issues/6790,JosephTremoulet,2,0,0,0,0,0,consider this program c#using system.runtime.compilerservices;namespace n public class c int a int x methodimpl(methodimploptions.noinlining void array_instance(int s int d int d a d a s a d a s methodimpl(methodimploptions.noinlining void field(int s int d int d x a s a d a s methodimpl(methodimploptions.noinlining static void array_static(int a int s int d int d a d a s a d a s public static int main(string args c c new c var a new int c.a a c.array_static(a c.array_instance c.field return in array_instance we currently generate bounds-checks for both ldelem s of a s even though we cse the load of array a the bounds-checks themselves are not cse candidates because they have type void and even if that checked passed theyre not in the list of cse-candidate opcodes so cse doesnt remove them if we could cse the ldelem s wholesale wed include the bounds-check in that cse as we do in method field but we cant do that in array_instance because the store to a d might overwrite a s assertion prop doesnt help either because the to loads of array a have different conservative value numbers and assertion prop uses the conservative numbers for fear of breaking safety by removing a redundant bounds-check but redundantly fetching the array not that the fear is warranted in this case as cse removes the redundant load by contrast in method array_static where the array a is an argument the array portion of the two ldelem s has the same conservative value number so assertion prop removes the second a s bounds check even though it has to leave in the second a s load due to the possibility that the store to a d overwrote a s .this same effect prevents hoisting invariant bounds-checks out of loops where the loop mutates the array that happens in this code from benchmark jit/performance/codequality/benchi/bubblesort s inner loop c for int j i j bound j if x i x j int temp x j x j x i x i temp here x and i are invariant w.r.t this loop but x i gets stored to and so the loads of x i cant be hoisted out of the loop the bounds check on the load x i however should be hoistable loop hoisting doesnt hoist it because its a cse candidate but even if it did neither cse nor assertion prop would remove the check in the loop because of the same reasons as in array_instance above).category:cqtheme:bounds-checksskill-level:expertcost:medium
171795348,6782,https://api.github.com/repos/dotnet/coreclr/issues/6782,ramarag,0,0,0,1,0,0,this will ensure the expected version to be present at the runtime@wtgodbe rahku gkhanna jkotas ptalfixes
171794470,6781,https://api.github.com/repos/dotnet/coreclr/issues/6781,benaadams,1,0,0,0,0,0,mod cycle dependency latency isnt necessary in threadpoolworkqueue:dequeue loop can be replaced with ternary operator@stephentoub seem ok
171651173,6769,https://api.github.com/repos/dotnet/coreclr/issues/6769,sergign60,2,0,0,0,0,0,the given pull request proposes a way for resolving issue jitted code dropping support its distinctive features and algorithm are all its code is under if defined(feature_jit_dropping and doesnt mess up with other code this feature is working only if the options internal_jitdropenabled and internal_jitdropmemthreshold jitted code can be dropped only for methods that are not dynamic or fcall if the size of the generated native code exceeds the value of internal_jitdropmethodsizethreshold this code is placed in the special heap code list each heap block in this list stores the code for only one method and has the sufficient size for the code of a method aligned to k the pointers to such methods are stored in the calledmethods hash map if the entrypoint of a method is backpatched this method is excluded from the calledmethods hash map when the total size of the generated native code exceeds the value of internal_jitdropmemthreshold option the execution of the program is stopped and stack frames for all the threads are inspected and pointers to methods being executed are stored in the executedmethods hash map the code for all the methods from the calledmethods that are not in the executedmethods is dropped all heap blocks for these methods are set in the initial state and can be reused for newly compiled methods pointers to the code for non-executed methods are set to null the coreclr code with this feature is built by the option./build.sh cmakeargs dfeature_jit_dropping=true
171587883,6767,https://api.github.com/repos/dotnet/coreclr/issues/6767,jamesqo,1,0,0,0,0,0,dotnet/corefx was recently merged which tweaks valuetuple s hashing algorithm it takes all bits into accounts equally and has a better spreading effect for lower numbers.since its probably best to maintain parity between tuple/valuetuple in terms of hash codes and the like ive updated the implementation here to use the same formula as well ive only enabled it for coreclr since this can be breaking.)i also noticed while looking into the tuple source code that equalitycomparer
171428410,6759,https://api.github.com/repos/dotnet/coreclr/issues/6759,jamesqo,1,0,0,0,0,0,currently the utfencoding methods are kind of a mess and they read ints at a time rather than longs so theyre not taking full advantage of bit platforms additionally strings have an isascii flag cached in the syncblk that we may be able to make use of since that will essentially let us skip any checks for non-ascii data during the loop and make getbytecount o().other ideas for optimization havent proven it but im sure that encoding.utf will not be inlined it does volatile accesses and initialization the constructor is more likely to be inlined this is going to harm the typical use case for people who dont cache the result like this csvar bytes encoding.utf.getbytes(str);bytes xff;str encoding.utf.getstring(bytes second method call to get_utf we should attempt to instead do something similar to arraypool.shared where the one-time init logic is separated out into a new method right now the virtual methods exposed in the api call another virtual method to do the heavy lifting maybe it would be worth duplicating some of the logic to avoid double virtual dispatch loop code size is kinda big which can be bad for the loop buffer the logic to handle non-ascii chars should be moved to outside the loop
171412748,6757,https://api.github.com/repos/dotnet/coreclr/issues/6757,sergign60,1,0,0,0,0,0,we propose to support releasing memory that is allocated for methods that have been executed and will never be executed again or can be recompiled that is needed for devices with limited memory capacity also when gdb jit feature is enabled there is additional memory consumption bytes on arm per method with several lines for elf debugging information such memory can be released when jitted code for method itself released.the existing execution model of coreclr without releasing memory for executed code and debugging info creates serious obstacles for applications running on devices with limited memory or even can make impossible their execution in certain cases.@papaslavik brucehoult dmitri-botcharnikov leemgs lemmaa wateret
171299727,6747,https://api.github.com/repos/dotnet/coreclr/issues/6747,JosephTremoulet,4,0,0,0,0,0,"when value numbering sees an expression that is too complex runs out ofcompile-time budget for deep field/phi sequences etc it assigns vnforexpr for the expression whose value number is being computed.this produces a new unique opaque value number that will compare asequal to itself but not to any other value number.this change updates value numbering to record the location of theexpression whose value such a value numbers is created to stand in for.while attaching location information to value numbers in general must bedone with care regarding subtleties of correlating value numbers forexpressions in different locations that compute the same value thosesubtleties are not relevant in the case of these unique/opaque valuenumbers whose point is to stand in for the value of one particularexpression and whose value may be propagated by copies but will never becomputed by other redundant expressions.loop-invariant code hoisting is updated to take these locations intoaccount when determining loop-invariance the opaque value number isloop-invariant if the expression whose value it represents is outside theloop.the vnforexpr method is updated to take a basicblock to identifythe location but the backing store only records the blocks loop number,since the loop-invariance check is the only consumer of this informationand doing so allows a more compact representation in particular we avoidallocating m_defs backing storage for these value numbers since they areused for the give up and be conservative cases).the basicblock passed to vnforexpr can be nullptr to still havethe prior semantics of a fully opaque value number that cant be provedloop-invariant this is used for a handful of cases where the budgetingresults are memoized and so expressions at different locations could endup sharing opaque value numbers as well as a few cases where the vnforexpr call is covering a rare corner case in a utility for whichthe corresponding basicblock may not be handy.fixes"
171047665,6742,https://api.github.com/repos/dotnet/coreclr/issues/6742,benaadams,1,0,0,0,0,0,"adds gtcallmoreflags gtf_call_m_does_not_return to fgfindjumptargets which happens in early in pipeline which may mark the method as uninlinable so prevent the later setting in fgfindbasicblocks count the bbj_returns in fgmakebasicblocks rather than recounting afterwards perf)with current branch diff improvement summary:(note lower is better)total bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes system.private.corelib.dasm of base total files with size differences.top method regessions by size bytes system.private.corelib.dasm dictionary :system.collections.icollection.copyto(ref,int):this system.private.corelib.dasm keycollection:system.collections.icollection.copyto(ref,int):this system.private.corelib.dasm valuecollection:system.collections.icollection.copyto(ref,int):this system.private.corelib.dasm enumerator:system.collections.ienumerator.get_current():ref:this system.private.corelib.dasm readonlycollection :system.collections.icollection.copyto(ref,int):thistop method improvements by size bytes system.private.corelib.dasm error:winioerror(int,ref system.private.corelib.dasm eventprovider:writeevent(byref,long,long,ref):bool:this system.private.corelib.dasm manifestbasedresourcegroveler:handlesatellitemissing():this system.private.corelib.dasm list :copyto(int,ref,int,int):this system.private.corelib.dasm encoderexceptionfallbackbuffer:fallback(char,char,int):bool:this total methods with size differences. with from to total bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes system.private.corelib.dasm of base total files with size differences.top method regessions by size bytes system.private.corelib.dasm enumerator:system.collections.ienumerator.get_current():ref:this system.private.corelib.dasm readonlycollection :system.collections.icollection.copyto(ref,int):this system.private.corelib.dasm customattributedata:.ctor(ref,struct):this system.private.corelib.dasm dictionary :system.collections.icollection.copyto(ref,int):this system.private.corelib.dasm keycollection:system.collections.icollection.copyto(ref,int):thistop method improvements by size bytes system.private.corelib.dasm array:sort(ref,int,int,ref system.private.corelib.dasm array:lastindexof(ref,struct,int,int):int system.private.corelib.dasm array:indexof(ref,struct,int,int):int system.private.corelib.dasm error:winioerror(int,ref system.private.corelib.dasm eventprovider:writeevent(byref,long,long,ref):bool:this total methods with size differences. resolves andyayersms kyulee"
171020584,6737,https://api.github.com/repos/dotnet/coreclr/issues/6737,DemiMarie,5,0,0,0,0,0,this is a feature request to inline literal delegates passed to functions so that the il generated by fsharparray.map fun x x some_array or its c equivalent has no indirect dispatch.category:cqtheme:delegatesskill-level:expertcost:large
171020423,6735,https://api.github.com/repos/dotnet/coreclr/issues/6735,DemiMarie,1,0,0,0,0,0,this is a feature request for pattern-based optimizations such as found in the new cl.exe or in llvm.category:cqtheme:optimizationskill-level:expertcost:extra-large
170539047,6693,https://api.github.com/repos/dotnet/coreclr/issues/6693,swgillespie,2,0,0,0,0,1,this is quite a large change that introduces a new interface igcheap that abstracts away the details of the gc away from the vm the changes in this pr fall into three categories the definition of igcheap itself gcinterface.h and code motion from gc.h to gcinterface.h the public interface of the gc was moved from gc.h to gcinterface.h this includes a number of enums and macro definitions that were used throughout the vm the abstraction of alloc_context gcinterface.h alloc_context is embedded by-value into the thread class and so its layout must be known to the vm at compile-time however alloc_context also contains implementation details of the gc that cant be exposed by the interface to solve this problem gc_alloc_context is defined in gcinterface.h that provides the vm-facing interface of alloc_context including two void pointers containing gc implementation details alloc_context is defined in gc.h which contains two inline methods that reinterpret the opaque fields in gc_alloc_context as the values that the gc expects to be there today this change required renaming vm uses of alloc_context to gc_alloc_context as well as requiring a few downcasts within the gc itself whenever the gc-specific fields on gc_alloc_context are used this accounts for the majority of the changes within gc.cpp changing uses of gcheap to igcheap the vm today refers to the gc using the gcheap class so the act of introducing an interface naturally required uses of gcheap to be renamed to igcheap .while doing this work i encountered six gc interface violations that i have left in place weakreference.cpp marshalnative.cpp appdomain.cpp appdomain.cpp appdomain.cpp appdomain.cpp of these files directly reference private details of the handle table we will need to address these at some point all of the uses within appdomain.cpp are for debug asserts but the uses within weakreference.cpp and marshaknative.cpp are not.once this has been merged the next steps will be to ensure that the gc always interacts with the ee and os through gctoeeinterface and gctoosinterface respectively from there we can decouple the gc from vm internals another step that will need to be done not necessarily before or after the previous step will be to trim down igcheap until it presents the interface that wed like to exist rather than how it is today.i welcome any and all comments on this change this is the start of a large change to the gc and vm as a whole so i welcome all feedback to ensure that we are doing this in the most efficient and clean way i do not plan on merging this until we are all happy with the direction and implications of this change
170509674,6689,https://api.github.com/repos/dotnet/coreclr/issues/6689,pgavlin,0,0,0,1,0,0,"these changes implement the design for ryujits lir described in following passes required changes rationalize which has been almost completely rewritten long decomposition target-independent lowering target-dependent lowering lsra liveness flowgraph optimization codegenfor the most part these changes are confined to the backend common code that needed to be updated included liveness flowgraph optimization and a few miscellaneous utilities.the utilities used to analyze and manipulate lir live almost entirely in src/jit/lir.{cpp,h the core concepts that are unique to lir are lir::use and lir::range the latter is a tuple that captures an sdsu def i.e an lir node and its corresponding use->def edge and user the former serves to abstract a self-contained sequence of lir nodes that make up e.g the contents of a basic block.testing indicates that neither jit throughput nor code quality are significantly impacted by these changes"
170496272,6688,https://api.github.com/repos/dotnet/coreclr/issues/6688,omariom,0,0,0,0,0,5,extracted from new methods for equalitycomparer.default quoting jkotas the net native compiler for uwp does similar transformation of equalitycomparer.default.equals to reduce binary size for full aot you can see the class library side of the implementation here the compiler side of the implementation is closed source unfortunately but there is no rocket science in it this optimization would make ryujit better aot codegenerator for corert project closer to the net native compiler for uwp compiler the beauty of doing this as jit optimization is that it will kick in for all existing code without any changes
170479699,6687,https://api.github.com/repos/dotnet/coreclr/issues/6687,benaadams,0,0,0,1,0,0,code for rather than doing this csharpstring dothething(myenum argument if enum.isdefined(typeof(myenum argument log.warn return string.empty return argument.tostring();} you can do this csharpstring dothething(myenum argument if argument.isdefined log.warn return string.empty return argument.tostring();} enum.isdefined(typeof(myenum argument is also quite slow as it needs to do lots of conversion checks etc whereas if you already have the enum these dont need to be done.e.g
170462672,6684,https://api.github.com/repos/dotnet/coreclr/issues/6684,BruceForstall,1,0,0,0,0,0,see the code in morph.cpp fgmorphargs(): #if defined(_target_x defined(legacy_backend todo-x-cq revisit for small structs we should use push instruction copyblkclass objclass size roundupsize target_pointer_size normalize size to number of pointer sized items#else defined(_target_x defined(legacy_backend
170336057,6679,https://api.github.com/repos/dotnet/coreclr/issues/6679,parjong,1,0,0,0,0,0,issinglefloatstruct currently checkes whether the current handle is not avalue class handle or it has more than one field.if not it proceeds to the next step that checks the type of each fields.unfortunately if the current handle is not a value class but has onefield somehow getfieldinclass failed with the assertion discussed in this commit tries to fix this invalid terminating condition
170308886,6676,https://api.github.com/repos/dotnet/coreclr/issues/6676,jashook,1,0,0,0,0,0,the arm emulator is building copying and running entirely on the machines tmp drive we can switch this over to a temp directory on another drive mnt this will speed up the build and keep the space issues from happening often.in addition there needs to be more cleanup for arm emulator jobs error writing /home/coreclr/windows_nt.x.debug/tests/coreoverlay/mscorlib.dll no space left on device
170257976,6672,https://api.github.com/repos/dotnet/coreclr/issues/6672,kspawa,2,0,0,0,0,0,for the full net framework we have the gac where most of the profiler assemblies exist so that they are available for use in all apps for net core we need to have a design such that there is either a common place or some other solution available to profiler writers so that they do not have to jump through a lot of hoops to make their assemblies available to all applications noahfalk please add any more details in case you have thoughts on the design
170039672,6661,https://api.github.com/repos/dotnet/coreclr/issues/6661,jamesqo,4,0,0,0,0,0,separated out from the discussion in currently the jit makes a helper call to jit_memcpy for non-constant sizes if it could generate rep movsb inline instead for amd/x that would be much more efficient doing this would allow for a better implementation of buffer.memorycopy which right now has xmm as the best thing available.category:cqtheme:block-optsskill-level:intermediatecost:medium
169991420,6653,https://api.github.com/repos/dotnet/coreclr/issues/6653,echesakovMSFT,16,0,0,13,0,6,work towards objects stack allocation moved allocation part of newobj-lowering into separate phase introduced gt_allocobj node to mark places where object allocation happens in importer.cpp changed lowering of allocation part of newobj instruction from an allocation helper call to a gt_allocobj node creation created new phase objectallocator phase_allocate_objects and put it right after dominator computing we will need the information for escape analysis current implementation of objectallocator walks over all basic blocks having flag bbf_has_newobj set and replaces gt_allocobj with an allocation helper calli did coreclr testing and throughput measurement we have one assembly diff an improvement related to deleting unreachable basic blocks throughput remains the same.@erozenfeld ptalcc dotnet/jit-contrib
169886634,6648,https://api.github.com/repos/dotnet/coreclr/issues/6648,adamsitnik,2,0,0,0,0,0,hello!@jkotas krzysztofcwalina could you review the code and tell if everything is ok before i implement set method and copy the code for readonlyspan?jan i have seen that you added some basic tests for span but it seems that they are not executed during build with tests included could you add it to the spanoft branch or tell me how can i quickly execute this tests
169816241,6647,https://api.github.com/repos/dotnet/coreclr/issues/6647,jamesqo,4,0,0,2,0,0,crossgen currently doesnt generate sse instructions of any kind for x which was causing issues in when i was attempting to use it with and-larger byte types this change enables it to use sse instructions dropping support for processors that dont support that. here is the gist that results when i dump the disassembly of every method in the system.private.corelib native image and grep for xmm .notes according to wikipedia pentium which is targeted for the framework already supports sse so theres no reason not to enable this for the framework the region ifdefd under feature_coreclr seems to target pentium pro released in an older processor than pentium since this has no support for sse i just deleted this and retargeted it to pentium removed ifndef for coreclr that contained a call to getspecificcpuinfo which is presumably querying the actual processors features at runtime is there any reason this wasnt enabled before?cc jkotas benaadams tannergooding mikedn
169806681,6645,https://api.github.com/repos/dotnet/coreclr/issues/6645,benaadams,25,0,0,12,0,0,reduces allocations by increases performance by x over m per sec on single thread.with these changes tostring no longer boxes the value and doesnt create an empty array for customattributerecords when the enum is not flagged also caches whether the enum is flagged skipping the reflection per call).it still boxes the enum to enum to make the tostring virtual call however.using the jkotas enummark wink csharpenum myenum one two three four five six seven eight nine ten public static void main(string args myenum.seven).tostring int start environment.tickcount for int i i i myenum.seven).tostring int end environment.tickcount console.writeline((end start).tostring());} pre ms ms ms m/s)post ms ms ms m/s)allocations pre post in run are the same just differ in images from profiling start stop pointsresolves
169790304,6642,https://api.github.com/repos/dotnet/coreclr/issues/6642,omariom,1,0,0,0,0,0,almost two thousand errors complaining about constexpr c:\program files x)\windows kits\\include\...\um\shlwapi.h error c illegal statement or sub-expression for constexpr function c:\dev\git\forks\coreclr\bin\obj\windows_nt.x.checked\src\debug\ee\dac\cordbee_dac.vcxproj
169726666,6638,https://api.github.com/repos/dotnet/coreclr/issues/6638,jamesqo,2,0,0,0,0,0,this is a follow-up to since that was accidentally merged ive experimented with tannergoodings idea of doing word writes at the beginning/end of the buffer before actually aligning dest which shaves off a couple of branches and seems to improve performance.this is the performance data i have for now the gist will be updated continually you need to press ctrl+f and search for baseline to see the times for the existing version the one that just got merged).during the other pr i was unable to get consistent timings between benchmark runs and benchmarkdotnet takes waaay too long so what ive done instead is run the tests multiple times and see which numbers keep popping up here are the average times for each configuration of bytes baseline experimental note that this should not be merged yet as i havent tested for i and have not collected data for when dest is unaligned also im thinking of possibly raising the threshold for when we do a qcall into the native memmove since copying bytes seems to be significantly faster than see my comment in the other pr).cc jkotas tannergooding gspp benaadams
169708568,6634,https://api.github.com/repos/dotnet/coreclr/issues/6634,benaadams,2,0,0,0,0,0,"with the introduction of do not inline methods that never returnthese changes reduce the code gen size of the jitted methods regular and generic n for array and arraysegment and a bunch of other generic types)also results in a kb reduction int the size of system.private.corelib native windows_nt.x.release). pre system.private.corelib.dll bytespost system.private.corelib.dll bytespre system.private.corelib.ni.dll bytespost system.private.corelib.ni.dll bytes byte reduction total bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes system.private.corelib.dasm of base total files with size differences.top method regessions by size bytes system.private.corelib.dasm customattributedata:.ctor(ref,struct):this system.private.corelib.dasm customattributedata:init(ref):this system.private.corelib.dasm timespan:tryparseexact(ref,ref,ref,byref):bool system.private.corelib.dasm datetimeparse:parsebyformat(byref,byref,byref,ref,byref):bool system.private.corelib.dasm datetimeformat:formatcustomized(struct,ref,ref,struct):reftop method improvements by size bytes system.private.corelib.dasm array:sort(ref,int,int,ref system.private.corelib.dasm array:lastindexof(ref,struct,int,int):int system.private.corelib.dasm array:indexof(ref,struct,int,int):int system.private.corelib.dasm array:binarysearch(ref,int,int,struct,ref):int system.private.corelib.dasm comparer :create(ref):ref total methods with size differences. one of the big wins other than the included throw code is smaller bytes of il to bytes is it prevents all the inlining of environment:getresourcestring(ref):ref e.g.pre inlines into e arraysegment :.ctor(ref,int,int):this il tr failed unprofitable inline argumentnullexception:.ctor(ref):this il tr f below always_inline size environment:getresourcestring(ref):ref il tr f failed unprofitable inline environment:getresourcestringlocal(ref):ref il tr aee failed unprofitable inline argumentoutofrangeexception:.ctor(ref,ref):this il tr f below always_inline size environment:getresourcestring(ref):ref il tr f failed unprofitable inline environment:getresourcestringlocal(ref):ref il tr aee failed unprofitable inline argumentoutofrangeexception:.ctor(ref,ref):this il tr f below always_inline size environment:getresourcestring(ref):ref il tr f failed unprofitable inline environment:getresourcestringlocal(ref):ref il tr ea failed unprofitable inline argumentexception:.ctor(ref):thisbudget initialtime finaltime initialbudget currentbudget=budget initialsize finalsize= post inlines into ab arraysegment :.ctor(ref,int,int):this il tr cf failed does not return throwhelper:throwargumentnullexception(int il tr c failed noinline per il/cached result throwhelper:throwargumentoutofrangeexception(int,int il tr c failed noinline per il/cached result throwhelper:throwargumentoutofrangeexception(int,int il tr cd failed noinline per il/cached result throwhelper:throwargumentexception(int)budget initialtime finaltime initialbudget currentbudget=budget initialsize finalsize= which will be repeated for each new generic"
169687764,6631,https://api.github.com/repos/dotnet/coreclr/issues/6631,erozenfeld,1,0,0,0,0,0,"added a null check folding optimization to early prop the optimization tries to fold gt_nullcheck(y nodes into gt_ind(x nodes where x=y+const in the same block where const is sufficiently small the algorithm uses ssa use-def info to go from x to its def and then tries to match the pattern x comma(nullcheck(y add(y const if such a pattern is found the algorithm checks the trees and statements that are between the use and the def in execution order to see if they have unsafe side effects calls exception sources and assignments all assignment if we are in a try and assignments to global memory if we are not if there are no nodes with unsafe side effects the null check is removed made several improvements to null check elimination in assertion propagation added a new kind for op ok_value_number non-null assertions can now be made about arbitrary value numbers not just locals fixed code that was trying to find a ref given a byref the code now handles an arbitrary number of offsets and checks whether the total offsetof is small enough added similar code that tries to find a ref vn given a byref vnthis addresses part of the suboptimal code generated for null check is no longer emitted.correctness ran full desktop and coreclr testing.throughput no measurable throughput impact verified by running internal cqngentp several times).code size in coreclr:framework assemblies:total bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes system.private.corelib.dasm of base microsoft.codeanalysis.csharp.dasm of base microsoft.codeanalysis.dasm of base system.numerics.vectors.dasm of base system.xml.xmldocument.dasm of base total files with size differences.top method improvements by size bytes system.numerics.vectors.dasm system.numerics.matrixx:tostring():ref:this system.private.corelib.dasm system.datetimeparse:parsebyformat(byref,byref,byref,ref,byref):bool microsoft.codeanalysis.csharp.dasm getmethodstoemit>d__:movenext():bool:this system.private.corelib.dasm system.datetimeparse:lex(int,byref,byref,byref,byref,byref,int):bool system.private.corelib.dasm system.datetimeparse:processdatetimesuffix(byref,byref,byref):bool total methods with size differences.jit code quality benchmarks in coreclr:total bytes of diff of base diff is an improvement.total byte diff includes bytes from reconciling methods base had unique methods unique bytes diff had unique methods unique bytestop file improvements by size bytes bytemark\bytemark\bytemark.dasm of base benchmarksgame\pidigits\pi-digits\pi-digits.dasm of base total files with size differences.top method improvements by size bytes bytemark\bytemark\bytemark.dasm assignjagged:second_assignments(ref,ref bytemark\bytemark\bytemark.dasm emfloat:multiplyinternalfpf(byref,byref,byref bytemark\bytemark\bytemark.dasm emfloat:addsubinternalfpf(ubyte,byref,byref,byref bytemark\bytemark\bytemark.dasm emfloat:denormalize(byref,int bytemark\bytemark\bytemark.dasm emfloat:divideinternalfpf(byref,byref,byref total methods with size differences.in internal spmi methods with diffs almost everything code size improvements bytes code size reduction overall on affected methodscq_perf methods with diffs code size improvements no regressionsbenchmarks with code size diffs:roslyn truetypebench mono-pi-digits mono-chameneos-redux bytemark\assign_jagged json_serialize sharpchess benchi\mulmtx internal cqperf didnt report any runtime wins for these benchmarks"
169620970,6627,https://api.github.com/repos/dotnet/coreclr/issues/6627,jamesqo,2,0,0,0,0,0,in buffer.memorycopy currently we are making writes every time we copy some data to update dest to update dest to update src and to update len ive decreased it to one to update a new local variable i which keeps track of how many bytes we are into the buffer all writes are now made using cs*(dest i x src i x) which has no additional overhead since theyre converted to using memory addressing operands by the jit.another change i made was to add a few extra cases for the switch-case at the beginning that does copying for small sizes without any branches it now covers sizes this is beneficial to the main codepath since we can convert the unrolled loop to a do..while loop and save an extra branch at the beginning max bytes for alignment for iteration of the loop so the min bytes we can copy without checking whether we should stop is this adds this pr increases the performance of memorycopy by for most buffer sizes on x you can see the performance test/results and the generated assembly for each version here note that this codepath is also used by wstrcpy at the moment so this directly affects many common string operations.)note that i havent tested this on arm or anything only i and x so im not sure how these changes will affect other platforms.i have yet to write up tests for this in corefx but i will later when i get the time.cc jkotas nietras mikedn gspp omariom bbowyersmyth
169463509,6612,https://api.github.com/repos/dotnet/coreclr/issues/6612,vancem,1,0,0,0,0,0,so you have one link to go to that represents the entire book
169424755,6603,https://api.github.com/repos/dotnet/coreclr/issues/6603,jamesqo,1,0,0,0,0,0,currently there are a lot of overloads of string.compare that feature needless code duplication this pr removes some of that and in the process optimizes some overloads as theyre able to now short-circuit for things like reference equality where they didnt before
169386449,6600,https://api.github.com/repos/dotnet/coreclr/issues/6600,JeppeSN,1,0,0,0,0,0,the method attribute.getparentdefinition(parameterinfo in the file mscorlib/src/system/attribute.cs contains the following lines find the parameterinfo on this method parameterinfo parameters rtmethod.getparameters return parameters param.position point to the correct parameterinfo of the method as discussed in this fails if param is a return parameter these give a position of not suitable for indexing into an array.the fix is easy find the parameterinfo on this method if param.isretval return rtmethod.returnparameter;}parameterinfo parameters rtmethod.getparameters return parameters param.position point to the correct parameterinfo of the method please make a pull request on this change./jeppesn
168914029,6572,https://api.github.com/repos/dotnet/coreclr/issues/6572,JosephTremoulet,3,0,0,0,0,0,the inliners restriction that methods that make use of the starg opcodecannot be inlined is somewhat artificial the comments indicate that thereason for this excluion is because the inliner forward-substitutesargument expressions in place of parameter references but the codepathsrequired to force evaluating an argument expression at the callsite andreference that result in place of parameter references is already in placeto handle ldarga and complex argument expressions.this change adds an arghasstargop flag to the inlarginfo type similar to the existing arghasldargaop flag removes the callee_stores_to_argument inline observation and instead sets the new flag for starg cases updates impinlinefetcharg to force evaluation to a temp for arguments that are marked arghasstargop updates starg processing in the importer to store to the corresponding temp when importing for an inlineeresolves
168484677,6541,https://api.github.com/repos/dotnet/coreclr/issues/6541,GSPP,1,0,0,0,0,0,the documentation should be clarified this method copies sourcebytestocopy bytes from the address specified by source to the address specified by destination if the buffers overlap and the difference between destination minus source is less than sourcebytestocopy the source block is copied to the destination block in reverse order.it is not clear what reverse order means i understood that part only because im familiar with the overlapping buffers problem with memcpy also buffers overlap is unclear because nowhere is it defined what a buffer is we are talking about ranges of addresses here interpreting them as a buffer is out of scope for this api the wording could be memory regions specified by source and sourcebytestocopy as well as destination and destinationsizeinbytes or it could be what the native version says.i would have suggest a text but i wasnt sure if i was causing any licensing issues with that id be willing to contribute a documentation fix if this is helping please clarify what a negative length or a negative destination size cause is that valid what does it do im actually unclear on what the function is supposed to do it behaves differently depending on whether src and dest are ascending or descending in memory where the ranges overlap in both cases the behavior deviates from native memmove is this supposed to happen if no its a bug if yes the documentation should spell that out static unsafe void memorycopytest var bytestocopy var array new byte fixed byte arrayptr array memorycopy(arrayptr arrayptr bytestocopy bytestocopy console.writeline(bitconverter.tostring(array var array new byte fixed byte arrayptr array memmove(arrayptr arrayptr bytestocopy console.writeline(bitconverter.tostring(array dllimport(msvcrt.dll setlasterror false static unsafe extern intptr memmove(void dest void src int count the output is different because the check if ulong)dest ulong)src len goto pinvoke is sometimes false sometimes true and if its false the unsafe managed version behaves questionably.ideally the function would mirror memmove .maybe its a good solution to call the bytewise managed loop for small overlapping buffers for big overlapping buffers call the native code
168483529,6540,https://api.github.com/repos/dotnet/coreclr/issues/6540,GSPP,1,0,0,0,0,0,according to my code review buffer.memorycopy executes int dest int src this will be an unaligned access if one of the pointers is not byte aligned im not sure about the performance implications on x on arm this allegedly faults i cant test on arm so i thought id report it to have this reviewed.if this is ok a comment should be added explaining why
168452002,6537,https://api.github.com/repos/dotnet/coreclr/issues/6537,jamesqo,6,0,0,0,0,0,in c youre allowed to have covariant arrays if one type is a subclass of another this can lead to runtime exceptions if you attempt to write an element that doesnt subclass the underlying type e.g csstring strings object objects strings no copying direct assignmentobjects new object runtime exception! since we know this is never going to happen for sealed classes like string or stringbuilder e.g if you write a string to a string it will always be valid it would be nice to elide these checks for such classes minimal repro code csvar array new string ;array str; generated assembly asmg_m_ig baafdf mov rcx xffdaa ba mov edx ecdf call corinfo_help_newarr__obj bc mov rcx rax bf mov r xf db mov r gword ptr r d xor edx edx ebdf call corinfo_help_arraddr_st nop corinfo_help_arraddr_st is the method that does type-checking before writing to the array.i was recently rewriting string.concat to use pooled arrays and even with all of the array/string allocations fillstringchecked overhead virtual method calls to tostring this call takes up about of the time in the method its increased to more than with the array allocations taken out.)it would be awesome if ryujit could eliminate calls to that method for sealed types cc mikedn caroleidt jkotas omariomcategory:cqtheme:helpersskill-level:expertcost:medium
168449984,6536,https://api.github.com/repos/dotnet/coreclr/issues/6536,HZH1907,4,0,0,0,0,0,"refusing to link openssllinking keg-only openssl means you may end up linking against the insecure,deprecated system version while using the headers from the homebrew version.instead pass the full include/library paths to your compiler e.g.:-i/usr/local/opt/openssl/include l/usr/local/opt/openssl/lib"
168429881,6535,https://api.github.com/repos/dotnet/coreclr/issues/6535,dagood,1,0,0,0,0,0,changes the type of warning seen in into an error so it wont get reintroduced the warnings were fixed in by upgrading to netcoreapp. .i wouldnt say this is a fix for because there are still other warnings but its a step.)/cc russkeldorph ericstj
168259467,6524,https://api.github.com/repos/dotnet/coreclr/issues/6524,OzieGamma,16,0,0,0,0,0,hi i dont know i this has been asked somewhere already so please forgive me if it does my search didnt find any results this might been similar have been using c and vb.net for a few years and for me what makes those languages incredible is tooling but also the fact that you can produce both quite low-level code and very abstract code.the functional programming paradigm has enabled non-performance-critical oriented developers to avoid many pitfalls and to reuse code languages such as scala f or c have proven that it can be combined successfully with an oop approach.unfortunately c doesnt support higher kind polymorphism and this apparently comes from the clr not supporting it see would enable programmers languages to write functions such as: public static t(this ienumerable
168152543,6505,https://api.github.com/repos/dotnet/coreclr/issues/6505,KrzysztofCwalina,0,0,0,1,0,0,we need the new compiler feature to make progress on span
167768522,6484,https://api.github.com/repos/dotnet/coreclr/issues/6484,CarolEidt,1,0,0,0,0,0,and validate that only valid assumptions are utilized
167488437,6465,https://api.github.com/repos/dotnet/coreclr/issues/6465,jamesqo,0,0,1,0,0,0,string.compare has some logic to short-circuit if the strings its comparing are equal and the indices are equal except it looks like its calling strings overload of instead of a reference comparison probably hasnt been discovered before since if strings are ordinally equal then they should be equal for all the other types currentculture invariantculture ignorecase etc as well.im going to submit a pr soon which includes a fix for this anyway but i just wanted to let people know/confirm that this wasnt intentional.cc jkotas bbowyersmyth gspp
167216119,6439,https://api.github.com/repos/dotnet/coreclr/issues/6439,elisee,1,0,0,0,0,0,hi this is a quick proposal for a new function for fast raw initialization of memory. buffer.blockcopy provides an equivalent to memcpy for fast raw copy a buffer.blockset function to mirror memset for fast raw initialization would be useful especially for gamedev where we work with a lot of arrays with primitive types vertex data level data etc.)it seems to be currently possible using dynamic il generation tricks and the initblk opcode but having it built-in would be very nice
167182576,6430,https://api.github.com/repos/dotnet/coreclr/issues/6430,jkotas,1,0,0,0,0,0,inword
167129316,6418,https://api.github.com/repos/dotnet/coreclr/issues/6418,rahku,1,0,0,0,0,0,do not insert gcstress interrupt instruction at call to jit_raredisablehelper this change is for arm similar change has already been done for x/x as part of pr see pr for details of this fix
167027832,6409,https://api.github.com/repos/dotnet/coreclr/issues/6409,yorickdewid,0,0,0,0,1,0,as reported earlier in cmake fails due to a missing source file in the objects folder this is not related to arm and seems to occur on debian cmake error at functions.cmake add_library cannot find source file coreclr/bin/obj/linux.x.debug/version.cpp tried extensions c c c cc cpp cxx m m mm h hh h hm hpp hxx in txxcall stack most recent call first src/corefx/system.globalization.native/cmakelists.txt add_library build files have been written to coreclr/bin/obj/linux.x.debug this is possible related to the msbuild.exe error shown before the failure
167022105,6408,https://api.github.com/repos/dotnet/coreclr/issues/6408,jnm2,1,0,0,0,0,0,because timerinfo->firingtime is set to currenttime timerinfo->period instead of timerinfo->firingtime timerinfo->period drift could happen when currenttime and timerinfo->firingtime are different what could cause them to be different the thread sleep might not get back exactly at the requested nextfiringinterval .this means that firetimers runs when one timer is expired but potentially a little later it runs at time timerinfo->firingtime sleepdelta where sleepdelta is the amount of time later than planned that it is scheduled and runs due to the previous thread sleep at time timerinfo->firingtime sleepdelta currenttime gettickcount is taken that means currenttime timerinfo->firingtime sleepdelta then each time the timer does fire timerinfo->firingtime currenttime+timerinfo->period substituting currenttime timerinfo->firingtime timerinfo->firingtime sleepdelta timerinfo->period .it would be nice if the timer itself was rock-solid im curious why the team didnt go with timerinfo->firingtime timerinfo->period .here it seems that sleepex is expected to be within ms or for longer intervals test.c that doesnt make me feel better about the delay between the timers planned expiry time and executing currenttime gettickcount i dont want my timers to be expected to drift up to ms or of the interval on every tick.thanks
166701472,6366,https://api.github.com/repos/dotnet/coreclr/issues/6366,pgavlin,0,0,0,1,0,0,this document describes a proposal which we intend to implement thatremoves embedded statements from the ryujit ir
165948818,6303,https://api.github.com/repos/dotnet/coreclr/issues/6303,mikedn,3,0,0,0,0,0,consider the following example c#using system;using system.runtime.compilerservices;class program methodimpl(methodimploptions.noinlining static void use(int x static void main var r new random int x r.next int y r.next int z r.next for int i i i use(x y z the x*y*z expression is invariant but it is not hoisted: g_m_ig bcf mov ecx edi fafcb imul ecx ebx fafce imul ecx esi efbffff call program:use(int ffc inc rd fea cmp rd cea jl short g_m_ig as far as i can tell this happens because the jit cant detect that x y and z themselves are invariant there doesnt seem to exist a vn function application for random.next calls and without that there seems to be no way to tell where a particular vn was defined outside the loop in this case
165655597,6285,https://api.github.com/repos/dotnet/coreclr/issues/6285,JosephTremoulet,3,0,0,0,0,0,earlyprop limits its propagation of array lengths to blocks markedbbf_has_indx for throughput reasons the importer sets that flag onblocks that store/load array elements but not blocks that simply extractan arrays length this change renames the flag to bbf_has_idx_len andupdates the importer to set it also on blocks with ldlen operations thischange also updates fgoptwhileloop to propagate the flag when itcopies such an expression as part of a zero-trip test.fixes this change has diffs in corelib none in the other core framework dlls and more in superpmi all diffs checked exhaustively in corelib and spot-checked elsewhere are length loads replaced with constants or length loads feeding compares where the whole load compare and conditional chunk of code have been removed.this change has no diffs in benchstones or benchmarks game we may want to start tracking forceinline variants where we make sure the inner routines are inlined into the context where the array creations are in scope.runs of cqngentp indicate throughput impact within noise range.@dotnet/jit-contrib ptal
165607470,6278,https://api.github.com/repos/dotnet/coreclr/issues/6278,Dmitri-Botcharnikov,3,0,0,0,0,3,this pr adds generation of source line debug information according to gdb jit interface for using with lldb see the feature is enabled by providing its own flag to cmake i.e build.sh cmakeargs dfeature_gdbjit=true it also requires the latest symbolreader managed dll to work dotnet/corefx#).the jit notification is generated at the same time as the dac notification in dacnotify::dojitnotification so when managed breakpoint is requested by bpmd command the source lines are displayed on break when available. (lldb bpmd test.exe test.mainadding pending breakpoints...(lldb cprocess resuming location added to breakpoint lldb jitted test!test.main()setting breakpoint breakpoint set address xafb test.main() process stopped thread tid xafb jit(xbc at test.cs name corerun stop reason breakpoint frame xafb jit(xbc at test.cs static int main dumpil likelyinlined unlikelyinlined(); the current implementation requires source files in current directory and portable pdb in original or current directory.tested in linux/x and linux/arm environments
165549831,6275,https://api.github.com/repos/dotnet/coreclr/issues/6275,ayende,6,0,0,0,0,0,consider the following code var str items string.join enumerable.range select(i var jobject jobject.parse(str); this generates a string that is kb in size but parsing it using json.net takes about kb this specific example is something that we run into where a specific code path got us to allocate so much memory we started swapping and the machine died.the problem is that there is really no way for us to protect against that.it would be nice if we had a way to limit allocations in particular times so we can say okay im allowing this thread to allocate in this scope up to mb or even just to get the amount of allocations that were done in a thread between two points
165413654,6261,https://api.github.com/repos/dotnet/coreclr/issues/6261,BruceForstall,1,0,0,0,0,0,primarily this will commonize code with x and reduce ifdefs but will also improve amd cq.related to
165252031,6251,https://api.github.com/repos/dotnet/coreclr/issues/6251,BruceForstall,2,0,0,0,0,0,fixes change ryujit to generate localloc code for x the same way legacy jit does.e.g use a push/dec loop for initialized memory and avoid using sub espto keep the emitter from tracking stack pointer adjustments.@adiaaida briansull ptalcc dotnet/jit-contrib
165119211,6237,https://api.github.com/repos/dotnet/coreclr/issues/6237,gafter,3,0,0,0,0,0,it is an invariant that two objects for which o.equals(o their hash codes should agree i.e o.gethashcode o.gethashcode see the specification which says two objects that are equal return hash codes that are equal.this invariant is assumed by many apis that use these methods and any types that fail to satisfy them are broken and cannot be expected to work with the core apis however the implementation for double does not satisfy this invariant specifically the following snippet of code prints true false cs object o double.nan object o double.nan console.writeline(o.equals(o console.writeline(o.gethashcode o.gethashcode
164739169,6212,https://api.github.com/repos/dotnet/coreclr/issues/6212,jamesqo,1,0,0,0,0,0,right now list.contains calls equalitycomparer.default.equals in a loop to check if the list contains the item which will result in n virtual method calls to equals if there are n items in the list a more efficient way to do this is to call array.indexof and check if its since internally that calls equalitycomparer.indexof which is an internal virtual method in equalitycomparer specialized for all the default comparers this way we only make virtual call to equalitycomparer.indexof instead of n.similar to dotnet/corefx which applies this optimization for stack performance results old new test source code with the other pr if the element is found in the first item of the list the new implementation is slightly slower if its found at the nd or rd position the times are about the same the new impl is about x faster for the th position and in extreme cases or not depending on how big typical lists are the new implementation can be more than x faster.ive pre-tested this with corefx and everything is passing in system.collections.tests .@jkotas stephentoub ptal edit note that this will not result in too big of a performance degradation for null items e.g if you do list.contains(null you wont be making virtual calls in a loop where you hadnt before since each of the specialized implementations of indexof for each of the equality comparers check for null hasvalue and still do plain if array i null if the parameter is null as opposed to calling equals
164625431,6195,https://api.github.com/repos/dotnet/coreclr/issues/6195,rahku,1,0,0,0,0,0,sos for windows x seems to have stopped working after commit in particular bpmd command no longer works it always prints the following message bpmd a.exe program.mainfile name:line number not supportedusage bpmd md usage bpmd nofuturemodule usage bpmd usage bpmd listusage bpmd clear usage bpmd clearallsee help bpmd for more details is the cause of the error it seems we are calling g_extsymbols->getmodulebymodulename with module name as coreclr.dll otherplaces where the api is called it does not append dll to the name such as here main_clr_dll_name_a to main_clr_module_name_a fixes the problem on windows x linux however expects full name of library also report correct error message
164444730,6181,https://api.github.com/repos/dotnet/coreclr/issues/6181,leemgs,2,0,0,0,0,0,"as we all know there are a lot of abbreviations as terminology in coreclr/src folder where we can find the the original meaning of the abbreviations?while browsing the source codes of coreclr to enable net core on linux arm i often wonder about the meaning of the abbreviations if there are not a related documentation,i would like to create terminology file in coreclr folder how about we append the file to keepthe existing(and new terminologies for example botr book of the runtimeclasslibnative native class library coreclr core common language runtimedac data access componentgc garbage collectorilasm intermediate language assemblerildasm intermediate language disassemblerjit just-in-timemscorlib microsoft core librarynativeresources native resourcesnig native image generatorpal platform adaptation layerpalrt platform adaptation layers run-timepe portable executable vm virtual machinetoolbox binder corefx debug dlls gcdump gcinfo inc ipcman md scripts strongname tools unwinder utilcode zap and so on"
164411098,6172,https://api.github.com/repos/dotnet/coreclr/issues/6172,pgavlin,1,0,0,0,0,0,"if the following program is compiled with optimizations enabled e.g the o flag is provided on the csc command line ryujit will drop the volatile read of a : using system.runtime.compilerservices;static class c static volatile int a static int b methodimpl(methodimploptions.noinlining static void lightweightstorefence a var dummy a b static void main lightweightstorefence   the il as reported by a jit dump is: il ldc.i il fe volatile il stsfld xil fe volatile il_a e ldsfld xil_f pop il ldc.i il stsfld xil a ret   the generated assembly is: g_m_ig func offs=h size=h gcrefregs byrefregs byref nogc prolog igg_m_ig offs=h size=h gcrefregs byrefregs byrefin mov dword ptr reloc classvar xda in a mov dword ptr reloc classvar xda g_m_ig offs=h size=h epilog nogc emitaddin ret   from the dump it appears that the importer drops the volatile ldsfld on the floor when it imports the pop instruction this is not correct per the ecma spec which states that volatile operations may not be removed or coalesced.thanks to omariom for reporting the original issue in category:correctnesstheme:volatileskill-level:expertcost:medium"
164149840,6153,https://api.github.com/repos/dotnet/coreclr/issues/6153,adamsitnik,1,0,0,0,0,0,hello everybody!i am writing a code that needs to check whether given dll was optimized or not the best way to do it in classic desktop clr is to check if given assembly has attribute debuggableattribute with isjitoptimizerdisabled false .the problem is that system.runtime does not expose this public property which is implemented anyway you expose this methods if so then is my pr enough to get it working
164139993,6149,https://api.github.com/repos/dotnet/coreclr/issues/6149,justinvp,1,0,0,0,0,0,the current implementation calls string.concat(object object object which results in a box allocation.avoid the box allocation by calling long.tostring allowing string.concat(string string string to be used
164132295,6148,https://api.github.com/repos/dotnet/coreclr/issues/6148,justinvp,1,0,0,0,0,0,the current implementation calls string.concat(object object which results in a box allocation.avoid the box allocation by calling int.tostring allowing string.concat(string string to be used
164031115,6137,https://api.github.com/repos/dotnet/coreclr/issues/6137,papaslavik,2,0,0,0,0,0,the soft fp is implemented using the varargs related existing code which uses pre-spilling.it doesnt make sense to pre-spill the integer arguments for soft fp so we added the fix.(moreover any pre-spills are not just causing the additional push instructions the pre-spilled local variables will get the stack slots which then will be updated after any manipulations with the variable which leads to a lot of surplus st and ld operations this suggests re-writing soft fp support in the future to reduce the code size and the execution time
163979573,6132,https://api.github.com/repos/dotnet/coreclr/issues/6132,benaadams,1,0,0,0,0,0,from thread count native costs high in threadpoolmgr::workerthreadstart cores ht cores cores
163966261,6131,https://api.github.com/repos/dotnet/coreclr/issues/6131,sivarv,1,0,0,0,0,0,issue is a related issuecategory:cqtheme:register-allocatorskill-level:expertcost:large
163755566,6115,https://api.github.com/repos/dotnet/coreclr/issues/6115,josh-endries,2,0,0,0,0,0,is there any work underway to create a freebsd ports system port and/or package of coreclr/.net i havent found much online only that its allegedly possible to build coreclr on freebsd i havent succeeded in that yet but nothing about a port the runtime page doesnt list freebsd this would virtually eliminate any barrier to entry and make it much easier/standardized to administer.note that this isnt the same port as referenced by this issue
163661365,6111,https://api.github.com/repos/dotnet/coreclr/issues/6111,scottdorman,2,0,0,0,0,0,when trying to port an existing application that uses decimal.round you get the following error or a variation of it error cs decimal does not contain a definition for roundthe method exists in the source but they arent exposed for some reason this appears to be similar to and is something that would fall under the notion of api convergence
163523032,6103,https://api.github.com/repos/dotnet/coreclr/issues/6103,mikedn,6,0,0,2,0,0,methods that do not contain return blocks cant ever exit normally they either throw or loop indefinitely inlining is not beneficial in such cases as it increases the code size without providing any speed benefits in the particular case of throws the inlined code can easily be times larger than the call site.the call to fgmorethanonereturnblock has been replaced with code that does the same thing but also detects the existence of at least one return block this avoids walking the basic block list twice.note that bbj_return blocks are also generated for cee_jmp methods exiting via cee_jmp instead of cee_ret will continue to be inlined assuming they were inlined before this change
163495304,6101,https://api.github.com/repos/dotnet/coreclr/issues/6101,BruceForstall,0,0,0,1,0,0,this change implements the necessary x support in ryujit for exception handling.it removes the eh-related nyi the number of nyi fallbacks in an x test run dropsby about there are new asserts which are now suppressed appear to benew and are new instances of existing known asserts.the various changes are implement code generation for bbj_callfinally/bbj_always blocks for invoking a finally.this requires appropriately modifying the shadowsp slot structure before the call implement bbj_ehfinallyret/bbj_ehfilterret control transfer the related gt_retfiltcode was already implemented implement gt_end_lfin for handling return-from-finally cleanup namely clearing theappropriate slot in the shadowsp structure
162773994,6034,https://api.github.com/repos/dotnet/coreclr/issues/6034,adiaaida,0,0,0,1,0,0,this will have several steps massage the code to prepare it for a full clang-format run build scripts for dev use to run clang-format for checkins run clang-format over all jit code
162649046,6027,https://api.github.com/repos/dotnet/coreclr/issues/6027,janvorli,1,0,0,0,0,0,there was a bug in the context translation between the windows contextand unix context on amd caused by the fact that the unix contextgregs array contains cs gs and fs in a single field reg_csgsfs andthe mcreg_segcs accessor macro was incorrectly written to use thewhole field as cs so writing the cs into the unix context alsocleared the gs fs and the topmost bits described as padding.this issue was exposed on the linux kernel where the paddingfor some reason was not zero probably used by the kernel for someinternal purposes.i have fixed it by changing the accessor to modify only the bitscorresponding to the cs.i have also changed the code in the inject_activation_handler tosave cycles and not to copy the windows context back to the unix onein case the activation function was not called and so the contextwas not possibly changed
162580300,6022,https://api.github.com/repos/dotnet/coreclr/issues/6022,BruceForstall,3,0,0,0,0,0,"most in a default x debug build are of the form: your project is not referencing the netcoreapp,version=v framework add a reference to netcoreapp,version=v in the frameworks section of your project.json and then re-run nuget restore"
162523203,6016,https://api.github.com/repos/dotnet/coreclr/issues/6016,janvorli,1,0,0,0,0,2,we get sigsegv in the gc when trying to allocate managed objects
162282351,6001,https://api.github.com/repos/dotnet/coreclr/issues/6001,GSPP,2,0,0,0,0,0,heres a micro benchmark to test the performance effect of an exception handler the handler is never executed its just there static void main var outeriterationcount var inneriterationcount use a high value so that the handler is entered rarely var sw stopwatch.startnew handler(outeriterationcount inneriterationcount sw.stop console.writeline($handler sw.elapsed.totalmilliseconds:f}ms var sw stopwatch.startnew handler(outeriterationcount inneriterationcount sw.stop console.writeline($handler sw.elapsed.totalmilliseconds:f}ms static void handler(int outeriterationcount int inneriterationcount unchecked uint result for int iouter iouter outeriterationcount iouter try for int iinner iinner inneriterationcount iinner result xfefe dummy work that is not optimized out result xdfc catch exception ex gc.keepalive(result sink result static void handler(int outeriterationcount int inneriterationcount unchecked uint result for int iouter iouter outeriterationcount iouter for int iinner iinner inneriterationcount iinner result xfefe dummy work that is not optimized out result xdfc gc.keepalive(result sink result handler mshandler ms the slowdown is quite severe x inspecting the disassembly i see that the inner loop in handler spills to the stack after each arithmetic operation this is so strange and undesirable that im reporting this as a bug.this is net desktop x release no debugger attached.category:cqtheme:ehskill-level:expertcost:extra-large
162126368,5988,https://api.github.com/repos/dotnet/coreclr/issues/5988,sam-baravy,0,0,0,1,0,0,init-tools.sh tries to compare strings like this if os==osx then echo raising file open limit otherwise mac build may fail echo ulimit n ulimit n fi what it actually does is different to what it looks like echo os if os==osx then echo equal fi equal if os osx then echo equal fi os=linux if os==osx then echo equal fi equal if os osx then echo equal fi this pr fixes the typo and makes osx workaround run on macs only
162014667,5971,https://api.github.com/repos/dotnet/coreclr/issues/5971,BruceForstall,1,0,0,0,0,0,the treenodeinfoinit function for xarch was getting exceedingly large and some of the individual cases like for gt_call were upwards of lines of code i extracted all the large cases out into functions.@dotnet/jit-contrib ptal
162006477,5969,https://api.github.com/repos/dotnet/coreclr/issues/5969,ghost,0,2,0,0,0,0,we can pretty much do all this stuff in native scripts ps sh or fancy javascript node.js which is installed as part of vs and easily script-able to obtain the local exe from their dist or shcoreclr/build. sh/ps wgets node in coreclr/tools and exports coreclr/tools to path if node isnt already present in path then calls node coreclr/build.js src test other args all written in one language this will remove the dependency on all other kinds of language runtimes to be installed on dev build machines
161875300,5947,https://api.github.com/repos/dotnet/coreclr/issues/5947,jyoungyun,1,0,0,0,0,0,now arm emulator cross build checks are automatic on a per pr basis but it does not check the unit test yet because it takes a lot of time and the internal loop jobs have a timeout of hours and it is not editable so i will pick some unit tests for arm ci under the name of tests/testsrunninginsidearm.txt and arm ci uses it with testdirfile option in runtest.sh.i will update the patch soon
161763484,5927,https://api.github.com/repos/dotnet/coreclr/issues/5927,ccurrens,1,0,0,0,0,0,affects coreclr and full net framework desktopit appears that the smaller the system timer resolution the more cpu is spent spinning when trying to acquire a contended lock via monitor*.enter methods in multiple traces ive seen absurdly high amounts of cpu being used by awarelock::contention it also looks like as the number of processors increase the overall performance decreases when there are many threads contending for a lock .often times changes to the system timer resolution are outside of a programs control in fact most wpf programs including visual studio lower the timer resolution to ms if there are locks with heavy contention in any managed program on the machine it will cause unnecessary cpu spikes i wrote a test program that does an admittedly trivial amount of work for an indefinite period of time but shows how the amount of cpu increases as the system timer resolution decreases i tested this on a wsr machine that has logical cores ht physical):! timer_resolution_cpu i change to use spinlock instead of monitor the cpu drops to around instead of hovering at ive found that modifying the spin configuration values decreases the maximum cpu used in my test program by a significant amount at ms timer resolution the program uses cpu when changing the spin configuration values to match those of the managed spinlock struct it drops down to around usage: set complus_spinlimitprocfactor=xset complus_spinlimitproccap=xc of processors on machine) i dont exactly know why changes to the timer resolution affects the awarelock as much as it does whereas the managed spinlock doesnt have the same problem i know that they accomplish spinning in different ways but i havent had time to dig into it further
161717550,5919,https://api.github.com/repos/dotnet/coreclr/issues/5919,gkhanna79,1,0,0,0,0,0,leecow ptal
161049441,5872,https://api.github.com/repos/dotnet/coreclr/issues/5872,ghost,2,0,0,0,0,0,full report ashfinished running pal tests.the following test(s failed:c_runtime/sscanf/test/paltest_sscanf_test exit code c_runtime/sscanf/test/paltest_sscanf_test exit code filemapping_memmgt/virtualalloc/test/paltest_virtualalloc_test exit code filemapping_memmgt/virtualalloc/test/paltest_virtualalloc_test exit code filemapping_memmgt/virtualalloc/test/paltest_virtualalloc_test exit code filemapping_memmgt/virtualalloc/test/paltest_virtualalloc_test exit code filemapping_memmgt/virtualalloc/test/paltest_virtualalloc_test exit code filemapping_memmgt/virtualalloc/test/paltest_virtualalloc_test exit code filemapping_memmgt/virtualprotect/test/paltest_virtualprotect_test exit code filemapping_memmgt/virtualprotect/test/paltest_virtualprotect_test exit code filemapping_memmgt/virtualprotect/test/paltest_virtualprotect_test exit code threading/namedmutex/test/paltest_namedmutex_test exit code pal test results passed failed
161016093,5870,https://api.github.com/repos/dotnet/coreclr/issues/5870,GSPP,3,0,0,0,0,0,in the system.runtime.compilerservices.unsafe package there is a method that allows unsafe casts from anything to anything method public hidebysig static t as(object o cil managed aggressiveinlining custom instance void system.runtime.versioning.nonversionableattribute::.ctor maxstack ldarg ret end of method unsafe::as this means that string s f s.gettype can be someclass or string s f string)s can throw in fact it might not throw because the c compiler or the jit might optimize that cast out.please document the usage rules for unsafe casts in general and document what exact unsafe operations are safe to perform on the clr.note that as
160950832,5860,https://api.github.com/repos/dotnet/coreclr/issues/5860,omariom,6,0,0,0,0,1,now that we have span another byreflike type should the idea of stack only types be extended to other structs it would allow us to encapsulate ref s and spans.it could be like this:if struct a has a field of stack-only type it makes the struct itself stack-only the same all the way up c#struct a private ref message message or span}struct b private a a;} @krzysztofcwalina jkotas
160849016,5851,https://api.github.com/repos/dotnet/coreclr/issues/5851,jkotas,60,0,0,24,0,41,turn into efficient first class feature x initial implementation x design document x jit correctness proper gc reporting of the special byref field re-enable gc layout reporting for span jit chokes on it fragile assumption introduced by recent jit throughput fix intrinsic for reading/writing byrefs multiple places x vm correctness x proper gc reporting x enforcement of byreflike constrains x x vm stress x gc reporting for tailcalls x gc reporting for struct passed in regs on unix x jit optimizations apply same sort of optimizations to span
160235396,5790,https://api.github.com/repos/dotnet/coreclr/issues/5790,yizhang82,1,0,0,0,0,0,today tlbimp does not support net core due to two problems it references mscorlib it references types that does not exist in net core some examples including: importedfromtypelibattributetypelibfuncattributetypelibtypeattributetypelibversionattribute it needs to correctly handle features that are not available in net core and take proper actions such as warnings)in order to work around this people need to use ildasm or ilspy to decompile the generated il into il and c and fix up the code manually the c decompilation route is probably much easier since you dont need to manually change all the references from mscorlib to the right contracts c compiler should do that automatically the caveat being that certain il features are not correctly supported in c such as this one has different problems it emits reference to mscoree.dll which would activate the dll in desktop clr
160075847,5784,https://api.github.com/repos/dotnet/coreclr/issues/5784,RussKeldorph,5,0,0,0,0,0,the coreclr build currently generates a ridiculous number of warnings especially on windows where the tests are built.warnings should be fixed and warnings converted to build breaks to prevent them from being re-introduced the honor system obviously isnt cutting it
159873390,5755,https://api.github.com/repos/dotnet/coreclr/issues/5755,kzu,1,0,0,0,0,1,just like tuple.create cuts down the noise and annoyanceof having to specify all the ts when you already have typedvalues to provide a similarly designed keyvaluepair.createfactory method would make code that creates those pairs(i.e public apis that expose ienumerable{keyvaluepair}significantly more concise and readable.fixes dotnet/corefx
159800335,5739,https://api.github.com/repos/dotnet/coreclr/issues/5739,gkhanna79,1,0,0,0,0,0,mscorlib facade is no different from any upstack assembly and thus should be shipped as rr image instead of mscorlib.ni.dll).and consider moving it to be an upstack nuget package.cc jkotas
159753505,5719,https://api.github.com/repos/dotnet/coreclr/issues/5719,benaadams,5,0,0,0,0,0,stackalloc can be around x slower than heap alloc not sure whyits often use case if to prevent future gc time while it makes runtime more predictable by not adding to gc pause due to the time it takes it doesnt often add to saved runtime
159728069,5707,https://api.github.com/repos/dotnet/coreclr/issues/5707,kouvel,1,0,0,0,0,0,issue when using software write watch getting dirty pages is synchronized with growing the write watch table using gc_lock as those cannot happen concurrently it turns out that a foreground gc can happen at that point pausing the background gc while it tries to acquire gc_lock in this issue the last object in the previously revisited page is a free object whose range spans one or more pages with the intent of skipping the free range revisit_written_page records the next object to scan immediately following the free range since only dirty pages are retrieved at a time the next set of up to dirty pages needs to be requested before that a foreground gc begins and the background gc pauses trying to acquire gc_lock the foreground gc promotes some objects and in the process allocates from the free range above and completes one of the moved objects in that previously free range gets a reference to a new object that is not referenced from anywhere else the background gc resumes determines that the moved objects page is dirty but skips revisiting the object because the previously recorded next object from which to start scanning already took the free range size into account before it was allocated the background gc does not mark through the moved object so the newly referenced object appears to be free and is sweeped later either verify_heap fails or the app crashes when trying to access that referenced objectfix similarly to what is done for the large object heap when revisiting a page and using software write watch dont advance last_object when the current object is a free object that spans beyond the current page or high_address on the next revisit it would start scanning from the previously scanned free object which now may be allocated or will have a smaller size until it reaches the requested page to scanfixes but not yet closing
159578087,5683,https://api.github.com/repos/dotnet/coreclr/issues/5683,myungjoo,2,0,0,0,0,0,corerun has been trying to load the executable from a directorywhere corerun is supposed to find dll files even if the user hasgiven a full path of the executable.this patch disables such speculation/search process for theexecutable name.fixes signed-off-by myungjoo ham myungjoo.ham@samsung.com
159553939,5673,https://api.github.com/repos/dotnet/coreclr/issues/5673,parjong,1,0,0,0,0,0,"while fixing pr pr all the features related with procfsare disabled in arm and arm softfp cross build.as a result the collision avodance logic in getprocessiddisambiguationkey is disabled,which leads to random coreclr_initialize failures(clr failed to initialize itself when the previous execution of clr with the same pidabnormally terminates)this commit tries to re-enable the relevant features for arm and arm softfp cross-build.since the arm/linux emulator which is the current reference in use supports/proc/self/stat proc/self/status proc/self/maps this commit re-enablesthree relevant features have_procfs_stat have_procfs_status have_procfs_maps).this commit tries to fix"
159537071,5671,https://api.github.com/repos/dotnet/coreclr/issues/5671,jamesqo,2,0,0,0,0,0,currently string.equals isnt getting inlined by the jit this means that a new method call has to be made every time someone does something like foo blah this is in spite of the fact that the body of string.equals itself is pretty small in terms of code size all it really does is two pointer comparisons and a length check before calling equalshelper this means that for different-length strings we are wasting a method call every time we call string.equals .this pull request makes the following changes omits compiling the this null check on coreclr since the check and the throw new nullreferenceexception clause bloated the compiled output significantly i removed it for net core this is only going to cause different behavior if someone handwrites il manually/does a reverse pinvoke as the comment notes compiles that app for net core and passes null as a parameter to one of the equals functions since for percent of cases this wont happen and removing it will speed up apps significantly i decided to only compile it for the framework aggregated two if return false conditionals into an or statement so we wont generate duplicate code to return false and thus decrease method size added aggressiveinlining attributes to the string.equals methods i didnt do it for the object-based overload since its more code most of the time its going to be done as a virtual method call which cant be inlined anyway perf impact test app for getting jit output old disassembly new disassembly the jit is able to optimize the method down to basically nothing test app for benchmarking old results new results jkotas alexghiondea hughbe ellismg
159346225,5631,https://api.github.com/repos/dotnet/coreclr/issues/5631,myungjoo,0,0,1,0,0,0,this was tested and observed at both arm/linux and x/linux.reproduction install coreclr corefx at directory a install a.exe at directory b create another a.exe different from b/a.exe at a for a more dramatic failure create a null file a/a.exe at a run corerun b/a.exe expected the file b/a.exe is executed.result the file a/a.exe is executed.note that if a/a.exe does not exist it properly executed b/a.exe
159315582,5626,https://api.github.com/repos/dotnet/coreclr/issues/5626,cmckinsey,8,0,0,0,0,1,enum.hasflag implementation requires boxing of both arguments when the enum types are the same we can replace the call with an inline bittest value flag flag that avoids the boxing allocations.there is a discussion on stackoverflow mini jit does a peep in their cil reader il pattern in ryujit importer typically looks like though the loading of the enum value onto the stack could be done with any of the various ld operations. il ldloc il c box xil_e ldloc il_f c box xil a call system.enum.hasflag a morph peep on the trees would be straightforward though it could also be possible through a series of applications of inlining type-propagation unreachable code-elimination and copy-propagation to achieve the same effect with a more generic global approach
159275686,5612,https://api.github.com/repos/dotnet/coreclr/issues/5612,jskeet,20,0,0,0,0,0,very simple code csharpusing system;using system.diagnostics;namespace consoleapplication public class program public static void main(string args time time private static void time(int iterations var stopwatch stopwatch.startnew for int i i iterations i abcfeg.endswith stopwatch.stop console.writeline(stopwatch.elapsed the project.json is mostly the default from dotnet new json buildoptions emitentrypoint true optimize true frameworks netcoreapp dependencies microsoft.netcore.app type platform version imports dnxcore on both linux ubuntu and ubuntu the output is something like text::.::. on windows on the same hardware its text::.::. version info net command line tools preview on windows and ubuntu preview on ubuntu note that under nunit every equality assertion involves three endswith calls making nunit assertions basically horrifically expensive on linux
159249006,5606,https://api.github.com/repos/dotnet/coreclr/issues/5606,sam-baravy,2,0,0,0,0,0,this pull request is to extend existing lldbplugin/libsosplugin test framework.framework architecture and basic test cases are covered at the moment
159076994,5596,https://api.github.com/repos/dotnet/coreclr/issues/5596,myungjoo,1,0,0,0,0,0,this fixes the regression caused bybecfbcfcbfea whichintended to fix while breaking many ofexception handling unit test cases.the commit fixing was an incorrect translationof x assembly code.fix signed-off-by myungjoo ham myungjoo.ham@samsung.com
158964888,5563,https://api.github.com/repos/dotnet/coreclr/issues/5563,tenor,3,0,0,0,0,0,since appdomains are coming to net core which is great news i would like to propose a new api for the appdomain class.currently its difficult to get a rough estimate of how much memory an appdomain is consuming.the apis provided are appdomain.monitoringtotalallocatedmemorysize and appdomain.monitoringsurvivedmemorysize.the former tells us the total size of all allocations which is not very useful and the latter tells us how much memory survived the last collection.if appdomains keep a count of all allocations how difficult is it to keep a separate count of new allocations since the last collection?while not perfect adding appdomain.monitoringsurvivedmemorysize allocations since the last collection paints a better picture of how much memory an appdomain is currently consuming.if this makes sense please consider this api for net core and for possibly the net framework and the clr hosting api.update the proposed api should also retrieve monitoringsurvivedmemorysize when called so that the caller gets an accurate snapshot of the memory situation at the instant the call was made
158858679,5560,https://api.github.com/repos/dotnet/coreclr/issues/5560,erozenfeld,2,0,0,0,0,0,several benchmarks from coreclr\tests\src\jit\performance\codequality show worse code generated for linux because of lack of callee-saved floating point registers on linux two examples are newte and burgers.test this issue is to investigate if anything can be done to mitigate that.category:cqtheme:calling-conventionskill-level:intermediatecost:small
158857807,5559,https://api.github.com/repos/dotnet/coreclr/issues/5559,erozenfeld,1,0,0,0,0,0,several bytemark benchmarks show double-digit perf difference linux vs windows lower number is better in the table below the data was collected using xunit-perf.os versions windows enterprise os build and ubuntu lts benchmark windows margin of error linux margin of error l w w bytemark.benchbitops bytemark.benchemfloatclass bytemark.benchludecomp bytemark.benchassignjagged bytemark.benchemfloat bytemark.benchassignrectangular bytemark.benchstringsort bytemark.benchfourier bytemark.benchideaencryption bytemark.benchneuraljagged bytemark.benchnumericsortrectangular bytemark.benchnumericsortjagged bytemark.benchneural
158815146,5550,https://api.github.com/repos/dotnet/coreclr/issues/5550,parjong,0,0,0,1,0,0,this commit tries to disable heap dump on linux if feature_event_traceis not set in order to fix
158740026,5519,https://api.github.com/repos/dotnet/coreclr/issues/5519,helloguo,1,0,0,0,0,0,"hi,i want to enable the link time optimization for building coreclr however i met some problems that i really appreciate anyone can give me any hint/suggestions first i follow the instructions from to update the gold linker and plugin i download the source code of binutils llvm and clang and build/update them everything works well in this step.second i add flto flag for building coreclr in file src/pal/tools/clang-compiler-override.txt i add set cmake_c_flags_release_init g o flto and set cmake_cxx_flags_release_init g o flto when i build it the compiler complains that ld home/guo/llvm-./llvm-...src/lib/codegen/asmprinter/dwarfunit.cpp llvm::die llvm::dwarfunit::getorcreatetypedie(const llvm::mdnode assertion ty resolve(ty.getref type was not uniqued possible odr violation failed after i dump more debug information from llvm it seems that type holderstackvalidation cortokentype opcode_t primeinfo and immutableflag from coreclrs source code cause this assertion one quick but dirty modification is to remove g flag for clang then coreclr can be build again this is not a right way to go but right now im not very familiar with the source code of coreclr and i dont know how to solve it any ideas?third one another error shows up while building coreclr home/guo/coreclr/src/debug/daccess/daccess.cpp error use of undeclared identifier dac_table_rva ulong dactableaddress m_globalbase dac_table_rva it seems that the script src/pal/tools/gen-dactable-rva.sh will be executed to add the definition of dac_table_rva in dactablerva.h but somehow this script doesnt work in order to make building continue i manually add the definition of dac_table_rva in the source code of course this is not a right way to go this way the building can finish completely and the size of libcoreclr.so is reduced also some benchmarks show that lto can achieve better performance.so i guess i need to fix the second and third problem in order to make lto work for building coreclr any comments/suggestions are appreciated thanks.mark"
158662812,5508,https://api.github.com/repos/dotnet/coreclr/issues/5508,GSPP,1,0,0,0,0,0,the dependenthandle struct is a useful form of a gchandle currently its only exposed as part of the conditionalweaktable class conditionalweaktable is quite a heavy-weight object it does more than is often needed if theres only a need for a single object pair using conditionalweaktable seems inappropriate and quite expensive.also conditionalweaktable is synchronized internally this means that it does not scale across many cores for that reason it is not a good workaround to simply maintain a global conditionalweaktable for the entire application.i suggest that the dependenthandle struct is being cleaned up and exposed for public consumption as far as i can tell only cosmetic changes need to be made to make the type nice a namespace change is probably in order as well it should be placed next to gchandle
158624016,5506,https://api.github.com/repos/dotnet/coreclr/issues/5506,yizhang82,3,0,0,0,0,0,coreclr doesnt support managed com activation today it does not have a dllgetclassobject implementation we can either enable it or write a special shim that launches coreclr and returns the factory object that creates the object through reflection
158526100,5496,https://api.github.com/repos/dotnet/coreclr/issues/5496,m08pvv,4,0,0,0,0,0,it seems that there is no documentation on operations that have implicit memory barriers acquire/release/full
158396234,5463,https://api.github.com/repos/dotnet/coreclr/issues/5463,jkotas,9,0,0,0,0,0,there are a lot of questions being asked on how this works we need to have documentation for it
158273254,5450,https://api.github.com/repos/dotnet/coreclr/issues/5450,lemmaa,2,0,0,0,0,0,i ran into several problems during the cross build coreclr for arm in linux machine.im trying to record and solve the information here x cmake initialization failure on arm cross build x fix wrong filename disasmarm.cpp for case sensitive filesystem x fix compile error cannot be narrowed to type int x fix array index xx is past the end of the array error x dont track lr as part of nv-context x fix error index must be an integer in range x fix error enumeration values not handled in switch x disable not yet implemented features
158145810,5407,https://api.github.com/repos/dotnet/coreclr/issues/5407,benaadams,2,0,0,0,0,0,times we want to queue things on the threadpool but if we are already on the threadpool continue executing rather than queue however the thread cant be checked if is threadpool thread currently
158078537,5404,https://api.github.com/repos/dotnet/coreclr/issues/5404,parjong,1,0,0,0,0,0,currently feature_hijack is disabled for arm and thus coreclr gotstuck if gc is invoked from jited code.this commit attempts to port feature_hijack from arm windows in orderto fix
158067228,5402,https://api.github.com/repos/dotnet/coreclr/issues/5402,AndyAyersMS,2,0,0,0,0,0,allow jit to inline methods with the cpblk il opcode add a test casewhere such an inline happens
158046886,5396,https://api.github.com/repos/dotnet/coreclr/issues/5396,leemgs,0,0,0,0,0,3,currently we can build coreclr with o flag of clang in release build mode for linux/arm this instruction is to enable o optimization level of clang on arm/linux by fixing the bug of llvm.signed-off-by geunsik lim geunsik.lim@samsung.com
158030240,5390,https://api.github.com/repos/dotnet/coreclr/issues/5390,helloguo,1,0,0,0,0,0,this asm helper function can replace the portable version and achieve better performance on ubuntu and mac os x
157948748,5371,https://api.github.com/repos/dotnet/coreclr/issues/5371,benaadams,1,0,0,0,0,0,range analysis doesnt take into account readonly arrays and you need to make a function local reference to eliminate the range check.analysis method median stddev scaled forlooparray us us forlooponeboundscheck us us forloopreadonlyarray us us forloopaddpointer us us foreacharray us us
157848784,5361,https://api.github.com/repos/dotnet/coreclr/issues/5361,wateret,1,0,0,0,0,0,fix arm-softfp calling convention not to follow hfa which is only for hardfp.fix for arm-softfp
157837843,5360,https://api.github.com/repos/dotnet/coreclr/issues/5360,myungjoo,1,0,0,0,0,0,the return address should be kept intact not recoveredjust yet it is going to be recovered by libgccsrescore_core_regs much later few instructions beforeheading back to catch.fixes this fixes stack misalignment during exception handling as well.with this we see all the arm/linux pal tests pass
157749367,5342,https://api.github.com/repos/dotnet/coreclr/issues/5342,davmason,1,0,0,0,0,0,this change enables the existing heap dump infrastructure from windows to work on linux it allows us to do managed memory investigations on linux.this is the port of the fix to rtm
157567864,5318,https://api.github.com/repos/dotnet/coreclr/issues/5318,ellismg,2,0,0,0,0,0,in build.sh today we have a hard coded list of distros we support building on and then set a condition variable which tells other parts of the script if it is safe to build or not.we should probably instead move to a strategy where if a managed build is requested we try to restore the tool runtime if that works e.g test for msbuild.exe in tools then we say we can build managed code otherwise we either warn or error depending on if the managed build was explicitly requested or not).this would let init-tools.sh be the only thing that has to worry about figuring out if you can run managed code or not
157565419,5314,https://api.github.com/repos/dotnet/coreclr/issues/5314,jamesqo,2,0,0,0,0,0,in equalitycomparer.default we have a special enumequalitycomparer to handle enums and avoid boxing unfortunately we dont have any such equivalent for comparer.default see we should probably specialize it in comparer too since unnecessary boxing bad
157329370,5303,https://api.github.com/repos/dotnet/coreclr/issues/5303,ghost,36,0,0,0,0,0,webassembly wasm according to microsoftedge status page webassembly is in development.imo it would be great to consolidate efforts right from the beginning between edge coreclr/corert and vc teams to provide robust webassembly code generation and optimizations.in case of llilc the llvm compiler has already started to support webassembly but having first hand code gen in coreclr has its own advantages perhaps we can have a draft implementation started in coreclr where community can chime in
157299721,5294,https://api.github.com/repos/dotnet/coreclr/issues/5294,ellismg,1,0,0,0,0,0,this builds on top of joperezr recent pull requests because he went through the trouble of updating buildtools and the cli for me once his is merged this could go it.i am still doing validation on the new platforms in docker but ubuntu worked as expected opening now to get a ci run./cc gkhanna weshaggard
157036183,5247,https://api.github.com/repos/dotnet/coreclr/issues/5247,davmason,1,0,0,0,0,0,this change enables the existing heap dump infrastructure from windows to work on linux it allows us to do managed memory investigations on linux.fixes leculver maoni lt
156955819,5240,https://api.github.com/repos/dotnet/coreclr/issues/5240,wateret,0,0,0,0,0,1,arm-softfp corelib is same as arm version
156609137,5196,https://api.github.com/repos/dotnet/coreclr/issues/5196,briansull,1,0,0,0,0,0,enable hfa support for passing arguments on arm fixes arm abi passing hfa struct arguments in floating point registers we are now passing additional hfa tests and have one test regression previously hfa support was enabled on arm using ifdef target_arm now hfa support is enabled for both platform using ifdef feature_hfa note that feature_hfa is a vm define and enable on for platforms that have hfa support the vm is responsible for determining if a stuct is a hfa or not the jit calls this method corinfotype ceeinfo::gethfatype(corinfo_class_handle hclass to identify hfa types note that when using an altjit targeting arm or arm we will never see an hfa type in codegenarm.cpp method genputargstk implement passing of hfa structs on the stack refactored to handle both byte structs and hfa struct track gc types for the byte structs or he floating point types for hfas use ldp when we have a byte struct with no gc pointers added asserts to check that we never write past the end of the outgoing arg areain codegencommon.cpp method genfnprologcalleregargs implement the homing of incoming hdf variables these are currently homed into a stack based struct as we did for arm use floating point types and registers when handling hfas added asserts to check that we never write past the end of the stack based structadded dump method for fgargtabentry to display how arguments will be passedadded getnextslotnum for fgarginfo which returns what stack offset we would use for the next stack base argumentfixed tree dump so that it can print multireg struct arguments in morph.cppmethod argscomplete we currently chose to spill odd sized structs bytes in size into a gt_lcl_var temp so that we dont need to use more than two instructions to pass a gt_obj struct since we cannot read beyond the end of a gt_obj struct)method fgmorpgargs handle hfas for multireg and stack arguments in this method size is the number of registers used when passing an argument in registers or the number of target_pointer_size stack slots when passing them on the stack for hfa this means that size can change if we cant pass them using registers use new dump method to print out how each argument is passed what register or what stack slot)method fgmorphmultiregstuctarg implement the expansion of multireg hfa arguments into gt_lists refactored to handle both byte structs and hfa struct track gc types for the byte structs or he floating point types for hfas
156608465,5195,https://api.github.com/repos/dotnet/coreclr/issues/5195,JeffCyr,8,0,0,0,0,0,there are some optimizations not available with managed code in net because there are currently no ways to enforce a memory alignment greater than the pointer size interlocked bit in x process when the underlying os is bit see discussion in issue interlocked bit cache line alignment optimizationsi have no idea if this is easy or hard in the current coreclr design but it would be nice to have a memoryalignmentattribute that could specify alignment minimally on class type and possibly on any class/struct/field.my motivation for this feature would be to implement an unfairsemaphore that isnt randomly inefficient in x when its bit state crosses a cache line boundary.i have created a gist to isolate the consequences of unaligned interlocked my machine unaligned interlocked operation can be x slower.category:proposaltheme:alignmentskill-level:expertcost:large
156411463,5177,https://api.github.com/repos/dotnet/coreclr/issues/5177,prajwal-aithal,1,0,0,0,0,0,in the cross/arm-softfp/toolchain.cmake file the following code snippet sets the cross link flags set(cross_link_flags cross_link_flags target toolchain})set(cross_link_flags cross_link_flags b${cross_rootfs}/usr/lib/${toolchain})set(cross_link_flags cross_link_flags l${cross_rootfs}/lib/${toolchain l${cross_rootfs}/usr/lib/${toolchain})set(cross_link_flags cross_link_flags sysroot=${cross_rootfs}) shouldnt the path passed to the b flag be as follows? set(cross_link_flags cross_link_flags target toolchain})set(cross_link_flags cross_link_flags b${cross_rootfs}/usr/lib/gcc/${toolchain})set(cross_link_flags cross_link_flags l${cross_rootfs}/lib/${toolchain l${cross_rootfs}/usr/lib/${toolchain})set(cross_link_flags cross_link_flags sysroot=${cross_rootfs}) @kvochko ianhays
156072061,5144,https://api.github.com/repos/dotnet/coreclr/issues/5144,gkhanna79,0,0,0,1,0,0,also removed initializedefaultcontext.@jkotas ptal@davidfowl fyi
155520667,5060,https://api.github.com/repos/dotnet/coreclr/issues/5060,DmitrySikorsky,4,0,0,0,0,0,doesnt work:assemblyloadcontext.default.loadfromassemblypath(@c:\x.y.dll);works:assemblyloadcontext.default.loadfromassemblypath(@c:\xy.dll
155516138,5059,https://api.github.com/repos/dotnet/coreclr/issues/5059,mkborg,1,0,0,0,0,0,fixes as proposed by prajwal-aithal
155407602,5040,https://api.github.com/repos/dotnet/coreclr/issues/5040,reader-man,2,0,0,0,0,0,"hi,thanks for this great project net core it would be great to have it running on the new ms bought technology xamarin so is there a road map for having a net core xamarin pcl that will work on winphone+ios+android"
155376375,5030,https://api.github.com/repos/dotnet/coreclr/issues/5030,kouvel,1,0,0,0,0,0,fixes on systems that support pthread process-shared robust recursive mutexes they will be used on other systems file locks are used file locks unfortunately dont have a timeout in the blocking wait call and i didnt find any other sync object with a timed wait with the necessary properties so polling is done for timed waits.shared memory files session-scoped mutexes name not prefixed or prefixed with local go in tmp/coreclr/shm/session/|global/
155373085,5027,https://api.github.com/repos/dotnet/coreclr/issues/5027,noahfalk,2,0,0,0,0,0,our current approach to get eyeballs on issues relies on generous developers frequently triaging all issues while convenient sometimes issues fall through the cracks providing a directory of maintainers allows contributors to take control and more quickly seek out the right maintainers to collaborate with
155360786,5025,https://api.github.com/repos/dotnet/coreclr/issues/5025,redknightlois,10,0,0,0,0,0,many if not all current cpus support prefetching in one way or another also the good thing is that the prefetch instruction can be omitted completely if the target architecture do no have such opcode or the jit does not support it as it is an empty method the reason to suggest such support is that in many places like in binary search on b+trees the search is actually memory bound so you eventually hit a ceiling it doesnt matter how good your jit code is the lack of prefetching makes improvements imposible btw we have reached that place since a few months ago with the introduction of system.runtime.compilerservices.unsafe it actually makes a lot of sense to include a method like csharppublic enum prefetchhint all or temporal or l l l nontemporal or nta}public static class unsafe jitintrinsic public unsafe static void prefetch(void p size length prefetchhint hint prefetchhint.all);} @caroleidt mellinoe
155321560,5021,https://api.github.com/repos/dotnet/coreclr/issues/5021,jamesqo,1,0,0,0,0,0,in string.equals(object we do a typecast before checking for reference equality of the strings which is not necessary because str is not used in this comparison this change moves the reference comparison before the typecast so if you do something like csfoo.equals((object)foo); it wont have the overhead of a typecast.cc jkotas hughbe
155312884,5019,https://api.github.com/repos/dotnet/coreclr/issues/5019,hughbe,1,0,0,0,0,0,avoids calling internal native method times per sort times is enough avoids calling internal native method times per reverse time is enoughthanks to jamesqos great getlowerbound improvement the method is superfast.however each time we call it we still need to call a native method.this means that across methods in array we cache the result of getlowerbound however sort and reverse dont do this so we can boost their perf slightly and be consistent./cc jkotas mikedn jamesqo
155115152,4993,https://api.github.com/repos/dotnet/coreclr/issues/4993,jamesqo,1,0,0,0,0,0,if the dimension is as the rank will always be its safe to skip calling getrank which calls arraybase::getrank which calls methodtable::getrank which calls getclass which looks like it does a bunch of stuff and the argument validation.related pr that made me look into the code to see if any optimizations could be made by hughbe cc jkotas mikedn
154915724,4980,https://api.github.com/repos/dotnet/coreclr/issues/4980,NickCraver,22,0,1,0,0,0,with rc and limited naming options in nuget characters and recognized patterns for pre-release we ended up with rc-final rc-update and rc-update while joking about it in slack chat this morning better options arose so im starting an issue here for discussion.the package naming formats we came up were major>..--
154820192,4969,https://api.github.com/repos/dotnet/coreclr/issues/4969,gkhanna79,1,0,0,0,0,0,enable custom load context to override the assemblies specified in tpa excluding the core library also removed the ni checks in loadfromniimage paths since rr images are not having that extension.refactored alc.cs to support the resolution order.@jkotas ptal
154773212,4960,https://api.github.com/repos/dotnet/coreclr/issues/4960,mmitche,1,0,0,0,0,0,getting the following in cs error opening win resource file d:\j\workspace\x_ryujit_ch---ecedcb\bin\obj/\windows_nt.x.checked\/native.res the process cannot access the file d:\j\workspace\x_ryujit_ch---ecedcb\bin\obj\windows_nt.x.checked\native.res because it is being used by another process d:\j\workspace\x_ryujit_ch---ecedcb\src\mscorlib\system.private.corelib.csproj indication this is usually an indication that certain msbuild properties are not being cleared/set properly in project reference dependencies and a project is erroneously being built twice./cc russkeldorph weshaggard gkhanna
154560473,4937,https://api.github.com/repos/dotnet/coreclr/issues/4937,SunnyWar,1,0,0,0,0,0,"i thought this was a cli issue but they said it was a roslyn problem the roslyn repo says its a coreclr issue...so here it is:steps to reproducecompare how the compile deals with x versus x it should be the same but isnt for var i i iterations i var x i if x count look at the generated assembly for the i part dee mov eax,edx dee and eax,h deea jns dee deec dec eax deed or eax,fffffffeh dee inc eax dee test eax,eax dee jne dee compare it to this for var i i iterations i var x i if x count eb test edx,ea jne eaexpected behavior recognized the pattern and replace it with so that it can be optimized recognize that the value can never be negative therefore making it a candidate for this pattern.actual behavior its not optimal.this is an example of pattern matching behavior that the coreclr should support look at introducing a new advanced visual c code optimizer for other examples.category:cqtheme:basic-cqskill-level:intermediatecost:small"
154406258,4925,https://api.github.com/repos/dotnet/coreclr/issues/4925,mylibero,1,0,0,0,0,0,recent commit breaks arm build.it defines emitinstojumpkind twice in src/jit/emit.h on arm.i will post a pr soon.@jyoungyun
154300683,4914,https://api.github.com/repos/dotnet/coreclr/issues/4914,pgavlin,1,0,0,0,0,0,now that the jit may be built on many platforms using many toolchains we should make sure that the jit/ee interface uses types with well-defined sizes on all platforms this includes e.g replacing unsized types int unsigned etc with sized equivalents from stdint ensuring that all enums have explicit sizes.category:implementationtheme:jit-coding-styleskill-level:intermediatecost:medium
154136829,4903,https://api.github.com/repos/dotnet/coreclr/issues/4903,BruceForstall,1,0,0,0,0,0,and move some header file changes from codegen.h to codegenclassic.h.the code moved were whole functions with no apparent tight coupling withother code already in codegencommon.cpp.the code moved had some ifndef legacy_backend portions no longerneeded removed.@dotnet/jit-contrib ptal
153894386,4874,https://api.github.com/repos/dotnet/coreclr/issues/4874,gkhanna79,0,0,0,0,0,2,this change enables system.private.corelib to be the core library for coreclr instead of mscorlib.dll updated build scripts and packaging to carry the ni as well.@jkotas alexghiondea weshaggard ptal
152907548,4766,https://api.github.com/repos/dotnet/coreclr/issues/4766,swaroop-sridhar,1,0,0,0,0,0,"ryujit has several extra struct copies of the two field biginteger struct in the pi-digit benchmarks functions.for example heres the code for pidigits:extract_digit(int):int:this g_m_ig push rdi push rsi push rbx ec sub rsp bf mov rsi rcx dc lea rdi rsp+h p this->bi b mov ecx c xor rax rax fab rep stosd bce mov rcx rsi bf mov rsi rcxg_m_ig de lea rcx bword ptr rsi b mov rdi gword ptr rcx b mov ebx dword ptr rcx c xor rcx rcx d lea rax bword ptr rsp+h t cec vxorpd ymm ymm ceaf vmovdqu qword ptr rax ymm dc lea rcx bword ptr rsp+h eafeffff call system.numerics.biginteger:.ctor(int):this ctor(t bc mov rcx gword ptr rsp+h b mov edx dword ptr rsp+h cd lea r bword ptr rsp+h d lea rax bword ptr rsp+h mov gword ptr rax rdi t p mov dword ptr rax ebx t p d lea rax bword ptr rsp+h mov gword ptr rax rcx t t mov dword ptr rax edx t t bc mov rcx r d lea rdx bword ptr rsp+h cd lea r bword ptr rsp+h multiply(t t x t efffff call system.numerics.biginteger:op_multiply(struct,struct):struct dc lea rcx bword ptr rsp+h d lea rdx bword ptr rsp+h cb mov r gword ptr rsp+h c mov gword ptr rdx r t t b mov rd dword ptr rsp+h mov dword ptr rdx rd t t d lea rdx bword ptr rsi q this->big_m_ig ceaf vmovdqu ymm qword ptr rdx ceaf vmovdqu qword ptr rsp+h ymm t qg_m_ig d lea rdx bword ptr rsp+h cd lea r bword ptr rsp+h add(t t t eafbffff call system.numerics.biginteger:op_addition(struct,struct):struct dc lea rcx bword ptr rsp+h d lea rdx bword ptr rsp+h cb mov r gword ptr rsp+h c mov gword ptr rdx r t t b mov rd dword ptr rsp+h mov dword ptr rdx rd t t c add rsi g_m_ig ceaf vmovdqu ymm qword ptr rsi ceaf vmovdqu qword ptr rsp+h ymm t this->big_m_ig d lea rdx bword ptr rsp+h cd lea r bword ptr rsp+h division(t t t eedeffff call system.numerics.biginteger:op_division(struct,struct):struct dc lea rcx bword ptr rsp+h b mov rax gword ptr rsp+h mov gword ptr rcx rax t t b mov eax dword ptr rsp+h mov dword ptr rcx eax t t dc lea rcx bword ptr rsp+h explicit(t edeffff call system.numerics.biginteger:op_explicit(struct):int nop g_m_ig c add rsp b pop rbx e pop rsi f pop rdi c ret the comments indicate block struct copy/init as well as field assignments.there are several extra copies in this code the copy of return value into t struct after each function is unnecessary the return struct can be reused for next computation this could be an isolated issue wrt copy-prop of struct-return values that can be fixed this accounts for three copies this->bi via pointer p could be block copied but is field-copied t t copy is unnecessary could be caused by phase ordering where one of the structs is lowered early is the zero initialization of t necessary before call to constructor category:cqtheme:structsskill-level:expertcost:extra-large"
152904363,4763,https://api.github.com/repos/dotnet/coreclr/issues/4763,AndyAyersMS,1,0,0,0,0,0,test case to stress inlining expression opts and control flowsimplification for booleans.test case has methods named idxx all should generate identicalcode on x windows we expect to get the byte sequence fbc movzx rax cl c ret only of the variants get this codegen there are at least othersequences ranging in size from to bytes of code.likely touches on the same issues raised in
152644518,4722,https://api.github.com/repos/dotnet/coreclr/issues/4722,terrajobst,0,0,1,0,0,0,on behalf of samuelenglard is there a way to have the core jit not optimize code debugging inside corefx/mscorlib is hard with optimizations
152074914,4703,https://api.github.com/repos/dotnet/coreclr/issues/4703,jamesqo,1,0,0,0,0,0,as it stands many high-level string functions like indexof lastindexof replace etc are implemented natively when they could be written in managed code i noticed this was done with one of the string.replace overloads in f so maybe it would be good to do this to make the code more accessible to newcomers if they arent familiar with how the c code maps to c
151934806,4687,https://api.github.com/repos/dotnet/coreclr/issues/4687,kyulee1,1,0,0,0,0,0,fixes is a bit large change across vm/zap/jit to properly support crossgenscenario fix incorrect ldr encoding with size enforce jit data following jit code per method by allocating them together this guarantees correct pc-relative encoding for such constant data access without fix-up for the general fix-up data acceess use adrp/add instruction pairs with fix-ups two more relocations types are implemented in all sides interface dispatch stub is now implemented which is needed forinterface call for crossgen.ive verified hello world runs with mscorlib.ni.dll
151271972,4610,https://api.github.com/repos/dotnet/coreclr/issues/4610,chunseoklee,1,0,0,0,0,0,this patch enables mscorlib.dll build on linux mint based on ubuntu lts
150980065,4572,https://api.github.com/repos/dotnet/coreclr/issues/4572,JohnChen0,1,0,0,0,0,0,this commit addresses issue and allows windows version of crossgen built from github to create pdbs for native images and ready to run images.new header files cvinfo.h and cvconst.h were copied from feature is currently only available on windows since it requires an additional module diasymreader.dll which is not yet available on other platforms
150597476,4540,https://api.github.com/repos/dotnet/coreclr/issues/4540,jamesqo,3,0,0,0,0,0,the current implementation of stream.copyto allocates a giant byte buffer if no buffersize parameter is passed this is incredibly wasteful if the stream were copying from can seek because then we can use the length and position properties to determine how many bytes are left and allocate a buffer of that size this pr alters the bodies of copyto and copytoasync to do that.right now i dont want this to be merged since there are several points of contention that need to be addressed should the optimization should occur inside/outside the virtual methods i did it outside so all stream subclasses would benefit from this this change introduces new virtual method calls canseek length and position canseek probably shouldnt throw and neither should the other two if the stream can seek but im still a bit iffy about this change how should streams with length position be handled this can arise in classes like memorystream if you do something like this cs var stream new memorystream position console.writeline(stream.position console.writeline(stream.length right now im handling it by short-circuiting the same as if length position since im assuming that would also mean there are no bytes left in the stream should i instead fallback to the default behavior keeping the buffer size at here to minimize the risk of a compat issue?i have tested these changes with these instructions and assuming i did them right they seem to be working as far as i can see.@stephentoub jkotas ptal
150487812,4528,https://api.github.com/repos/dotnet/coreclr/issues/4528,gkhanna79,2,0,0,0,0,0,this change enables consuming the jit as a dynamic library as opposed to getting statically linked for now i have kept feature_merge_jit_and_engine incase we need it in the short-term since the runtime and jit were in the coreclr package since jit was statically linked i am keeping the jit in the coreclr nuget package this will be fixed in the next phase once is merged jkotas pgavlin ptalcc russellhadley russkeldorph schellap
150341501,4506,https://api.github.com/repos/dotnet/coreclr/issues/4506,GSPP,3,0,0,0,0,0,continuing my series to break the bcl for fun and no profit heres another string.join bug: string.join new object null x returns it should return x .this bug exists in coreclr in and in the recently merged string.join fix
150324807,4504,https://api.github.com/repos/dotnet/coreclr/issues/4504,krytarowski,0,0,0,1,0,0,thanks for coypoop for improving the english wording
149657679,4436,https://api.github.com/repos/dotnet/coreclr/issues/4436,davzucky,2,0,0,0,0,0,the idea of this flag is that it will allow to build the library statically so that the dotnetcli bootstrapping package use to build coreclr and corefx would only contain statically linked native library.this will help on a lot on issue that poeples are facing because of the lib version difference mainly icu and curl the param name static./build.sh static
149483036,4409,https://api.github.com/repos/dotnet/coreclr/issues/4409,davzucky,40,0,0,4,0,0,following on this problem that i raised with archlinux i would still make progress to enable the support of the platform getting archlinux support move forwardthis is the first goal that i have for that i could imagine the following step to get started building manually a dotnetcli package for archlinux and getting it deploy updating coreclr and corefx build to recognize archlinux and pick up this custom package creating an archlinux server to get daily build or archlinux including dotnet cli creating an official pacman archlinux package manager packagei have already and for coreclr running locally however i dont know what is the process to enable this type of infrastructure step like
149409887,4407,https://api.github.com/repos/dotnet/coreclr/issues/4407,masonwheeler,1,0,0,0,0,0,with the latest coreclr checkout when running build clean on windows one of the initial steps is to download build tools this step is currently failing: d:\devfolder\coreclr>build cleanbuild commencing coreclr repo buildbuild doing a clean buildcould not find d:\devfolder\coreclr\bin\logs\*_windows_nt__x__debug.*build checking prerequisitesinstalling dotnet cli...error could not install dotnet cli correctly see d:\devfolder\coreclr\init-tools.log for more details.error could not restore build tools. the contents of init-tools.log running d:\devfolder\coreclr\init-tools.cmd installing to d:\devfolder\coreclr\tools\dotnetcli\dotnet-dev-win-x...-beta-.zip exception calling downloadfile with argument(s the operation has timed out at line char new-object net.webclient).downloadfile categoryinfo notspecified methodinvocationexception fullyqualifiederrorid webexception exception calling extracttodirectory with argument(s could not find file d:\devfolder\coreclr\tools\dotnetcli\dotnet-dev-win-x...-beta zip at line char new-object net.webclient).downloadfile categoryinfo notspecified methodinvocationexception fullyqualifiederrorid filenotfoundexception this appears to be a problem of poor synchronization between the build script and the servers can someone look into it
149219294,4390,https://api.github.com/repos/dotnet/coreclr/issues/4390,pgavlin,1,0,0,0,0,0,these changes replace uses of some type and macrodefinitions from utilcode.h with uses of equivalentdefinitions that are internal to the jit
148899389,4384,https://api.github.com/repos/dotnet/coreclr/issues/4384,bbowyersmyth,2,0,0,0,0,0,fixes i dont know if there is a lot of value protecting against broken iterators accessing interface properties less is a good thing.change join and concat to access iterator.current value once most of these are for null checking but now that these functions use a stringbuilder this can be delegated to stringbuilder.append which handles those rare cases fine
148757810,4367,https://api.github.com/repos/dotnet/coreclr/issues/4367,AndyAyersMS,2,0,0,0,0,0,when running the coreclr tests the corerun processes hack the description seen in taskmanager to just say build .this seems to be a recent innovation.! image
148711438,4365,https://api.github.com/repos/dotnet/coreclr/issues/4365,GSPP,8,0,0,0,0,0,net only supports automatic lifetime for managed objects the gc cleans up this is fantastic for productivity sometimes developers need tight control over latency though the gc can interfere with that goal.this has been discussed at length in many place i believe the team is aware of this issue although great strides have been made improving the gc this is still an important concern it is not clear that the gc can ever fully resolve this.as a workaround we can place data in manually allocated memory and use pointers to access that data but that data can never be a managed object i cannot pass that data to other non-aware code if i want to allocate an unmanaged buffer i cannot pass that buffer as a byte to other code this is terrible for composability. please implement unsafe managed objects with user controlled lifetime like this: allocated class somedata public int x somedata somedata activator.createobject(mycustomheap);somedata.x dowork(somedata);activator.deleteobject(somedata mycustomheap this! i can ask the runtime to create and destroy objects on a custom allocator that i provide an allocator is just a custom class: abstract class allocator intptr allocate(intptr numberofbytes void deallocate(intptr address);} using this api developers can manage memory without involving the gc they can devise their own lifetime schemes. benefits its possible to avoid the gc these are totally normal net objects that work like any other object composability deterministic memory consumption no need to wait for the gc or trigger it finalizer is called deterministically if there are no finalizers there is no need to even call deleteobject the allocator can destroy all objects in constant time arena allocation). the usual perils of unsafe memory management apply need to ensure that there are no leaks and no double-frees cannot reference deleted objects memory corruption can result if contract broken.this scheme lends itself to arena allocation a game engine can allocate all per-frame objects in an arena and constant-time delete all of them at frame end a rest service can arena allocate all data per-request an xml parser can allocate all temporary buffers temp strings etc in a per-parse arena. this proposal achieves very nice integration of unsafe memory management into an otherwise managed application the idea is that most code is safe and managed but there are performance-critical islands of unmanaged memory that interoperate nicely.the only clr change required would be to teach the gc to ignore such custom objects this could be done through a bit in the object header or based on type i have left it open whether classes need to be declared as custom-allocated or whether any class can be allocated unsafely
148585908,4356,https://api.github.com/repos/dotnet/coreclr/issues/4356,vanka78bg,2,0,0,0,0,0,currently system.numerics.vectors takes advantage of certain jit intrinsics provided by ryujit to accelerate some vector operations for instance addind two vector variables together would emit a single simd instruction for packed addition in contrast matrix and quaternion operations cannot take advantage of this due to a lack of jit support for example transforming a vector variable by a matrixx would emit scalar multiplications and scalar additions instead of only packed multiplications and packed additions.the most common indended usage of the system.numerics.vectors library is in graphically intensive d and d applications which often need to apply affine transformations to many vectors for this reason providing simd acceleration for matrix and quaternion operations can be of a great benefit with a theoretical speedup by a factor of or more however such improvements are not currently possible without the necessary jit support in my opinion the biggest performance advantage can be achieved by accelerating at least the following opertations transforming a vector by a matrix transforming a vector by a quaternion multiplying a matrix by a matrix transposing a matrix to implement efficiently)category:cqtheme:vector-codegenskill-level:expertcost:large
148357993,4331,https://api.github.com/repos/dotnet/coreclr/issues/4331,GSPP,55,0,0,8,0,16,why is the net jit not tiered?the jit has two primary design goals fast startup time and high steady-state throughput.at first these goals appear at odds but with a two-tier jit design they are both attainable all code starts out interpreted this results in extremely fast startup time faster than ryujit example the main method is almost always cold and jitting it is a waste of time code that runs often is jitted using a very high quality code generator very few methods will be hot therefore throughput of the high quality jit does not matter much it can spend as much time as a c compiler spends to generate very good code also it can assume that the code is hot it can inline like crazy and unroll loops code size is not a concern.reaching this architecture does not seem too costly writing an interpreter seems cheap compared to a jit a high quality code generator must be created this could be vc or the llilc project it must be possible to transition interpreted running code to compiled code this is possible the jvm does it its called on stack replacement osr).is this idea being pursued by the jit team?.net runs on s of millions of servers i feel like a lot of performance is left on the table and millions of servers are wasted for customers because of suboptimal code gen.category:throughputtheme:big-betsskill-level:expertcost:extra-large
147891135,4307,https://api.github.com/repos/dotnet/coreclr/issues/4307,alsemenn,1,0,0,0,0,0,on osx debug build both native and managed following occurs:the number written by native part is not see attached source code).but if struct layout changed to sequential in cs file everything works fine. src.zip
147868199,4303,https://api.github.com/repos/dotnet/coreclr/issues/4303,CarolEidt,1,0,0,0,0,0,the check for the case where a barrier is not required when writing to a local variable needs to include the localvaraddr case
147841974,4299,https://api.github.com/repos/dotnet/coreclr/issues/4299,mikem8361,1,0,0,0,0,0,the official lldb without my changes for core dumps is so much better for sos and general native debugging we need to switch the ci lab and the official documentation
147536792,4271,https://api.github.com/repos/dotnet/coreclr/issues/4271,grokys,2,0,0,0,0,0,"creating a new portable class library in vs and then clicking target net platform standard in the project properties causes the project to break with errors like: predefined type system.object is not defined or importedpredefined type system.void is not defined or imported it seems that a nuget package cannot be located: unable to resolve netstandard.library rc for netstandard,version=v.. is this feature ready for use ive not seen any mention of it anywhere"
147469583,4267,https://api.github.com/repos/dotnet/coreclr/issues/4267,ayende,7,0,0,0,1,0,is not fair.full details here the gist of it is that this code will typically print cant get it because one thread releasing and acquiring the semaphore at high rate will block another thread from ever accessing it. public class program public static void main(string args var fair new fairpractice var thread new thread(fair.otherwork thread.start while thread.isalive fair.domainwork public class fairpractice semaphoreslim s new semaphoreslim public void otherwork while true thread.sleep if s.wait false console.writeline(\r\ncant get it return console.writeline(\r\ngot it s.release private int work public void domainwork if s.wait false throw new timeoutexception(cant get semaphore console.write(\r work thread.sleep s.release
147369331,4264,https://api.github.com/repos/dotnet/coreclr/issues/4264,Dmitri-Botcharnikov,2,0,0,0,0,0,lldb has no/partial support for linux/arm platform e.g it misses implementation of registercontext for this combination of os and cpu we propose to upgrade lldb to version as its the last stable release and includes linux/arm support
146985144,4187,https://api.github.com/repos/dotnet/coreclr/issues/4187,stephentoub,0,0,0,1,0,1,in general cancellationtokensource.dispose is not meant to be used concurrently with other operations on the instance dispose should only be used when the creator of the cts is done with it however theres one common situation where recommended usage runs afoul of this a typical usage of a linkedcancellationtokensource as created by cancellationtokensource.createlinkedtokensource is as follows c#private cancellationtoken internalcancellation;public void somemethod(cancellationtoken externalcancellation using var cts cancellationtokensource.createlinkedtokensource(externalcancellation internalcancellation dowork(cts.token where an lcts is used to combine some external source of cancellation with some internal one its important that the lcts then be disposed as otherwise itll end up leaking state into constituent cts and in particular in the case of the externally provided one that could be a very long lived token however its perfectly fine for the external token to have cancellation requested at any time during this method which means that even though dispose and cancel werent designed to be safe to execute concurrently and even though we recommend against it its actually possible with recommended usage.its a very dificult race to reproduce but when it does the typical visible result is an objectdisposedexception state corruption could also result.this commit addresses that in two ways rather than having the lcts register a delegate with each ct that calls cancel it instead has its delegate call notifycancellation this is the same method cancel calls but without the upfront disposal check that eliminates the easily visible result of a race that would cause an objectdisposedexception with all of the tweaking thats been done to dispose since it was originally written its actually very close to being safe to use concurrently with cancel this takes it the rest of the way though we still dont want to document it as such its really just to make lcts work correctly and as such cancel does still have a disposed check at the very beginning the only state dispose mutates that could be problematic is a timer and a manualresetevent timers dispose is already thread-safe mres isnt so if its been allocated which is relatively rare i add a single interlocked.exchange to null it out and then do a volatile read on a state field to see whether cancellation is currently in progress only disposeing of the mre if it is and leaving it for finalization otherwise on the cancel side we just add some null checks to ensure were not attempting to dispose of nulld out fields again with volatile reads where necessary.fixes ericeil kouvel alfredoms lukazoid
146725954,4149,https://api.github.com/repos/dotnet/coreclr/issues/4149,wtgodbe,1,0,0,0,0,0,we dont currently have any documentation for all of the ci/jenkins trigger phrases that are defined in netci.groovy which renders them less useful than they could be this is a first crack at a document to contain all of those phrases
146578507,4142,https://api.github.com/repos/dotnet/coreclr/issues/4142,Toxantron,1,0,0,0,0,0,"hello,are there any ambitions to provide an api to bitconverter that takes an exisiting byte and position to include the bytes of a primitive right now i have an additional converter based on bitconverter that has methods like this c summary includes an int into an array of bytes summary public unsafe static void include(int value byte bytes int index error handling and parameter validation if bytes null throw new argumentnullexception(nameof(bytes if index bytes.length throw new argumentoutofrangeexception(nameof(index fixed byte b bytes int*)(b index value summary includes a long into an array of bytes summary system.security.securitysafecritical auto-generated public unsafe static void include(long value byte bytes int index error handling and parameter validation if bytes null throw new argumentnullexception(bytes if index bytes.length throw new argumentoutofrangeexception(index fixed byte b bytes long*)(b index value i think it would be great to have those methods as well whenever we try to serialize values into an array without having to use array.copy all the time to avoid redundant code the getbytes methods should then just call the new methods c converts an int into an array of bytes with length four system.security.securitysafecritical auto-generated public unsafe static byte getbytes(int value contract.ensures(contract.result().length byte bytes new byte include(value bytes return bytes converts a long into an array of bytes with length eight system.security.securitysafecritical auto-generated public unsafe static byte getbytes(long value contract.ensures(contract.result().length byte bytes new byte include(value bytes return bytes i would be happy to create a pr if this is considered a valid api addition"
146386021,4114,https://api.github.com/repos/dotnet/coreclr/issues/4114,jehine-MSFT,1,0,0,0,0,0,ive noticed that when getting a response with gzip as the content encoding this value is not populated into the response.header.content.contentencoding object if the value is foo this value is properly propagated from the response to the header object
146351424,4108,https://api.github.com/repos/dotnet/coreclr/issues/4108,omariom,1,0,0,0,0,1,jit could replace virtual interface and delegate dispatch with static one when it knows the target at jit-time jit could even inline it when appropriate c#private static readonly equalitycomparer.default;private static readonly icomparer
146200242,4104,https://api.github.com/repos/dotnet/coreclr/issues/4104,erozenfeld,1,0,0,0,0,0,morph in ryujit is responsible for several things setting side effect flags on tree nodes correctly transforming call arguments making some expression optimizations and more global morph is called before optimization phases during optimizations morph is called on statements affected by optimizations that has caused a number of bugs optimizations rely on value numbers and morph cant always properly maintain them when performing its expression transformations we should try to factor parts of morph needed for maintaining ir invariants so that we can use them during optimization phases without performing morph optimizations.category:cqtheme:big-betsskill-level:expertcost:extra-large
145830246,4074,https://api.github.com/repos/dotnet/coreclr/issues/4074,kouvel,0,0,0,1,0,0,ide windowsfixes implemented software write watch using write barriers a new set of write barriers is introduced each corresponding to an existing one but which also updates the write watch table the gc switches to a write watch barrier during concurrent gc and switches back to a non write watch barrier after the final query for dirty pages the write watch table is alloacted along with the card table since the card table is used differently different synchonization is used for the write watch table the runtime is suspended during resize since that is the most infrequently occuring operation of that resetwritewatch and getwritewatch resetwritewatch doesnt need a suspend but since the software ww version is much faster than the windows version moved it into the suspended region to avoid some synchronization that would otherwise be required the background calls to getwritewatch dont need or do a suspend they only need to synchronize with the resize path not for the purpose of correct functionality but to not miss dirty pages such that concurrent gc is effective also while concurrent gc was already enabled by default it wasnt actually on by default outside windows since there was no write watch support with this change concurrent gc is on and functions by default.miscellaneous fixed runtests.sh to copy mscorlib.dll and delete the windows version of mscorlib.ni.dll
145546027,4061,https://api.github.com/repos/dotnet/coreclr/issues/4061,jamesqo,1,0,0,0,0,0,fixes useroslyncompiler is no longer needed since it looks like were not using the native compilers for c#/vb anymore.cc jkotas svick alexghiondea
145501557,4059,https://api.github.com/repos/dotnet/coreclr/issues/4059,colgreen,4,0,0,0,0,0,there appears to be a long running issue with the performance of multidimensional arrays compared to a comparable jagged array are there any plans to look into this?some existing discussion here ran a quick test using net in x mode i.e using ryujit and the issue appears to still be present.category:cqtheme:md-arraysskill-level:expertcost:large
145268370,4049,https://api.github.com/repos/dotnet/coreclr/issues/4049,jaredpar,2,0,0,0,0,0,consider the following code class program static void main(string args var x mystruct.empty public struct mystruct public static readonly mystruct empty null this code will compile with c and is legal according to the cli spec the type definition is recursive but the layout of the struct is not because the field involved here is static the clr is unable to handle this though and fails at runtime with a typeloadexception unhandled exception system.typeloadexception could not load type consoleapplication.program+mystruct from assembly consoleapplication version culture=neutral publickeytoken=null
144642643,3995,https://api.github.com/repos/dotnet/coreclr/issues/3995,hughbe,0,0,0,1,0,0,fastpath the case of numberstyles.integer andnumberformatinfo.invariantinfo to provide up to x performance boost benchmarks times are in millseconds averaged over instances of iterations please ignore the changes for hexnumber those are just a glimpse of whats next if this is merged benchmark benchmark codeclick here
144615766,3992,https://api.github.com/repos/dotnet/coreclr/issues/3992,hughbe,1,0,0,0,0,0,up to x perf improvement and x allocation reduction by using custom specific parsing code and avoiding split allocations benchmark results! benchmark benchmark codeclick here public static void timeaction(string prefix action action var sw new stopwatch for int iter iter iter int gen gc.collectioncount sw.restart for int i i i action sw.stop console.writeline(${prefix}time sw.elapsed.totalseconds}\tgc gc.collectioncount gen static void main(string args console.writeline measure x.x timeaction(old new versionold timeaction(new new versionnew console.writeline measure x.x.x timeaction(old new versionold timeaction(new new versionnew console.writeline measure x.x.x.x timeaction(old new versionold timeaction(new new versionnew console.writeline measure x.x.x.x with whitespace timeaction(old new versionold timeaction(new new versionnew console.readline();}
144425550,3977,https://api.github.com/repos/dotnet/coreclr/issues/3977,manu-st,6,0,0,0,0,0,im opening an issue to track the progress of arm bit with respects to the regression tests.currently im getting the following results on ubuntu running on a nvidia jetson tk this is unfortunately not the results you get from a clean checkout the only difference is that it contains a fix for issue pr but overall it should provide a good base to monitor our progress test results tests discovered passed failed skipped ive attached the xml results: coreclrtests.zip
143514280,3929,https://api.github.com/repos/dotnet/coreclr/issues/3929,papaslavik,1,0,0,0,0,0,arm softfp support for issue
142475333,3848,https://api.github.com/repos/dotnet/coreclr/issues/3848,AndyAyersMS,1,0,0,0,0,0,now that we can measure the code size impact of individual inlines we should look into cases where the size increase is unusually large.for instance this table shows inlines where the native size increase is above the th percentile given the il size of the inlined method.category:cqtheme:inliningskill-level:intermediatecost:medium
141789767,3805,https://api.github.com/repos/dotnet/coreclr/issues/3805,leemgs,0,0,0,0,0,3,here is linux/arm emulator as a virtual arm device to help system developers that dont have any real embedded devices such as raspberry pi board samsung arm chromebook and odroid x)u board it means that you can easily build net core source and run an executable arm binary on the emulator virtual arm device linux/arm emulator to build/run net core note we will continually update this webpage to share changed contents whenever you upload the latest version this webpage is last modified on jul by geunsik lim requirements host os ubuntu lts x pc required ram size gib target architecture armvle major goal to enable linux/arm continuous integration ci based on qemu/chroot to build run dotnet core components e.g coreclr and corefx like sandbox to provide the system developers that dont have embedded boards with virtual arm device download download the latest version of linux/arm emulator default packages optional packages archive for keeping the older versions thanks to bruce hoult getting started linux/arm emulator step decompress the compress file with pbzip command for parallelism and the existing bzip command is also compatible to decompress the file u$leemgs sudo apt-get install pbzip u$leemgs sudo ln s usr/bin/pbzip usr/bin/pbunzip u$leemgs sudo time tar use-compress-prog=pbunzip xvf linux-arm-emulator- .tar.pbz step run start.sh please refer to doc/readme.txt for more details) step net core world arm@emul cd dotnet/runtime-hardfp-debug-mode arm@emul time corerun c dotnet/example/hello.exe arm@emul time corerun c dotnet/example/ms /hello.exe linux arm@emul time corerun c dotnet/example/ms /hello.exe freebsd arm@emul time corerun c dotnet/example/ms /hello.exe mac arm@emul time corerun c dotnet/example/floattest.exe step screenshot execution time experiment between debug build and release buildyou can see more screenshots at build the latest coreclr/corefx firsthand on ubuntu x compilation with ubuntu/arm rootfs for ubuntu/arm coreclr w cross-build on ubuntu x instruction sudo time cross/build-rootfs.sh arm cp arf cross/rootfs/arm work/dotnet/rootfs-coreclr time rootfs_dir=/work/dotnet/rootfs-coreclr/arm build.sh arm debug verbose clean cross corefx w cross-build on ubuntu x instruction sudo time cross/build-rootfs.sh arm cp arf cross/rootfs/arm work/dotnet/rootfs-corefx time rootfs_dir=/work/dotnet/rootfs-corefx/arm build.sh native arm debug clean cross time build.sh managed debug clean verbose compilation with linux/arm emulator rootfs for linux/arm coreclr w native-build on linux/arm emulator cd linux-arm-emulator start.sh select menu source dot/setenv/setenv_coreclr.sh cd nfs/coreclr please read doc/nfs.txt file for details time build.sh arm-softfp cross clean verbose coreclr w cross-build on ubuntu x):sudo mount linux-arm-emulator/platform/rootfs-tm.ext work/dotnet/rootfs-coreclr/linux-arm-emulatorcd coreclr vi cross/arm-softfp/toolchain.cmake diff git a/cross/arm-softfp/toolchain.cmake b/cross/arm-softfp/toolchain.cmakeindex ab..eeaa a/cross/arm-softfp/toolchain.cmake b/cross/arm-softfp/toolchain.cmake set(cmake_system_processor armvl specify the toolchain set(toolchain arm-linux-gnueabi)+set(toolchain_custom armvl-tizen-linux-gnueabi set(toolchain_prefix toolchain set(cmake_c_compiler toolchain_prefix}gcc set(cmake_cxx_compiler toolchain_prefix}g add_compile_options(-mfpu=vfpv add_compile_options(--sysroot=${cross_rootfs set(cross_link_flags cross_link_flags target toolchain})-set(cross_link_flags cross_link_flags b${cross_rootfs}/usr/lib/gcc/${toolchain})-set(cross_link_flags cross_link_flags l${cross_rootfs}/lib/${toolchain})+set(cross_link_flags cross_link_flags b${cross_rootfs}/usr/lib/gcc/${toolchain_custom})+set(cross_link_flags cross_link_flags l${cross_rootfs}/usr/lib/gcc/${toolchain_custom set(cross_link_flags cross_link_flags sysroot=${cross_rootfs vi cross-build-corclr-emul.sh coreclr cross-build start usr/bin/env bashchroot=/work/dotnet/rootfs-coreclr/linux-arm-emulatorrootfs_dir=${chroot cplus_include_path=$chroot/usr/lib/gcc/armvl-tizen-linux-gnueabi/../include/c++/:$chroot/usr/lib/gcc/armvl-tizen-linux-gnueabi/../include/c++/armvl-tizen-linux-gnueabi/:$chroot/usr/include/llvm/:$chroot/usr/include/llvm-c/:$chroot/usr/local/include cxxflags=-wno-deprecated-declarations build.sh arm-softfp cross debug clean verbose clang coreclr cross-build end corefx w native-build on linux/arm emulator in progress do unit test of coreclr on raspberry pi boardwork@pi cd coreclr/tests/work@pi time runtest.sh testrootdir=/home/pi/coreclr/bin/tests/windows_nt.x.debug testnativebindir=/home/pi/coreclr/bin/obj/linux.arm.debug/tests coreclrbindir=/home/pi/coreclr/bin/product/linux.arm.debug mscorlibdir=/home/pi/coreclr/bin/product/linux.arm.debug corefxbindir=/home/pi/corefx/bin/linux.anycpu.debug corefxnativebindir=/home/pi/corefx/bin/linux.arm.debug todo stabilize the file system consistency of guestos support sshfs completely separated a floating point e.g softfp and hard-fp infrastructure changelog refer to the doc/changelog.txt file.end
141426185,3776,https://api.github.com/repos/dotnet/coreclr/issues/3776,ramarag,1,0,0,0,0,0,sequence of events:git fetch allgit merge upstream/mastergit clean dxf build skipnative skipmscorlib tests\runtest.cmdeverything works finemake test changesbuild skipnative skipmscorlib tests\runtest.cmdeverything works finewait for hoursdo a build skipnative skipmscorlibsee the error:buildtest starting the managed tests buildbuildtest using environment c:\program files x)\microsoft visual studio common\tools\vsdevcmd.batbuildtest invoking msbuild restoring all packages...exec error package dependencies must specify a version range e:\git\coreclr\tests\build.proj e:\git\coreclr\tests\build.proj error msb the command set core_root e:\git\coreclr\tests..\tools\dotnetcli/bin/dotnet.exe restore packages e:\git\coreclr\tests..\packages source source source e:\git\coreclr\tests\src exited with code exec error package dependencies must specify a version range e:\git\coreclr\tests\build.proj e:\git\coreclr\tests\build.proj error msb the command set core_root e:\git\coreclr\tests..\tools\dotnetcli/bin/dotnet.exe restore packages e:\git\coreclr\tests..\packages source source source e:\git\coreclr\tests\src exited with code
140077312,3654,https://api.github.com/repos/dotnet/coreclr/issues/3654,ramarag,0,0,0,0,0,1,the new generated code is c++#define stackstring_h_standlone include stdlib.h#include pal_mstypes.h#include pal_error.h#include pal.h#define pal_free free#define pal_realloc realloc#include pal/stackstring.hpp#include tpdotnetruntime.hextern c ulong fireetxplatgcallocationtick_v const unsigned int allocationamount const unsigned int allocationkind const unsigned short clrinstanceid const unsigned int allocationamount const void typeid pcwstr typename const unsigned int heapindex ulong error error_write_fault if eventxplatenabledgcallocationtick_v return error_success int typename_path_size pathcharstring typename_ps int typename_full_name_path_size pal_wcslen(typename sizeof(wchar char typename_full_name typename_ps.openstringbuffer(typename_full_name_path_size if(typename_full_name null){return error_write_fault typename_path_size widechartomultibyte cp_acp typename typename_full_name typename_full_name_path_size null null asserte(typename_path_size typename_full_name_path_size typename_ps.closebuffer(typename_path_size if typename_path_size return error_invalid_parameter tracepoint dotnetruntime gcallocationtick_v allocationamount allocationkind clrinstanceid allocationamount const size_t typeid typename_full_name heapindex error error_success;return error;} the old generated code is c++extern c ulong fireetxplatgcallocationtick_v const unsigned int allocationamount const unsigned int allocationkind const unsigned short clrinstanceid const unsigned int allocationamount const void typeid pcwstr typename const unsigned int heapindex ulong error error_write_fault if eventxplatenabledgcallocationtick_v return error_success int typename_path_size int typename_full_name_path_size widechartomultibyte cp_acp typename null null null char typename_full_name null typename_full_name char*)malloc(typename_full_name_path_size*sizeof(char asserte(typename_full_name null if(typename_full_name null){goto lexit typename_path_size widechartomultibyte cp_acp typename typename_full_name typename_full_name_path_size null null asserte(typename_path_size typename_full_name_path_size if typename_path_size error error_invalid_parameter goto lexit tracepoint dotnetruntime gcallocationtick_v allocationamount allocationkind clrinstanceid allocationamount const size_t typeid typename_full_name heapindex error error_success;lexit if typename_full_name null free(typename_full_name);}return error
140033993,3643,https://api.github.com/repos/dotnet/coreclr/issues/3643,gkhanna79,0,0,0,0,0,1,x publish packages tracked by this issue x publish symbol packages tracked by x enable signing tracked by x enable linux build definitions tracked by this issue x enable versioning of binaries tracked by and
139766956,3633,https://api.github.com/repos/dotnet/coreclr/issues/3633,jamesqo,9,0,0,0,0,0,lots of times for readability i use constant_string.length instead of in my code for example csharpstring textafterfoo(string s s.substring(s.indexof(foo foo.length a lot more readable than it would be nice if ryujit could optimize this as a jit-time constant so a string wouldnt have to actually be loaded and called length on.category:cqtheme:basic-cqskill-level:intermediatecost:medium
139253832,3581,https://api.github.com/repos/dotnet/coreclr/issues/3581,nietras,1,0,0,0,0,0,ilasm.exe and ildasm.exe are already part of coreclr however there does not appear to be any nuget packages for them since these sometimes are useful for scripting build or similar it would be great to have these as separate nugettable packages.this issue originates from
139252519,3579,https://api.github.com/repos/dotnet/coreclr/issues/3579,nietras,1,0,0,0,0,0,ilasm.exe and ildasm.exe are already part of coreclr however another useful tool is ilsub.exe il substituter see a tool for substituting a method body with hand-written il e.g as in csharp methodimpl(methodimploptions.aggressiveinlining ilsub sizeof t ret public static int sizeof
139140381,3565,https://api.github.com/repos/dotnet/coreclr/issues/3565,jackfree,2,0,0,0,0,0,the implementation of tostring within enum.cs ends up calling a getenumname method inside getenumname we end up calling getenumdata twice the first from a call to array values getenumrawconstantvalues and the second from string names getenumnames();this is rather costly if done repeatedly and can account for a lot of superfluous memory allocation and sorting there are a few problems here getenumdata could simply be called once from public static string getname preventing the second call and double allocations altogether and the names and values could be stored in a local enum.tostring does a lot of work and a lot of allocations which is not really expected for a simple tostring call and it could easily cache the results there is already code in rttype.cs inside the method getenumvalue which does exactly this it caches the results and does not re-sort and re-allocate for every call to enum.tostring so in theory with a simple one line change we could swap out string retval getname(et value inside enum.cs with retval et.getenumvalue(value since internalformat already has an object of type runtimetype
138683770,3534,https://api.github.com/repos/dotnet/coreclr/issues/3534,nietras,1,0,0,0,0,0,ilasm.exe and ildasm.exe are already part of coreclr however there does not appear to be any nuget packages for them since these sometimes are useful for scripting build or similar it would be great to have these as separate nugettable packages.in fact it would be great if there would be a whole family of il tools e.g.: ilasm.exe il assembler generates a portable executable pe file from common intermediate language cil code. ildasm.exe il disassembler takes a portable executable pe file that contains intermediate language il code and creates a text file suitable as input to ilasm.exe . ilsub.exe il substituter see a tool for substituting a method body with hand-written il e.g as in csharp methodimpl(methodimploptions.aggressiveinlining ilsub sizeof t ret public static int sizeof
137459391,3439,https://api.github.com/repos/dotnet/coreclr/issues/3439,redknightlois,4,0,0,0,0,0,"found this trying to optimize a very low level memory addressing algorithm suddenly i noticed that we were doing the idiv twice repro on rc csharp public class program public long dividend methodimpl(methodimploptions.noinlining public long run(long parameter long div parameter dividend long mod parameter dividend return div mod public static void main(string args random r new random var p new program p.dividend long value p.run console.writeline(${value console.readline will output in x but will also happen in x asmffeecc mov rcx,qword ptr rcx ffeecc mov rax,r instructions to prepare for idiv ffeecca cqo ffeeccc idiv rax,rcx parameter dividendffeeccf mov r,rax r divresult ffeecc mov rax,r instructions to prepare for idiv ffeecc cqo ffeecc idiv rax,rcx parameter dividendffeecca lea rax, r+rdx rax divresult modulus this could be written as asmffeecc mov rcx,qword ptr rcx ffeecc mov rax,r instructions to prepare for idiv ffeecca cqo ffeeccc idiv rax,rcx parameter dividendffeecc add rax,rdx rax divresult modulus this is pretty common in addressing modes or accessing matrix locations etc everywhere you have a row and a column you will have such an structure.category:cqtheme:div-mod-remskill-level:expertcost:large"
134539525,3226,https://api.github.com/repos/dotnet/coreclr/issues/3226,m08pvv,1,0,0,0,0,0,please provide intrinsics for operations like vprold vprord etc.this instructions are quite often used in functions like hash functions and its necessary to have intrinsics for the operations for the best performance its not always possible to leave managed code for calculations because of related overhead.it would be really nice to have this intrinsics in ryujit and in system.numerics.vectors
133801766,3184,https://api.github.com/repos/dotnet/coreclr/issues/3184,jack-pappas,1,0,0,0,0,0,"with the current net apis theres no way to use the tryparse methods e.g for int double datetime on just part of a string instance a substring the only way to implement such a thing using the current tryparse apis is to first call string.substring(int,int on the string to first extract the substring then pass the new string instance to whatever tryparse method youre calling the downside is that this allocates an unnecessary string instance for every field you need to extract the only workaround is to manually implement the specific parsing method you need but then you lose the extra functionality provided by the parse tryparse methods such as octal and hex integer parsing.for example double.tryparse would get an additional overload with a signature like csharppublic static bool tryparse(string s int startindex int length out double result"
133110408,3142,https://api.github.com/repos/dotnet/coreclr/issues/3142,benaadams,1,0,0,0,0,0,to allow buffer pooling at coreclr level.for example k of streamreader s allocates a fair bit for both char and byte ! streamreader
130491384,2959,https://api.github.com/repos/dotnet/coreclr/issues/2959,CarolEidt,2,0,0,0,0,0,currently even under the unix amd abi vector
130197760,2944,https://api.github.com/repos/dotnet/coreclr/issues/2944,MaceWindu,6,0,0,0,0,0,see connect issue as wont fix without any comment is not nice this issue makes decimal completely useless as a key in collections that rely on gethashcode result like dictionary or hashset
128404127,2834,https://api.github.com/repos/dotnet/coreclr/issues/2834,Marqin,1,0,0,0,0,0,"hello,most distributions ubuntu arch etc moved to libicu and system.globalization.native.so bundled with dnx coreclr does need to dynamically link libicu i see two possible solutions bundle libicu with coreclr its mit licensed from what i see build two versions of system.globalization.native.so and make dnx install that one which will be working on target distro check icu version or just name it differently and document in install notes how to swap those so"
127462753,2725,https://api.github.com/repos/dotnet/coreclr/issues/2725,jkotas,9,0,0,0,0,0,c/c compilers allows passing hints to the optimizer using assume or similar constructs it would be useful to have same capability in net one use case was discussed in unsafe.assume((p xf unsafe.write>(p v); category:proposaltheme:optimizationskill-level:expertcost:large
127186002,2715,https://api.github.com/repos/dotnet/coreclr/issues/2715,eiriktsarpalis,3,0,0,0,0,0,it has recently come to my attention that coreclr has eliminated iserializable while i believe that this is a move in the right direction it seems to have also removed the only way possible to correctly serialize exceptions in net serialization of exceptions is tricky because they are objects which encapsulate two types of data data defined at construction time such as message innerexception or any other fields defined by the particular exception implementation data appended by the runtime such as stacktrace importantly this is data that cannot be modified by the user without resorting to reflection.a correct exception serialization should carry along both types of data this is very important in distributed frameworks such as akka.net mbrace and i would imagine orleans too so my question here is what will coreclr be offering as a replacement scheme for serializing exceptions
126937984,2688,https://api.github.com/repos/dotnet/coreclr/issues/2688,stephentoub,4,0,0,0,0,0,sigterm is meant to be used for graceful shutdown of an app the runtime should handle it by doing the equivalent of environment.exit then with apps will also be able to plug in their own cleanup thatll be triggered on any graceful shutdown including those triggered by sigterm.as an example docker stop will initially send a sigterm to give the app a chance to gracefully shutdown before it eventually then sends sigkill if the process is still alive
125730867,2591,https://api.github.com/repos/dotnet/coreclr/issues/2591,omariom,18,0,0,0,0,1,if jit could treat the calls like typeof(t).isvaluetype typeof(iinterface).isassingnablefrom(typeof(t etc as jit time constants that could allow us to write more performant generic code.category:cqtheme:type-intrinsicsskill-level:intermediatecost:large
125416559,2555,https://api.github.com/repos/dotnet/coreclr/issues/2555,clrjunkie,2,0,0,0,0,0,for example are all writes volatile does lock still generate a full barrier
124915886,2527,https://api.github.com/repos/dotnet/coreclr/issues/2527,matty-hall,4,0,0,0,0,0,where on earth is the source to peverify in reading the ecma spec there are often times ambiguities in the language used and i find myself wanting to go look at how peverify handles a given construct ive search the tree but the only references ive found seem to be in validator.cpp which is loading peverify.dll dynamically so where the heck is its source
123131658,2430,https://api.github.com/repos/dotnet/coreclr/issues/2430,benaadams,4,0,0,0,1,0,array.copy buffer.blockcopy are up to x times slower than what can currently be written using managed c for byte copies bytes.as these are the low level copy apis they should be faster than anything that can be written using managed code.the illyriadgames/bytearrayextension repository adds a vectorizedcopy extension method for byte that demonstrates this speed-up and i assume potentially more gains could be made at the clr level. ! performance graph buffer.blockcopy is essentially calling memmove would this effect other copies e.g structs passed as parameters as they are essentially small copy operations
122943609,2385,https://api.github.com/repos/dotnet/coreclr/issues/2385,jods4,30,0,0,0,0,0,the following issue was filed twice at roslyn dotnet/roslyn and dotnet/roslyn where gafter suggested that this optimization should be done by the jit rather than by the c compiler this is why i am copy-pasting the issue in this repo minus some comments that were only relevant to roslyn).---linq the enumerable flavor is a huge productivity boost unfortunately it comes with an additional runtime cost more delegates calls often lambda captures more allocations this means that on hot paths linq may not be an appropriate choice actually ive read that roslyn avoids linq on hot paths for this very reason.in many most cases the compiler could turn the linq code into optimized for foreach loops the proof that this is possible is that linqoptimizer from nessos does just that at runtime.i suggest that roslyn performs the transformation done by linqoptimizer at compiler-time when it can i.e no call to unknown methods no unsupported construct if it cant it bails out to the library-based approach used today.benefits everyone gets a speed boost x on some queries and reduced memory usage for free even people who dont know about linqoptimizer i.e almost everyone this makes linq usable again in more situations transformation happens at compile-time today this can be done with linqoptimizer but at the cost of creating expression trees and compiling them at runtime main drawback is certainly that this is a large and complex code transformation to include and support in the compiler i think that it fits well with the current theme of creating a leaner more performant language with reduced memory allocations and i hope youd think its worthy of including in the compiler proper.category:proposaltheme:optimizationskill-level:expertcost:extra-large
121357604,2285,https://api.github.com/repos/dotnet/coreclr/issues/2285,varocarbas,1,1,0,0,0,0,since some months ago i have been aware about the problems that the parsing methods at least parse and tryparse of various numerical types at least decimal and double have when dealing with thousands separators at least in net in both c and vb.net the following c sample code illustrates the point well c#string stringval decimal decval m;if decimal.tryparse(stringval numberstyles.any cultureinfo.invariantculture out decval this part will be reached because decimal.tryparse thinks that is a valid number} such misbehaviour can be replicated under many different conditions the basic idea is that the parsing approaches dont understand what the thousands separators really imply i.e groups of numbers in the aforementioned example).today i focused my analysis of the code on the decimal type and found parsenumber mscorlib\src\system\number.cs the way in which this method treats the thousands separators in all their forms explains perfectly the observed behaviour it focus the analysis on valid/invalid characters and doesnt bring into account the size of the group at any point.my proposal consists in forcing the corresponding methods to trigger an error when the thousands separators arent in the right positions my intention is firstly focusing on the decimal type although the aforementioned method is most likely used by other types too after having ready a good enough correction for decimal i will analyse the remaining types in detail and perform additional changes if required.the correction will consist in analysing the input string in case of including thousands separators their locations would be checked if this analysis fails no conversion to number would be performed in principle i am planning to take advantage from the current implementation more specifically a loop analysing all the characters and rely on low level approaches although i have still to think carefully about the exact algorithm
120968965,2265,https://api.github.com/repos/dotnet/coreclr/issues/2265,fuszenecker,1,0,0,0,0,0,the error message the given key was not present in the dictionary should be a bit more informative it could also tell which key is not found in the dictionary
120218811,2222,https://api.github.com/repos/dotnet/coreclr/issues/2222,tmds,2,0,0,0,0,0,i am trying to compile a project for core i get a ton of errors some example the name thread does not exist in the current context the name appdomain does not exist in the current context the name timezone does not exist in the current context uri does not contain a definition for hexescape type does not contain a definition for gettypecode assemblybuilderaccess does not contain a definition for runandsave type does not contain a definition for isinterface and no extension method isinterface accepting a first argument of type type could be found are you missing a using directive or an assembly reference typebuilder does not contain a definition for createtype and no extension method createtype accepting a first argument of type typebuilder could be found are you missing a using directive or an assembly reference type does not contain a definition for getcustomattributes and the best extension method overload customattributeextensions.getcustomattributes(memberinfo type bool requires a receiver of type memberinfo socket does not contain a definition for handle and no extension method handle accepting a first argument of type socket could be found are you missing a using directive or an assembly reference bindingflags does not contain a definition for exactbindingsome of these errors should be solvable by adding project.json dependencies.other errors are not implemented yet and yet others will never be implemented.so i wonder about a few things how do i figure out which dependencies to add how can i know what functionality isnt available today how can i know what functionality isnt planned to be available in the foreseeable future how can i match the version i am using to the source repos online e.g what code is in system.runtime version when i look inside the source repos i see some of the things i get errors about are present e.g exactbinding getcustomattributes createtype so why do i get the errors?thanks
119539744,2191,https://api.github.com/repos/dotnet/coreclr/issues/2191,stephentoub,2,0,0,0,0,0,see the discussion at c#using system;using system.reflection;using system.reflection.emit;class mytype).makegenerictype(dummtype fails with: unhandled exception system.typeloadexception collectible type mytype dummy may not have thread or context static members at system.runtimetype.makegenerictype(type instantiation at repro.main in program.cs:line this means that a developer writing a general-purpose library with generic types cant use threadstatic because it would break a consumer of the library and/or that a developer writing a collectible assembly needs to know the implementation details of generic types being used neither of those is very good.related to
119516716,2188,https://api.github.com/repos/dotnet/coreclr/issues/2188,hickford,1,0,0,0,0,0,list.binarysearch has an overload that takes an icomparer.sort has both overloads the same applies for array.binarysearch
119362604,2184,https://api.github.com/repos/dotnet/coreclr/issues/2184,GSPP,1,0,0,0,0,0,the parallel class and plinq are inconsistent in the way the degree of parallelism can be specified for plinq the dop is always exact for parallel the dop is the maximum that will be used.whether you want an exact or a max dop depends on the problem for example when doing io we often want an exact dop that was empirically determined to be optimal the tpl cannot possibly know the correct dop for magnetic disks the best dop might be for ssds it might be for web services it might be extremely high.this means that we effectively cannot use parallel for io depending on the number cpus and the thread-pool state wildly different actual dops might be chosen the app might work fast on one machine slow on another or slow at a certain time of day depending on cpu load or crash the webservice being called on a client with many cpu cores.i mean the previous paragraph literally if you disagree please explain how parallel can be used effectively for io given the challenges detailed here.plinq then does not support a max dop which can be an efficiency issue for cpu bound workloads as far as i can tell plinq cooperates with other plinq queries through use of the thread-pool to avoid oversubscription thats good but it does not work either due to the related issue unbounded number of threads try this: system.threading.tasks.task.waitall(enumerable.range select(i system.threading.tasks.task.run parallelenumerable.range forall thread.sleep());})).toarray()); also it is strange from an api perspective to have the very analogous apis parallel and plinq behave differently in this aspect i see no fundamental reason this has to be so.another problem is that plinq has a maximum dop of this has been raised from as i just noticed which is great can we make this essentially unlimited?you might say who in his right mind wants to start more than threads well if there is enough ram and this is a bit process it can be a very convenient and reliable way to increase the dop often it is not the right choice for production code but for lower quality dev tools it can be totally fine to do that.another problem is that plinq does not support using a custom taskscheduler i have needed that recently to globally limit the parallelism induced by certain plinq queries i wanted each query to use a dop of n but globally in the whole app i wanted to also enforce a max dop of n the solution for that would have been to use a custom taskscheduler that limits the dop to n and make plinq use that.after a cursory look at the plinq source it seems that basic support for custom task schedulers is architecturally present e.g spoolpipeline i hope this would be reasonably easy to enable.i propose plinq should be able to have a max dop parallel should be able to have an exact dop the plinq dop limit should be removed make plinq be able to execute on a given taskscheduler .in this issue i have written up a few challenges that i run into frequently im also an active answering user on stack overflow in tpl-related tags these issues come up all the time
119345306,2183,https://api.github.com/repos/dotnet/coreclr/issues/2183,mikedn,1,0,0,0,0,0,c#static int foo(int x int sum for int i i i sum x return sum;} generates g_m_ig ba mov edx x bc mov eax ecx fea imul edx:eax edx bc mov eax edx b mov edx dword ptr rsp+h d add edx eax cef shr eax d add edx eax ffc inc rd fa cmp rd mov dword ptr rsp+h edx cdd jl short g_m_ig it also does only partial cse c#return x x generates g_m_ig b mov eax x fe imul edx:eax ecx bc mov eax edx bc mov rd eax cef shr rd c add eax rd f cmp eax fd jg short g_m_ig b mov eax x fe imul edx:eax ecx bc mov eax edx somehow the shift disappeared but not the multiplication c add eax rdg_m_ig c retg_m_ig b mov eax g_m_ig c ret cse works fine in jit which doesnt do reciprocal multiplication both cse and hoisting work fine in ryujit for division by power of shouldnt reciprocal multiplication have been done in lowering instead of morphing the generated ir is larger and more likely to hinder further optimization rather than exposing new optimization opportunities
119262639,2179,https://api.github.com/repos/dotnet/coreclr/issues/2179,benaadams,6,0,0,0,0,0,stream interface segregation problem statementstream is a leaky abstraction with its behavior determined at runtime with canread canseek cantimeout canwrite and notsupportedexception rather than compile time contracts this also means adapter wrapping classes like textwriter and its subclasses which dont share streams interface are required to enforce consistency which leads to higher allocations however their constructors throw so it is still runtime discovery.the wide interface scope of stream also suffers from ownership confusion due to it being passed as a idisposable leading to clarifying methods such as streamwriter(stream stream encoding encoding int buffersize bool leaveopen )also its large api surface is problematic for testing dependency injection and scope control as rarely is it desirable to expose a directly derived type rather than a secondary wrapper for the derived type in a public api due to this large surface area.these effect cause the api surfaces to be defined at the fringes rather than in the bcl reducing easy interoperability between rd party components ideally the ownership of behavior would be brought back to the bcl which would allow greater component reuse and communication without requiring custom adapters or glue code for each interaction inefficienciescreating an httpcontext that supports keepalive request response and duplex streams from a socket currently would requires the creation of networkstream objects per request which maybe be several million extra objects created per second.this is because disposable control of the socket cant be passed on and read shouldnt have write ability and write shouldnt have read ability csharppublic partial class httpcontext private stream stream public httpcontext(socket socket stream new networkstream(socket fileaccess.readwrite true duplexstream new networkstream(socket fileaccess.readwrite false requeststream new networkstream(socket fileaccess.read false responsestream new networkstream(socket fileaccess.write false public stream duplexstream get set public stream requeststream get set public stream responsestream get set this situation could be improved by the constructor taking a disposable r+rw interface easier to mock for testing for example they could be a file input and a file output combined in a class that implemented the interface this could then be exposed it to the properties via up-casting to its parent interfaces which only requires a single stream object as shown below csharppublic partial class httpcontext private iduplexstreamasync(t stream where t iblockingreader(this iblockingwriter(this iblockingreader(this ireaderasync(iseekableduplexstream.write(byte value writebyte(value interface conversionpublic ireadstreamasync textreader would need the following extra method defined to support cancellationtoken parameter csharppublic virtual task textwriter would need the following extra methods defined to support cancellationtoken parameter and the string based interface csharppublic virtual task writeasync(string value cancellationtoken cancellationtoken public virtual async task writeasync(string values if values null values.length return for var i i values.length i await writeasync(values i ).configureawait(false return;}public virtual async task writeasync(string values cancellationtoken cancellationtoken if values null values.length return for var i i values.length i await writeasync(values i cancellationtoken).configureawait(false return use cases copyto copytoasync extensionsas shown above as part of the api additions copyto and copytoasync can have their main method defined as extension methods but only need the up-cast types iblockingreader(null private readonly static nullstream s_nullstream new nullstream public readonly static iblockingreader.blockingwriter);}public task donothingasync(ireaderasync.writerasync request response streamsreturning to the request response streams shown in the inefficiencies section of the problem statement that demonstrated an improved pure interface approach.however with the additional stream astype changes the entry point can still be maintained and the same result can be achieved as shown below csharppublic partial class httpcontext private iduplexstreamasync
118469123,2144,https://api.github.com/repos/dotnet/coreclr/issues/2144,benaadams,1,0,0,0,0,0,throwing an unhandled exception at the top level of a threadpool thread either by using threadpool.queueuserworkitem or use of async void will crash the process by design and they cannot be stopped and are at the top of the stack.it would be better if threadpool had a something like taskscheduler.unobservedtaskexception to catch these events so they could be logged/handled
113991045,1890,https://api.github.com/repos/dotnet/coreclr/issues/1890,davidfowl,2,0,0,0,0,0,can we make crossgen smarter and just have it walk the closure and do what ngen did it would make it much more efficient and easier on us than having to call it per assembly ourselves
112940747,1856,https://api.github.com/repos/dotnet/coreclr/issues/1856,ygc369,4,0,0,0,0,0,when gc of generation or finishes all garbage objects with finalizer should be moved to heap zone of generation thus these objects would be collected next generation gc after their finalizers are called
111744417,1784,https://api.github.com/repos/dotnet/coreclr/issues/1784,ygc369,31,0,0,1,0,5,if a small objects reference is never stored in heap or static variables only stored in local variables it is temporary the clr or jit should alloc it on stack and free it in time thus gc pressure would be lower this feature is just like escape analysis technique in jvm ive suggested this in roslyn forum but they said i should suggest here.category:cqtheme:stack-allocationskill-level:expertcost:large
110040832,1684,https://api.github.com/repos/dotnet/coreclr/issues/1684,Rohansi,3,0,0,0,0,0,this adds support for collectible assemblies that are loaded with assemblyloadcontext as of right now the managed side of this is very incomplete but i am able to load and call something from an assembly let it get collected by the gc and can see the assembly disappear from the appdomain assembly list.my current issues with this are x the managed assemblyloadcontext needs changes to properly clean up after itself free gc handle free native instance x assemblies are not fully unloaded from the appdomain x assembly files are locked on disk even after theyre collected x assemblies might be cached too x might be able to get rid of the empty assembly and just lazily create a loaderallocator x dependencies of collectible assemblies arent loaded in the same context and when they are they dont unload properly theres probably some gc holes in there x need a crst for the native assemblyloadcontext x memory leaks load run collect loop shows memory usage slowly increasing probably need more error checking im going to need to write a lot of tests for thisthis is related to issue
105077252,1505,https://api.github.com/repos/dotnet/coreclr/issues/1505,mikedn,1,0,0,0,0,0,if the finally block in a try / finally pair does nothing then they can be eliminated such finally blocks are produced when foreach is used with bcl collections such as list
103654887,1453,https://api.github.com/repos/dotnet/coreclr/issues/1453,jskeet,2,0,0,0,0,0,consider this code csharppublic class test public static void main object x new object string y string x that produces a nice informative error system.invalidcastexception unable to cast object of type system.object to type system.string.change the string y string x to int y int x and we get system.invalidcastexception specified cast is not valid.this is far less useful as an example of when this is a pain consider calling sqlcommand.executescalar if youre not entirely sure before trying what type is going to be used for the result you may know its an integer type but not which its annoying to have to use a local variable to report the actual type in a log or debug session before the cast if the exception just provided the same information that it does for a reference cast it would streamline development
100227719,1376,https://api.github.com/repos/dotnet/coreclr/issues/1376,matty-hall,1,0,0,0,0,0,"runtimetype.getenumname and runtimetype.isenumdefined both throw exceptions for enums whose underlying type is intptr or uintptr i havent tested other code paths extensively but id imagine that there are probably other places that this issue surfaces due to how unusual this construct is things actually do work for enum types with an underlying type of boolean or char which is somewhat interesting given that those feel less integery to me than native integers even though clearly theyre ints on the stack).now while c doesnt allow you to create such an enum the spec does which is i presume why peverify has no problems with this construct either heres the relevant portion of the spec i collected common language specification rules cls rule the underlying type of an enum shall be a built in cls integer type the name of the field shall be value and that field shall be marked rtspecialname i...)thats not very specific but elsewhere it is ii enums an enum short for enumeration defines a set of symbols that all have the same type a type shall be an enum if and only if it has an immediate base type of system.enum since system.enum itself has an immediate base type of system.valuetype see partition iv enums are value types ii the symbols of an enum are represented by an underlying integer type one of bool char int unsigned int int unsigned int int unsigned int int unsigned int native int unsigned native int so while i get that this is odd the spec certainly allows it and it seems arbitrary that bool and char work but intptr/uintptr dont.repro: .assembly extern mscorlib publickeytoken b a c e ver assembly enumtest hash algorithm x ver module enumtest.exe.imagebase x.file alignment x.stackreserve x.subsystem x.corflags x.class private auto ansi beforefieldinit enumtest.program extends mscorlib system.object method private hidebysig static void main(string args cil managed entrypoint ldstr boolenum value validity ldc.i call string enumtest.program::enumtostring(!!u underlyingvalue cil managed locals init object boxed e enumvalue class mscorlib system.exception ex string cs ldarg box u stloc ldloc unbox.any e stloc try ldloca.s enumvalue constrained e callvirt instance string mscorlib system.object::tostring stloc leave.s aftertry catch mscorlib system.exception stloc ldstr exception ldloc callvirt instance string mscorlib system.exception::get_message ldstr call string mscorlib system.string::concat(string,string,string stloc leave.s aftertry aftertry ldloc ret method public hidebysig static string enumvalidity(!!u underlyingvalue cil managed locals init object boxed class mscorlib system.exception ex string cs ldarg box u stloc try ldtoken e call class mscorlib system.type mscorlib system.type::gettypefromhandle(valuetype mscorlib system.runtimetypehandle ldloc call bool mscorlib system.enum::isdefined(class mscorlib system.type,object brfalse.s enuminvalid ldstr valid stloc leave.s aftertry enuminvalid ldstr invalid stloc leave.s aftertry catch mscorlib system.exception stloc ldstr exception ldloc callvirt instance string mscorlib system.exception::get_message ldstr call string mscorlib system.string::concat(string,string,string stloc leave.s aftertry aftertry ldloc ret method public hidebysig specialname rtspecialname instance void ctor cil managed ldarg call instance void mscorlib system.object::.ctor ret class public auto ansi sealed enumtest.booleanenum extends mscorlib system.enum field public specialname rtspecialname bool value field public static literal valuetype enumtest.booleanenum yes bool(true)}.class public auto ansi sealed enumtest.charenum extends mscorlib system.enum field public specialname rtspecialname char value field public static literal valuetype enumtest.charenum thelettera char()}.class public auto ansi sealed enumtest.intptrenum extends mscorlib system.enum field public specialname rtspecialname native int value field public static literal valuetype enumtest.intptrenum one uint(x)}.class public auto ansi sealed enumtest.uintptrenum extends mscorlib system.enum field public specialname rtspecialname native unsigned int value field public static literal valuetype enumtest.uintptrenum two uint(x"
99258297,1350,https://api.github.com/repos/dotnet/coreclr/issues/1350,redknightlois,1,0,0,0,0,0,last couple of days i had been a very bad time dealing with debugging a project the debugger would crash msvcmon.exe and windows will stop responding even ctrl-alt-del wont work after disabling ryujit everything came back to normal
96728289,1279,https://api.github.com/repos/dotnet/coreclr/issues/1279,RossNordby,1,0,0,0,0,0,"the current stackalloc implementation uses a tight loop of push instructions to allocate and fill in the memory for example stackalloc int yields: fedac mov eax,hfedac push fedacb push fedacd sub rax,hfedad jne fedac given that the use of stackalloc is often performance related it would be nice if the stack pointer just jumped directly to the end and left the memory as-is this appears to be permitted by the c spec section the content of the newly allocated memory is undefined.changing this behavior would nastily break applications that relied on the zeroing despite spec im not sure how much of a problem this would be its a niche feature that tends to be used for very specific reasons and older jit versions seemed to leave the memory as-is according to some postings circa"
94956475,1235,https://api.github.com/repos/dotnet/coreclr/issues/1235,ayende,7,0,0,0,0,0,one of the hardest things that we have to handle when writing server application or system software in net is the fact that we dont have good control over memory.this range from simple inability to state how big is this thing to controlling how much memory well use for certain operations.in my case working on ravendb there are a lot of operations that require extensive memory usage over which we have little control the user can specify any indexing function they want and well have to respect that.when doing heavy indexing that can cause several issues in particular it means that we generate a lot of relatively short term data during which other operations also run because we are system software we are doing a lot of i/o which require pinning memory.the end result is that we may have memory with the following layout. useful objects indexing garbage pinned buffers doing i/o indexing garbage pinned buffers that result in high memory fragmentation on gen mostly which is hard to deal with.it also means that when indexing is done we have to cleanup quite a lot of garbage and because the indexing garbage is mixed with stuff that is used right now it either cannot be readily allocated or require a big compaction.it would be great if we had greater control over memory usage being able to define a heap and instruct the clr to allocate objects from it would be wonderful we wont have request processing memory intermixed with background ops memory and we have a good way to free a lot of memory all at once.one option would be to do something like this: using(var heap heap.create(heapoptions.none initial size max size using(heap.allocatefromme var sb new stringbuilder for(var i i i sb.appendline(i console.writeline(sb.tostring this will ensure that all allocations inside the scope are allocated on the new heap the gc isnt involved in collecting items from this heap at all it is the responsibility of the user to take care of that either by explicitly freeing objects rare or by disposing the heap.usage of references to the heap after it is destroyed wont be allowed.alternatively because that might be too hard complex just having a way to do something like heap.allocate(); would be great note that we can do the same right now by allocating native memory and using unsafe code to get a struct pointer back this works but very common types like arrays or strings cannot be allocated in this manner having support for explicit usage like this would greatly alleviate the kind of gymnastics that we have to go through to manage memory
94237564,1226,https://api.github.com/repos/dotnet/coreclr/issues/1226,omariom,2,0,0,0,0,0,there is a small difference between code generated for direct reading of a volatile variable and doing it via volatile.read c#volatile int sharedvar;public int test return sharedvar;}public int test return volatile.read(ref sharedvar asm mov eax dword ptr rcx ret vs cmp dword ptr rcx ecx lea rax bword ptr rcx mov eax dword ptr rax ret category:cqtheme:basic-cqskill-level:expertcost:large
92462160,1191,https://api.github.com/repos/dotnet/coreclr/issues/1191,stephentoub,1,0,0,0,0,0,task supports synchronous and asynchronous continuations when a task completes async continuations are queued to execute and then sync continuations are executed synchronously one after the other though for a variety of reasons the system may choose to treat a synchronous continuation as an asynchronous one never the other way around because you can end up with long chains of these synchronous continuations without any assistance its possible to accidentally construct chains that result in overflowing the stack and terminating the process to handle this task internally has some probes to determine when execution is too deep on the stack to allow continuations to run synchronously e.g however these checks currently only apply to some of the kinds of continuations that can be created for tasks e.g continuewith continuations notably these checks dont currently apply to await so its still possible to create code that overflow in this manner e.g c#using system;using system.threading.tasks;class program static void main const int divedepth func
91896391,1187,https://api.github.com/repos/dotnet/coreclr/issues/1187,hpaiemen,1,0,0,0,0,0,"hi,im currently trying to port code from full framework to dnx core and i encounter most of my problems with the new reflection api here is my problem i need to import at run time dynamically some assemblies that can be saved anywhere on disk so the user most specify an absolute path for the assembly to be loaded in full framework i used assembly.loadfrom(string asmpath method to get the job done but after doing some searches on compatibility with dnx core i understood that it wasnt yet available.i tried something with assemblyname here is the result empty class to import: using system;using system.collections.generic;using system.linq;using system.threading.tasks;namespace classlibrary public class class public class test program using system;using system.collections.generic;using system.linq;using system.threading.tasks;using system.reflection;using system.runtime.loader;namespace consoleapp public class program public void main(string args try assembly myassembly assembly.load(assemblyloadcontext.getassemblyname(@c:\classlibrary.dll catch(exception e console.writeline(e.message console.readline now the console output when running consoleapp assembly.load with a codebase is not supported on windows phone. first error message is probably not up to date since i dont target windows phone device i used vnext class library and vnext console app in visual studio rc and i would like to know if assembly.loadfrom(string asmpath will be implemented for dnx core and if not how can i load assemblies from their absolute or relative path on disk thx"
90232959,1166,https://api.github.com/repos/dotnet/coreclr/issues/1166,omariom,4,0,0,0,0,0,"currently jit treats sealed methods as virtual i use vs rc c# methodimpl(methodimploptions.noinlining) private int testsealedmethodinlining(derived obj return obj.getvalue();}class base public virtual int getvalue(int value return x class derived base public sealed override int getvalue(int value return value testsealedmethodinlining in machine code asm sub rsp,h mov qword ptr rsp+h ,rdx mov rcx,rdx mov edx mov rax,qword ptr rsp+h mov rax,qword ptr rax mov rax,qword ptr rax+h call qword ptr rax+h nop add rsp,h ret what i would expect asm mov rdx qword ptr rdx mov rax ret"
89788776,1161,https://api.github.com/repos/dotnet/coreclr/issues/1161,mikedn,1,0,0,0,0,0,"sample c code c#struct number private double value public static implicit operator number(double value return new number value value public static implicit operator double number number return number.value public static number operator number x number y return x.value y.value class program static int main number x y return int)(x y a portion of the generated code: vmovsd xmm,qword ptr rsp+h vaddsd xmm,xmm,mmword ptr rsp+h xor eax,eaxmov qword ptr rsp+h ,raxmov qword ptr rsp+h ,raxvmovsd qword ptr rsp+h ,xmmmov rax,qword ptr rsp+h mov qword ptr rsp+h ,raxmov rax,qword ptr rsp+h mov qword ptr rsp+ ,raxvmovsd xmm,qword ptr rsp+ vcvttsdsi eax,xmm if int is used intstead of double or if double is used directly instead of number then the generated code is simply mov eax category:cqtheme:structsskill-level:expertcost:large"
88000238,1135,https://api.github.com/repos/dotnet/coreclr/issues/1135,omariom,4,0,0,0,0,0,currently generic list calls array.clear on its underlying array in the implementation of clear removeall removerange mathods it has to do so because the generic argument can contain references which must be freed for gc.but what if it is plain int or any other value type that doesnt have references in it directly or indirectly?if type had a property that could say if the type contains references then clearing the array could be completely skipped.i see a huge performance opportunity here less cpu work less memory traffic and pollution.and not only there if jit considered this property value as a jit time constant then the check itself and the branch of the generated code could be skipped as well other methods could benefit from that without sacrificing a nanosecond like removeat
85253944,1097,https://api.github.com/repos/dotnet/coreclr/issues/1097,masonwheeler,5,0,0,0,0,0,now that weve got a good idea of what we need to do for android support lets try and make it happen!the first step is to build coreclr for arm which is what the majority of android devices run on today shahid-pk has contributed some work towards the goal of getting it to build but he says its incomplete and still needs some work which he doesnt have time to finish at the moment can anyone review this and possibly contribute some missing pieces id help but i know very little c and even less of shell-scripting
77326732,1012,https://api.github.com/repos/dotnet/coreclr/issues/1012,migueldeicaza,16,0,0,0,0,4,currently marshaling in net has three modes ansi unicode platform dependent and auto which picks a good default between those two the meaning of unicode is closely associated with windows utf.there is today no convenient and reliable way to do utf encoding and at best we have an ambiguous definition of what unicode is.there are enough bits on the metadata tables to add these two values.people can resort to custom marshalers slow cumbersome everyone has to do it or manual marshaling or hope that the platform does the right thing anecdotally this also happens to be oldest mono bug that is still open.the world has spoken and utf is the standard we should have first-class support for it both for p/invoke signatures as well as the various helper methods in marshal
75730754,990,https://api.github.com/repos/dotnet/coreclr/issues/990,masonwheeler,4,0,0,0,0,0,in jbevain brought up the possibility that what would be interesting is to tag all proposals that require new il or metadata constructs and when theres enough of them see about pushing for a new revision the only change so far was for generics in one thing thats very noticeably missing from the clr object model is metaclasses coming from a delphi background where metaclasses aka tclass are used all over its quite jarring to find them completely missing basic overview:the delphi object model is quite similar to the clr object model in many ways--this is not surprising as both were designed by the same architect--but one major feature thats missing is the metaclass where system.object contains a gettype method that returns a type object delphi has something very similar except the tclass value that it returns is far more powerful bringing several features that both the clr and jvm object models lack.a metaclass is a fundamentally new kind of primitive value like ints objects and delegates that represents the class itself not a particular instance of the class they are immutable compiler-generated singletons one for each class in the project much like type objects metaclass values and inheritancein the clr its possible to declare a variable of type type and assign type objects to it but its not possible to restrict the allowable types beyond this delphis metaclasses take this a step further a metaclass variable can be declared as type tclass the metaclass of the base object class or as a more restricted metaclass of a specific class in the latter case only a metaclass value of that class or a class derived from it can be assigned to this variable this is statically checked by the compiler in exactly the same way that object instance types are checked.this is important because while a type only contains reflection data for the class it represents and each type object gives access to the exact same set of methods and properties a metaclass has class-scope methods and properties on it much like a class does including virtual methods virtual class methods and constructorsin the clr all methods are either instance-scope methods or static methods with metaclasses a third option is available class-scope methods their this parameter is the metaclass value not an object instance class-scope methods can be declared virtual which means exactly what it intuitively sounds like virtual class-scope methods may be overridden in derived classes and when invoking a virtual class-scope method the method that is called depends on the metaclass it is being invoked upon.the most common and arguably most useful application of this feature is the use of virtual constructors constructors are considered class-scope methods and can be declared virtual just like any other method this makes the factory pattern trivial instantiating an object from a defined hierarchy whose class is not known until runtime is a simple matter of registering the class with a map that resolves to a metaclass and then performing a key lookup and calling a virtual constructor on the metaclass.delphis gui library has been using this technique to good advantage for years now the equivalent on the clr requires the use of activator.createinstance which has a much higher overhead as it must instantiate everything via reflection and the parameters passed cannot be statically verified at compile time a virtual constructor call by contrast has all the type safety benefits of any other virtual method call plug-in functionalityvirtual constructor calls are useful for object factories but also for a kind of inverse factory construct consider the scenario in which a factory needs to produce widget objects of the time it needs to produce a frobwidget but in certain cases it needs to produce a bozwidget instead and the code that actually creates the widgets is several steps removed from the code that makes the decision as to what type is necessary this could get messy very quickly but with metaclasses it can be greatly simplified: class widgetgenerator public metaclass
75680203,987,https://api.github.com/repos/dotnet/coreclr/issues/987,briansull,1,0,0,0,0,0,thee following two cases should generate the same code:public static double runa return math.sqrt math.sqrt();}public static double runb double res math.sqrt math.sqrt return res
75091607,972,https://api.github.com/repos/dotnet/coreclr/issues/972,weshaggard,3,0,0,0,0,0,there has been a number of questions about making the code formatting consistent in mscorlib and it is something we would like to consider doing in the future once we fully understand the codeflow between the sources on github and our internal source that ships in the full net framework the reason we are hesitant to run the formatter right now is there is a lot of code and it would add a lot of risk to the full desktop framework source code a couple of the risks factors stem from things like incorrect merges which are always going to happen when you have a large codebase with code churning on multiple forks and the code formatter will definitely change almost every line of source code in mscorlib other things like renaming fields we simply cannot even do because it will break compatibility with serializers for the full framework at any rate im opening this issue to track the desire to run the code formatter but it will likely not happen for some time
74691359,969,https://api.github.com/repos/dotnet/coreclr/issues/969,ghost,6,0,0,0,0,4,apple brought bit support to arm in other vendors nvidia qualcomm are bringing bit arm architecture in however mips has bit support since del>
74379873,963,https://api.github.com/repos/dotnet/coreclr/issues/963,migueldeicaza,4,0,0,0,0,2,there are cases in particular on osx where native apis are defined in terms of the natural size of the platform this means that apis use bit integers on bit platforms and bit integers in bit platforms.mono uses a poor mans approach to solve this problem and we introduce the structures system.nint system.nuint and system.nfloat that stand for native integer native unsigned integer and native float these data types will be bits or bits depending on the platform.the usual set of operators on ints uints and floats are defined on those structures.the mono runtime then has special support to turn sequences that would invoke those operators into the native representation for it.this means that code that would pass two nint structures and call the addition operator on it are turned into a regular integer addition operation with no performance loss this is the poor mans way of introducing a new data type that is not part of the cil spec.this is what we published on the subject
73958552,952,https://api.github.com/repos/dotnet/coreclr/issues/952,masonwheeler,1,0,0,0,0,0,once we have a linux version fully up and running what will be necessary to get an android version some sort of roadmap for this should be added to docs.thoughts well need linux coreclr working for both x and arm well need at least one activity that starts the coreclr app as a ndk call how will interop with androids java system classes work how will building deployment and debugging work yes before anyone says it xamarin is a thing its licensing makes it an extremely onerous thing however and its essentially impossible to create a third-party open-source development tool to produce android apps with xamarin it would be nice to rectify that
73388010,930,https://api.github.com/repos/dotnet/coreclr/issues/930,akoeplinger,25,0,0,0,0,0,right now coreclr has no good way to handle the differences between platforms when it comes to p/invoking native libraries.e.g imagine i want to call an openssl function on unix the library is called libssl.so/dylib but on windows it is libeay.dll there are countless other examples e.g libz.so vs zlib.dll ).corefx solves this by conditionally compiling the p/invoke code for each platform with the correct library name this seems like a major organizational overhead though and is brittle when new platforms are added.mono does two things to make this much easier it automatically probes for variations of the string passed to dllimport e.g if i specify dllimport(myfoo it tries myfoo.dll myfoo.so libmyfoo.so and so on in the happy case this is enough to find the library on all the platforms dllmap this is for cases where the library name is just too different or if only a certain function should be redirected or only on some specific platforms.in my opinion coreclr should implement something along those lines i know that using dllmap is not really possible since theres no system.configuration stack in net core but it should at least guide an alternate implementation.what do you think? edit i proposed adding dllmap attributes in csharp assembly dllmap(foo foo.dll osname.windows) assembly dllmap(foo libfoo.dylib osname.osx) assembly dllmap(dll=foo target=libfoo.so os=osname.linux) assembly dllmap(dll=dl name=dlclose target=libc.so os=freebsd
72818216,917,https://api.github.com/repos/dotnet/coreclr/issues/917,ghost,10,0,0,0,0,5,musl for alpine clibc for alpine and lilblue and newlib for amigaos cygwin and playstation portable are standard c library implementations for embedded systems which dont include memory management unit mmu net team has plans to target microcontrollers/embedded-systems with coreclr please provide support for those platforms.note that static lib libnix is also available for amigaos or is a list of major c standard libraries implementations
72682303,914,https://api.github.com/repos/dotnet/coreclr/issues/914,mikedn,4,0,0,0,0,0,c code c#static int main(string args return string.isnullorempty(args asm code: g_m_ig cmp dword ptr rcx jbe short g_m_ig b mov rax gword ptr rcx c test rax rax je short g_m_ig cmp dword ptr rax fc sete al redundant fbc movzx rax al redundant c test eax eax redundant jne short g_m_ig c xor eax eax basically the il code after inline contains a ceq followed by a brtrue and the jit compiler doesnt seem capable of folding them.category:cqtheme:basic-cqskill-level:intermediatecost:medium
72320645,895,https://api.github.com/repos/dotnet/coreclr/issues/895,justinvp,3,0,0,0,0,0,fixes dotnet/corefx/issues/notes tests are here dotnet/corefx/pull although the tests in corefx wont exercise these new overloads until the new methods are exposed in system.runtime.dll the tests are written in a way to light up once the methods are available in the meantime i ran the split tests manually in a one-off app compiled against a coreclr mscorlib.dll with the added methods on windows i made the changes as surgical as possible to minimize churn there are some opportunities for stylistic code formatting improvements but i held off on those for this pr./cc ellismg
71212721,833,https://api.github.com/repos/dotnet/coreclr/issues/833,mgravell,1,0,0,0,0,0,see issue
69882723,760,https://api.github.com/repos/dotnet/coreclr/issues/760,aggieben,1,0,0,0,0,0,in building a project im converting to coreclr i ran across this error c:\users\benjamin\projects\miniprofiler\stackexchange.profiling\sqltiming.cs error cs type does not contain a definition for isenum and no extension method isenum accepting a first argument of type type could be found are you missing a using directive or an assembly reference?)whats odd to me about this is that everything i can find online indicates that type should be available and the isenum property should be available fowlers reverse package search finds type in the system.runtime package and i have system.runtime as a dependency in my project.json in the dnxcore framework section however the compiler error happens and dotpeek also says there is no type type in the system.runtime package what have i missed
69128690,731,https://api.github.com/repos/dotnet/coreclr/issues/731,stephentoub,1,0,0,0,0,0,path.max_path and path.max_directory_path are used to set buffer sizes and make decisions about whether paths are valid but theyre hardcoded to win values on unix they should pull the relevant values from pathconf
66950885,659,https://api.github.com/repos/dotnet/coreclr/issues/659,zer0n,44,0,0,4,0,0,im not sure whether this is the appropriate repo to ask this question if not please advise the correct one.i want to do net development in linux i havent been able to do it yet due to lack of important features in mono one of them is c++/cli i wonder whether and/or when this will be available soon
66375670,641,https://api.github.com/repos/dotnet/coreclr/issues/641,reduz,7,0,0,0,0,0,would it be possible to document how c interop happens from embedding into a c application to calling to c from net and calling net functions from c im not finding any docs on how to do this
65570758,603,https://api.github.com/repos/dotnet/coreclr/issues/603,ikopylov,5,0,0,0,0,0,in the corefx issue was the idea to do explicit check whether ireadonlycollection
64149152,555,https://api.github.com/repos/dotnet/coreclr/issues/555,ygc369,2,0,0,0,0,0,i think ive found an effective way to compress loh if clr always alloc every large object at the beginning of a ram page(usually kb per page)then the large object heap(loh can be compressed without much cost clr can compress loh by modifying ram page table and tlb instead of copying data if so small fragmentation maybe still exist less then a memory page size per fragment but there would be no large fragmentation and compressing would be very fast because of no copying to do this os support may be needed fortunately windows os and visual studio are both microsofts softwares so microsoft can implement this at least on windows
64102484,552,https://api.github.com/repos/dotnet/coreclr/issues/552,JoshVarty,38,0,0,2,0,0,"hi there,i would like to start the conversation about collectible assemblies and the clr for reference the user voice for this issue is available here my understanding is that this is currently possible with mono but not the clr.with the new roslyn compiler and projects like scriptcs i think were going to see an increase in the number of users who are dynamically compiling and running code today there is no way to unload an assembly without burning down the entire appdomain smile:).id love to get a feel for what limitations exist that would prevent this feature how much work it might take and whether or not the team felt it was feasible or necessary"
63861251,542,https://api.github.com/repos/dotnet/coreclr/issues/542,stas-sultanov,1,0,0,0,0,0,i would like to suggest to make class string to implement ireadonlylist{char instead of ienumerable{char}.possibly interface should be implemented explicitly because of the length property which is extern and hardcoded in jit on the other hand length could be deprecated and count should be used instead
61688717,445,https://api.github.com/repos/dotnet/coreclr/issues/445,gregoryyoung,8,0,0,0,0,0,is there any timeframe on a profiling api are there any public design docs available at this point?greg
61624171,444,https://api.github.com/repos/dotnet/coreclr/issues/444,stephentoub,2,0,0,0,0,0,as discussed in we are currently brittle with regards to our usage of dlopen which requires that we provide the name of a library that includes version information we need to figure out how we want to handle this for the specific case discussed in for dllimports in general and for anywhere else we may rely on loading arbitrary libraries
60671166,430,https://api.github.com/repos/dotnet/coreclr/issues/430,mirhagk,3,0,0,0,0,0,tracing garbage collection is great for throughput and c has a pretty well tuned garbage collector even if its a little out of date w.r.t academic papers but there are scenarios where throughput does not matter as much as consistent predictable performance or scenarios that use a lot of memory and cant afford to pay the price of a tracing collector in either pausing or memory consumption.video games are a very common situation where tracing collection can be disastrous and a lot of programmers have to work around this with object pools and the like essentially managing memory themselves.itd be nice if it was possible to swap out the garbage collector in net like it is possible with many java implementations and a reference counter would be a useful one to swap out for of course it should not change any guarantees that the language has so therell have to be a backup cycle collector but merely change throughput pausing performance and memory consumption.this would obviously be a very big change as the gc is very tuned and quite a lot of code and the new reference gc would need to be able to hook in to assignments and variable scope but it has the potential to make c that much more attractive to certain scenarios such as game programming).alternatively this could be a consideration for net native only as net native already seeks to reduce memory consumption on constrained devices and reference counting has many similar goals this is basically a request to consider reference counting as an alternative garbage collector somewhere in the net ecosystem
60145872,408,https://api.github.com/repos/dotnet/coreclr/issues/408,ala53,9,0,0,0,0,0,per the nightmarish pr it was recommended i open an issue to discuss reorganizing gc.cpp.for those that arent familiar gc.cpp is a line file which seems to contain the entire garbage collector and gcpriv.h is a line header which seems to correspond to gc.cpp.so what would be the best way to split gc.cpp into its components.we could split by function allocator mark phase sweep phase deallocator etc.we could split by class gcstatistics gcmechanisms gcallocator etc.we could split into allocator deallocator and garbage collector.or something not mentioned here...what ive identified so far there are commented defines for the same function dprintf max_generation something seemingly globally needed is a private enum hidden in gc.h
57432873,229,https://api.github.com/repos/dotnet/coreclr/issues/229,IDisposable,2,0,0,0,0,0,as documented in connect bug string.gethashcode ignores any characters in the string beyond the first null character in x runtime this means that if someone embeds a null character in a string the hash-code will only be computed up to that character this is wrong in that clr string instances are length specified and embedded null character are significant and characters after it are important to the hash-code.note the return value in bit builds does take all characters into account so the strings that have a nice distribution in x builds might generate horrific collisions in x builds while as an implementation detail the string buffer is always followed by a null character this is merely to ease the interop issues and has nothing to do with how strings should be handled in pure clr changing the hash-code in a new build is not a breaking change just look at the comment in line
56516882,60,https://api.github.com/repos/dotnet/coreclr/issues/60,borgdylan,1,0,0,0,0,0,i realize that currently only linux on bit is supported will linux on bit x and on arm be supported as well
56442062,36,https://api.github.com/repos/dotnet/coreclr/issues/36,benaadams,1,0,0,0,0,0,avoid unnecessary work for identical locations in buffer.blockcopyperform validity checks to ensure parameters are correct but short-circuitout memmove when exactly the same data would be copied to the same location.there are a number of occasions which can be intentional or unintentional where the buffer being copied is the same place e.g an internal buffer is the same as the return buffer and there is no need to call memmoves overwrite safe copy generally the call to blockcopy will be in a library so it is more practicalto enable the check here rather than alter all the calling functions including rd party libraries to preform additional checks
